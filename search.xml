<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>回文数的判断方法</title>
      <link href="/2023/08/23/%E5%9B%9E%E6%96%87%E6%95%B0%E7%9A%84%E5%88%A4%E6%96%AD%E6%96%B9%E6%B3%95/"/>
      <url>/2023/08/23/%E5%9B%9E%E6%96%87%E6%95%B0%E7%9A%84%E5%88%A4%E6%96%AD%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h3 id="判断回文数-有很多方法-记录几种方法如下"><a href="#判断回文数-有很多方法-记录几种方法如下" class="headerlink" title="判断回文数 有很多方法 记录几种方法如下"></a>判断回文数 有很多方法 记录几种方法如下</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">def judge1(data):</span><br><span class="line">    data = str(data)</span><br><span class="line">    if data == &#x27;&#x27;.join(reversed(data)):</span><br><span class="line">        return True</span><br><span class="line">    else:</span><br><span class="line">        return False</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def judge2(data):</span><br><span class="line">    data = str(data)</span><br><span class="line">    if data == data[::-1]:</span><br><span class="line">        return True</span><br><span class="line">    else:</span><br><span class="line">        return False</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def judge3(data):</span><br><span class="line">    # judge1和2都是利用str类型做判断 judge3使用的是整形</span><br><span class="line">    help = 1</span><br><span class="line">    # 生成一个辅助变量help 跟data的位数一致</span><br><span class="line">    while (data / help &gt;= 10):</span><br><span class="line">        help *= 10</span><br><span class="line">    print(help)</span><br><span class="line">    while (data != 0):</span><br><span class="line">        # 对比每一位是否相等</span><br><span class="line">        if (data // help != data % 10):</span><br><span class="line">            return False</span><br><span class="line">        # 调整data和help的位数</span><br><span class="line">        data = (data % help) // 10</span><br><span class="line">        help //= 100</span><br><span class="line">        print(data)</span><br><span class="line">        print(help)</span><br><span class="line">    return True</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    data = 123321</span><br><span class="line">    if judge3(data):</span><br><span class="line">        print(f&quot;&#123;data&#125;是回文数&quot;)</span><br><span class="line">    else:</span><br><span class="line">        print(f&#x27;&#123;data&#125;不是回文数&#x27;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>每日一题-超级回文数</title>
      <link href="/2023/08/23/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-%E8%B6%85%E7%BA%A7%E5%9B%9E%E6%96%87%E6%95%B0/"/>
      <url>/2023/08/23/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-%E8%B6%85%E7%BA%A7%E5%9B%9E%E6%96%87%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="题目简介"><a href="#题目简介" class="headerlink" title="题目简介"></a>题目简介</h3><p>如果一个正整数自身是一个回文数，而且他也是一个回文数的平方，那么我们称这个数为超级回文数<br>现在我们给定义两个正整数L和R（字符串形式表示）返回包含在范围[L,R]中的超级回文数的数目<br>回文数就是从左往右和从右往左的顺序一致的整数例如121 232<br>实例:<br>输入L&#x3D;’4’R&#x3D;’1000’<br>输出 4<br>解释：4，9,121以及484是超级回文数 要注意的是676不是超级回文数 26*26 &#x3D; 676 但是26不是回文数</p><h3 id="函数解释"><a href="#函数解释" class="headerlink" title="函数解释"></a>函数解释</h3><pre><code>减小问题的规模 提高计算效率 修改最大限制 题目要求的是R小于10的18次方 运算量太大经过分析可以得知 如果把R先开方再对半除就能得到最大限制limit是10的5次方从0开始使用函数palindrome_number_make去创建回文数再平方该回文数传参给函数palindrome_number_judge判断是不是回文数再判断生成的回文数的平方是不是在题目所给的范围内，如果满足以上要求那么就是超级回文数让result加1最后将结果返回</code></pre><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">def palindrome_number_judge(data):</span><br><span class="line">    # 判断传入的data是不是回文数</span><br><span class="line">    data = str(data)</span><br><span class="line">    if data == data[::-1]:</span><br><span class="line">        return True</span><br><span class="line">    else:</span><br><span class="line">        return False</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def palindrome_number_make(data):</span><br><span class="line">    # 加工回文数生成 一个data生成两个回文数分别是奇数长度回文数和偶数长度回文数</span><br><span class="line">    # 比如data = 1，然后加工出的回文数是11和1</span><br><span class="line">    # data是123，加工出的回文数是123321和12321</span><br><span class="line">    if data &gt;= 10:</span><br><span class="line">        data = str(data)</span><br><span class="line">        data_1 = data + data[::-1]</span><br><span class="line">        data_2 = data + data[-2::-1]</span><br><span class="line">    else:</span><br><span class="line">        data = str(data)</span><br><span class="line">        data_1 = data</span><br><span class="line">        data_2 = data + data[::-1]</span><br><span class="line">    data_1 = int(data_1)</span><br><span class="line">    data_2 = int(data_2)</span><br><span class="line">    return data_1, data_2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def reduce_que_size(L, R):</span><br><span class="line"></span><br><span class="line">    limit = 100000</span><br><span class="line">    result = 0</span><br><span class="line">    for data in range(limit):</span><br><span class="line">        data_1, data_2 = palindrome_number_make(data)</span><br><span class="line">        if data_1 ** 2 &gt; R:</span><br><span class="line">            break</span><br><span class="line">        if palindrome_number_judge(data_1 * data_1) and L &lt;= data_1 ** 2:</span><br><span class="line">            result += 1</span><br><span class="line"></span><br><span class="line">    for data in range(limit):</span><br><span class="line">        data_1, data_2 = palindrome_number_make(data)</span><br><span class="line">        if data_2 ** 2 &gt; R:</span><br><span class="line">            break</span><br><span class="line">        if palindrome_number_judge(data_2 * data_2) and L &lt;= data_2 ** 2:</span><br><span class="line">            result += 1</span><br><span class="line">    return result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    print(reduce_que_size(1, 5))</span><br><span class="line">    print(palindrome_number_make(9))</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>每日一题-无线环绕字符串中寻找非空子串问题</title>
      <link href="/2023/08/22/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-%E6%97%A0%E7%BA%BF%E7%8E%AF%E7%BB%95%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E5%AF%BB%E6%89%BE%E9%9D%9E%E7%A9%BA%E5%AD%90%E4%B8%B2%E9%97%AE%E9%A2%98/"/>
      <url>/2023/08/22/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-%E6%97%A0%E7%BA%BF%E7%8E%AF%E7%BB%95%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E5%AF%BB%E6%89%BE%E9%9D%9E%E7%A9%BA%E5%AD%90%E4%B8%B2%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="题目简介"><a href="#题目简介" class="headerlink" title="题目简介"></a>题目简介</h3><p>无线环绕字符串寻找非空子串问题：假设有一个想象的字符串f：…a-z a-z a-z…这样循环，现有一字符串s，请找出字符串s中不重复的<br>非空的子串在想象串f中的不重复非空子串的个数</p><h3 id="解析："><a href="#解析：" class="headerlink" title="解析："></a>解析：</h3><p>将字符串s从左到右依次寻找，第一个以a结尾的子串在f中的个数是1是a，第二个以a结尾的子串在f中的个数是3分别是a za yza，可以看出第二个以a结尾的子串<br>在f中的个数包含了第一个以a结尾的子串，因此可以知道，以相同字母结尾的子串在f中的个数取最大值即可，所以以s串中的每一个字母结尾的子串在f中能找到的<br>个数分别是 a:1 b:2 y:1 z:2 a: 3 b :4,然后将数据整合放入dict中可以得到a:3 b:4 y:1 z:2，将每一个字母的value值加起来就是本题的解</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">def build_f():</span><br><span class="line">    # f串的构建</span><br><span class="line">    f = [chr(i) for i in range(97, 123)]</span><br><span class="line">    f = &quot;&quot;.join(f)</span><br><span class="line">    # 假设是3倍a-z</span><br><span class="line">    f = f * 3</span><br><span class="line">    return f</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def search_str(s):</span><br><span class="line">    # 搜索字符串方法</span><br><span class="line">    # 默认长度为1 str_len是前一个字符成长的长度</span><br><span class="line">    str_len = 1</span><br><span class="line">    str_dict = &#123;&#125;</span><br><span class="line">    for i in range(len(s)):</span><br><span class="line">        cur = s[i]  # 当前的字符串</span><br><span class="line">        pre = s[i - 1]  # 之前的字符串</span><br><span class="line">        if cur == &#x27;a&#x27; and pre == &#x27;z&#x27;:</span><br><span class="line">            str_len += 1</span><br><span class="line">        elif chr(ord(pre) + 1) == cur:</span><br><span class="line">            str_len += 1</span><br><span class="line">        else:</span><br><span class="line">            str_len = 1</span><br><span class="line">        # 将数据放入dict中</span><br><span class="line">        if str_dict.get(s[i]):</span><br><span class="line">            if str_len&gt;str_dict[s[i]]:</span><br><span class="line">                str_dict.update(&#123;s[i]: str_len&#125;)</span><br><span class="line">        else:</span><br><span class="line">            str_dict.update(&#123;s[i]: str_len&#125;)</span><br><span class="line"></span><br><span class="line">    return str_dict</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    # f = &#x27;...a-z a-z a-z...&#x27;</span><br><span class="line">    s = &#x27;abyzab&#x27;</span><br><span class="line">    # f串没用上 只是一个假设的串</span><br><span class="line">    f = build_f()</span><br><span class="line">    print(search_str(s))</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>算法进阶-动态规划</title>
      <link href="/2023/07/27/%E7%AE%97%E6%B3%95%E8%BF%9B%E9%98%B6-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
      <url>/2023/07/27/%E7%AE%97%E6%B3%95%E8%BF%9B%E9%98%B6-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
      
        <content type="html"><![CDATA[<h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>动态规划（英语：Dynamic programming，简称 DP），是一种在数学、管理科学、计算机科学、经济学和生物信息学中使用的，通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。动态规划常常适用于有重叠子问题和最优子结构性质的问题。<br>以上定义来自维基百科，看定义感觉还是有点抽象。简单来说，动态规划其实就是，给定一个问题，我们把它拆成一个个子问题，直到子问题可以直接解决。然后呢，把子问题答案保存起来，以减少重复计算。再根据子问题答案反推，得出原问题解的一种方法。<br>动态规划最核心的思想，就在于拆分子问题，记住过往，减少重复计算。<br>摘自：<a href="https://zhuanlan.zhihu.com/p/365698607">https://zhuanlan.zhihu.com/p/365698607</a></p><h3 id="斐波那契数列看动态规划"><a href="#斐波那契数列看动态规划" class="headerlink" title="斐波那契数列看动态规划"></a>斐波那契数列看动态规划</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">def fibnacci(n):</span><br><span class="line">    f = [0, 1, 1]</span><br><span class="line">    if n &gt; 2:</span><br><span class="line">        for i in range(n - 2):</span><br><span class="line">            num = f[-1] + f[-2]</span><br><span class="line">            f.append(num)</span><br><span class="line">    return f[n]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(fibnacci(100))</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>算法进阶-贪心算法</title>
      <link href="/2023/07/26/%E7%AE%97%E6%B3%95%E8%BF%9B%E9%98%B6-%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
      <url>/2023/07/26/%E7%AE%97%E6%B3%95%E8%BF%9B%E9%98%B6-%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h2><p>又称贪婪算法，是指在对问题求解时，总是做出在当前看来是最好的选择，也就是说，不从整体最优上加以考虑<br>贪心算法所做的是在某种意义上的局部最优解<br>贪心算法并不保证会得到最优解，但是在某些问题上贪心算法的解就是最优解。<br>要会判断一个问题是否能用贪心算法解决</p><h3 id="模拟商店找零问题"><a href="#模拟商店找零问题" class="headerlink" title="模拟商店找零问题"></a>模拟商店找零问题</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># change函数需要两个参数t是找零面值list，n是你输入的要找零金额</span><br><span class="line"># 找零的面值如下：</span><br><span class="line">t = [100, 50, 20, 5, 1]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def change(t, n):</span><br><span class="line">    m = [0 for _ in range(len(t))]</span><br><span class="line">    for i, money in enumerate(t):</span><br><span class="line">    # enumerate用来给t列表的每一项一个索引，默认从0开始，用在for循环中就是把索引值赋给i</span><br><span class="line">        m[i] = n // money</span><br><span class="line">        n = n % money</span><br><span class="line">    return m, n</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 打印366元的找零结果</span><br><span class="line">print(change(t, 376))</span><br></pre></td></tr></table></figure><h3 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h3><p>0-1背包：对于一个商品，要么拿走要么留下，不能拿走1部分<br>分数背包：对一个商品，可以拿走其中一部分<br>举例：v和w分别是价值和重量<br>商品1：v1&#x3D; 60 w1 &#x3D;10<br>商品2：v2 &#x3D; 100 w2 &#x3D; 20<br>商品3：v3 &#x3D; 120 w3 &#x3D; 30<br>背包容量 w&#x3D;50</p><h4 id="分数背包的实现"><a href="#分数背包的实现" class="headerlink" title="分数背包的实现"></a>分数背包的实现</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">goods = [(60, 10), (120, 30), (100, 20)]</span><br><span class="line"># 单位重量下更值钱的商品 降序排列</span><br><span class="line">goods.sort(key=lambda x: x[0] / x[1], reverse=True)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def fractional_bakcpack(goods, w):</span><br><span class="line">    m = [0 for _ in range(len(goods))]</span><br><span class="line">    total_v = 0</span><br><span class="line">    for i, (prize, weight) in enumerate(goods):</span><br><span class="line">        if w &gt;= weight:</span><br><span class="line">            m[i] = 1</span><br><span class="line">            total_v += prize</span><br><span class="line">            w -= weight</span><br><span class="line">        else:</span><br><span class="line">            m[i] = w / weight</span><br><span class="line">            total_v += m[i] * prize</span><br><span class="line">            w = 0</span><br><span class="line">            break</span><br><span class="line">    return total_v,m</span><br><span class="line"></span><br><span class="line">print(goods)</span><br><span class="line">print(fractional_bakcpack(goods, 50))</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="拼接最大数字问题"><a href="#拼接最大数字问题" class="headerlink" title="拼接最大数字问题"></a>拼接最大数字问题</h3><p>问题描述：<br>有n个非负整数，将其按照字符串拼接的方式拼接为一个整数，如何拼接可以使得到的的整数最大？<br>例如：32,94,128,1286,6,71 可以拼接的最大整数为94716321286128</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">from functools import cmp_to_key</span><br><span class="line">li = [32,94,128,1286,6,71]</span><br><span class="line">def xy_cmp(x,y):</span><br><span class="line">    if x+y &lt;y+x:</span><br><span class="line">        return 1</span><br><span class="line">    elif x+y&gt;y+x:</span><br><span class="line">        return -1</span><br><span class="line">    else:</span><br><span class="line">        return 0</span><br><span class="line"></span><br><span class="line">def number_join(li):</span><br><span class="line">    li = list(map(str,li))</span><br><span class="line">    li.sort(key=cmp_to_key(xy_cmp))</span><br><span class="line">    return &quot;&quot;.join(li)</span><br><span class="line"></span><br><span class="line">print(number_join(li))</span><br></pre></td></tr></table></figure><h3 id="活动选择问题"><a href="#活动选择问题" class="headerlink" title="活动选择问题"></a>活动选择问题</h3><p>问题概述：<br>假设有n个活动，这些活动要占用同一片场地，而场地在某个时刻只能供一个和活动使用。<br>每个活动都有一个开始时间si和结束时间fi（题目中时间以整数表示），表示活动在[si,fi)区间占用场地<br>问：安排哪些活动能够使改场地举办的活动个数最多？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">activities = [</span><br><span class="line">    (1, 4),</span><br><span class="line">    (3, 5),</span><br><span class="line">    (0, 6),</span><br><span class="line">    (5, 7),</span><br><span class="line">    (3, 9),</span><br><span class="line">    (5, 9),</span><br><span class="line">    (6, 10),</span><br><span class="line">    (8, 11),</span><br><span class="line">    (8, 12),</span><br><span class="line">    (2, 14),</span><br><span class="line">    (12, 16)</span><br><span class="line">]</span><br><span class="line"># 排序保证活动是按照结束时间排好序的</span><br><span class="line">activities.sort(key=lambda x: x[1])</span><br><span class="line">print(activities)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def activity_selection(a):</span><br><span class="line">    res = [a[0]]</span><br><span class="line">    for i in range(1, len(a)):</span><br><span class="line">        if a[i][0] &gt;= res[-1][1]:  # 当前活动开始时间小于等于最后一个入选活动的结束时间</span><br><span class="line">            # 不冲突</span><br><span class="line">            res.append(a[i])</span><br><span class="line">    return res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(activity_selection(activities))</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>数据结构-树与二叉树</title>
      <link href="/2023/07/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>/2023/07/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><p>树结构是一种包括节点(nodes)和边(edges)的拥有层级关系的一种结构， 它的形式和家谱树非常类似.<br>linux 文件结构（tree 命令），它的结构也是一棵树。<br>根节点(root): 树的最上层的节点，任何非空的树都有一个节点<br>路径(path): 从起始节点到终止节点经历过的边<br>父亲(parent)：除了根节点，每个节点的上一层边连接的节点就是它的父亲(节点)<br>孩子(children): 每个节点由边指向的下一层节点<br>兄弟(siblings): 同一个父亲并且处在同一层的节点<br>子树(subtree): 每个节点包含它所有的后代组成的子树<br>叶子节点(leaf node): 没有孩子的节点成为叶子节点</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">class Node:</span><br><span class="line">    # 链式存储的方式存储树</span><br><span class="line">    def __init__(self, name, type=&#x27;dir&#x27;):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.type = type</span><br><span class="line">        self.children = []</span><br><span class="line">        self.parent = None</span><br><span class="line"></span><br><span class="line">    def __repr__(self):</span><br><span class="line">        return self.name</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class FileSystemTree:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.root = Node(&quot;/&quot;)</span><br><span class="line">        self.now = self.root</span><br><span class="line"></span><br><span class="line">    def mkdir(self, name):</span><br><span class="line">        if name[-1] != &quot;/&quot;:</span><br><span class="line">            name += &quot;/&quot;</span><br><span class="line">        node = Node(name)</span><br><span class="line">        self.now.children.append(node)</span><br><span class="line">        node.parent = self.now</span><br><span class="line"></span><br><span class="line">    def ls(self):</span><br><span class="line">        return self.now.children</span><br><span class="line"></span><br><span class="line">    def cd(self, name):</span><br><span class="line">        if name[-1] != &quot;/&quot;:</span><br><span class="line">            name += &quot;/&quot;</span><br><span class="line">        if name == &quot;../&quot;:</span><br><span class="line">            self.now = self.now.parent</span><br><span class="line">            return</span><br><span class="line">        for child in self.now.children:</span><br><span class="line">            if child.name == name:</span><br><span class="line">                self.now = child</span><br><span class="line">                return</span><br><span class="line">        raise ValueError(&quot;invalid dir&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">tree = FileSystemTree()</span><br><span class="line">tree.mkdir(&quot;var/&quot;)</span><br><span class="line">tree.mkdir(&quot;bin/&quot;)</span><br><span class="line">tree.mkdir(&quot;usr/&quot;)</span><br><span class="line">print(tree.ls())</span><br><span class="line">tree.cd(&quot;bin/&quot;)</span><br><span class="line">tree.mkdir(&quot;pyhton/&quot;)</span><br><span class="line">print(tree.ls())</span><br><span class="line">tree.cd(&quot;../&quot;)</span><br><span class="line">print(tree.ls())</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><p>了解完树的结构以后，我们来看树结构里一种简单但是却比较常用的树-二叉树。<br>二叉树是一种简单的树，它的每个节点最多只能包含两个孩子.<br>通过上边这幅图再来看几个二叉树相关的概念:<br>节点深度(depth): 节点对应的 level 数字<br>树的高度(height): 二叉树的高度就是 level 数 + 1，因为 level 从 0开始计算的<br>树的宽度(width): 二叉树的宽度指的是包含最多节点的层级的节点数<br>树的 size：二叉树的节点总个数。</p><h3 id="满二叉树-full-binary-tree"><a href="#满二叉树-full-binary-tree" class="headerlink" title="满二叉树(full binary tree)"></a>满二叉树(full binary tree)</h3><p>如果每个内部节点（非叶节点）都包含两个孩子，就成为满二叉树。</p><h3 id="完美二叉树-perfect-binary-tree"><a href="#完美二叉树-perfect-binary-tree" class="headerlink" title="完美二叉树(perfect binary tree)"></a>完美二叉树(perfect binary tree)</h3><p>当所有的叶子节点都在同一层就是完美二叉树，毫无间隙填充了 h 层。</p><h3 id="完全二叉树-complete-binary-tree"><a href="#完全二叉树-complete-binary-tree" class="headerlink" title="完全二叉树(complete binary tree)"></a>完全二叉树(complete binary tree)</h3><p>当一个高度为 h 的完美二叉树减少到 h-1，并且最底层的槽被毫无间隙地从左到右填充，我们就叫它完全二叉树</p><h3 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h3><p>二叉树其实是一种递归结构，因为单独拿出来一个 subtree 子树出来，其实它还是一棵树。那遍历它就很方便啦，我们可以直接用递归的方式来遍历它。但是当处理顺序不同的时候，树又分为三种遍历方式:</p><p>先(根)序遍历: 先处理根，之后是左子树，然后是右子树<br>中(根)序遍历: 先处理左子树，之后是根，最后是右子树<br>后(根)序遍历: 先处理左子树，之后是右子树，最后是根</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">class BitreeNode:</span><br><span class="line">    def __init__(self, data):</span><br><span class="line">        self.data = data</span><br><span class="line">        self.lchild = None  # 左孩子</span><br><span class="line">        self.rchild = None  # 右孩子</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 手动创建二叉树创建节点</span><br><span class="line">a = BitreeNode(&quot;A&quot;)</span><br><span class="line">b = BitreeNode(&quot;B&quot;)</span><br><span class="line">c = BitreeNode(&quot;C&quot;)</span><br><span class="line">d = BitreeNode(&quot;D&quot;)</span><br><span class="line">e = BitreeNode(&quot;E&quot;)</span><br><span class="line">f = BitreeNode(&quot;F&quot;)</span><br><span class="line">g = BitreeNode(&quot;G&quot;)</span><br><span class="line"></span><br><span class="line">e.lchild = a</span><br><span class="line">e.rchild = g</span><br><span class="line">a.rchild = c</span><br><span class="line">c.lchild = b</span><br><span class="line">c.rchild = d</span><br><span class="line">g.rchild = f</span><br><span class="line"></span><br><span class="line">root = e</span><br><span class="line">print(root.lchild.rchild.data)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def pre_order(root):</span><br><span class="line">    # 前序遍历</span><br><span class="line">    if root:</span><br><span class="line">        print(root.data, end=&quot;,&quot;)</span><br><span class="line">        pre_order(root.lchild)</span><br><span class="line">        pre_order(root.rchild)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def in_order(root):</span><br><span class="line">    # 中序遍历</span><br><span class="line">    if root:</span><br><span class="line">        in_order(root.lchild)</span><br><span class="line">        print(root.data, end=&quot;,&quot;)</span><br><span class="line">        in_order(root.rchild)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def post_order(root):</span><br><span class="line">    # 后序遍历</span><br><span class="line">    if root:</span><br><span class="line">        post_order(root.lchild)</span><br><span class="line">        post_order(root.rchild)</span><br><span class="line">        print(root.data, end=&quot;,&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">from collections import deque</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def level_order(root):</span><br><span class="line">    # 层次遍历</span><br><span class="line">    queue = deque()</span><br><span class="line">    queue.append(root)</span><br><span class="line">    while len(queue) &gt; 0:</span><br><span class="line">        node = queue.popleft()</span><br><span class="line">        print(node.data, end=&#x27;,&#x27;)</span><br><span class="line">        if node.lchild:</span><br><span class="line">            queue.append(node.lchild)</span><br><span class="line">        if node.rchild:</span><br><span class="line">            queue.append(node.rchild)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pre_order(root)</span><br><span class="line">print()</span><br><span class="line">in_order(root)</span><br><span class="line">print()</span><br><span class="line">post_order(root)</span><br><span class="line">print()</span><br><span class="line">level_order(root)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h2><p>二叉搜索树是一个二叉树且满足在性质：<br>设x是二叉树的一个节点。如果y是x左子树的一个节点，那么y.key&lt;&#x3D;x.key;<br>如果y是x右子树的一个节点，那么y.key&gt;&#x3D;x.key<br>二叉搜索树的操作：查询、插入、删除</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br></pre></td><td class="code"><pre><span class="line">import random</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class BitreeNode:</span><br><span class="line">    def __init__(self, data):</span><br><span class="line">        self.data = data</span><br><span class="line">        self.lchild = None  # 左孩子</span><br><span class="line">        self.rchild = None  # 右孩子</span><br><span class="line">        self.parent = None  # 父节点</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class BST:</span><br><span class="line">    def __init__(self, li=None):</span><br><span class="line">        self.root = None</span><br><span class="line">        if li:</span><br><span class="line">            for val in li:</span><br><span class="line">                self.insert_norec(val)</span><br><span class="line"></span><br><span class="line">    def insert(self, node, val):</span><br><span class="line">        if not node:</span><br><span class="line">            node = BitreeNode(val)</span><br><span class="line">        elif val &lt; node.data:</span><br><span class="line">            node.lchild = self.insert(node.lchild, val)</span><br><span class="line">            node.lchild.parent = node</span><br><span class="line">        elif val &gt; node.data:</span><br><span class="line">            node.rchild = self.insert(node.rchild, val)</span><br><span class="line">            node.rchild.parent = node</span><br><span class="line">        else:</span><br><span class="line">            pass</span><br><span class="line">        return node</span><br><span class="line"></span><br><span class="line">    def insert_norec(self, val):</span><br><span class="line">        # 非递归插入</span><br><span class="line">        p = self.root</span><br><span class="line">        if not p:  # 空数</span><br><span class="line">            self.root = BitreeNode(val)</span><br><span class="line">            return</span><br><span class="line">        while True:</span><br><span class="line">            if val &lt; p.data:</span><br><span class="line">                if p.lchild:</span><br><span class="line">                    p = p.lchild</span><br><span class="line">                else:  # 左孩子不存在时</span><br><span class="line">                    p.lchild = BitreeNode(val)</span><br><span class="line">                    p.lchild.parent = p</span><br><span class="line">                    return</span><br><span class="line">            elif val &gt; p.data:</span><br><span class="line">                if p.rchild:</span><br><span class="line">                    p = p.rchild</span><br><span class="line">                else:</span><br><span class="line">                    p.rchild = BitreeNode(val)</span><br><span class="line">                    p.rchild.parent = p</span><br><span class="line">                    return</span><br><span class="line">            else:</span><br><span class="line">                return</span><br><span class="line"></span><br><span class="line">    def query(self, node, val):</span><br><span class="line">        # 查询</span><br><span class="line">        if not node:</span><br><span class="line">            return None</span><br><span class="line">        if node.data &lt; val:</span><br><span class="line">            return self.query(node.rchild, val)</span><br><span class="line">        elif node.data &gt; val:</span><br><span class="line">            return self.query(node.rchild, val)</span><br><span class="line">        else:</span><br><span class="line">            return node</span><br><span class="line"></span><br><span class="line">    def query_norec(self, val):</span><br><span class="line">        # 非递归查询</span><br><span class="line">        p = self.root</span><br><span class="line">        while p:</span><br><span class="line">            if p.data &lt; val:</span><br><span class="line">                p = p.rchild</span><br><span class="line">            elif p.data &gt; val:</span><br><span class="line">                p = p.lchild</span><br><span class="line">            else:</span><br><span class="line">                return p</span><br><span class="line">        else:</span><br><span class="line">            return None</span><br><span class="line"></span><br><span class="line">    def remove_node1(self, node):</span><br><span class="line">        # 删除的情况1 node是叶子节点没有孩子</span><br><span class="line">        if not node.parent:</span><br><span class="line">            # 判断是不是根节点</span><br><span class="line">            self.root = None</span><br><span class="line">        if node.parent == node.parent.lchild:</span><br><span class="line">            # node是父亲的左孩子</span><br><span class="line">            node.parent.lchild = None</span><br><span class="line">        else:</span><br><span class="line">            # node是父亲的右孩子</span><br><span class="line">            node.parent.rchild = None</span><br><span class="line"></span><br><span class="line">    def remove_node21(self, node):</span><br><span class="line">        # 删除的情况2.1 node只有一个左孩子</span><br><span class="line">        if not node.parent:</span><br><span class="line">            self.root = node.lchild</span><br><span class="line">            node.lchild.parent = None</span><br><span class="line">        elif node == node.parent.lchild:</span><br><span class="line">            node.parent.lchild = node.lchild</span><br><span class="line">            node.lchild.parent = node.parent</span><br><span class="line">        else:</span><br><span class="line">            node.parent.rchild = node.lchild</span><br><span class="line">            node.lchild.parent = node.parent</span><br><span class="line"></span><br><span class="line">    def remove_node22(self, node):</span><br><span class="line">        # 删除情况2.2 node只有一个右孩子</span><br><span class="line">        if not node.parent:</span><br><span class="line">            self.root = node.rchild</span><br><span class="line">            node.rchild.parent = None</span><br><span class="line">        elif node == node.parent.lchild:</span><br><span class="line">            node.parent.lchild = node.rchild</span><br><span class="line">            node.rchild.parent = node.parent</span><br><span class="line">        else:</span><br><span class="line">            node.parent.rchild = node.rchild</span><br><span class="line">            node.rchild.parent = node.parent</span><br><span class="line"></span><br><span class="line">    def delete(self, val):</span><br><span class="line">        if self.root:</span><br><span class="line">            # 不是空树再删除</span><br><span class="line">            node = self.query_norec(val)</span><br><span class="line">            if not node:</span><br><span class="line">                return False</span><br><span class="line">            # 存在node</span><br><span class="line">            if not node.lchild and not node.rchild:</span><br><span class="line">                # 情况1 没有左孩子也没有右孩子</span><br><span class="line">                self.remove_node1(node)</span><br><span class="line">            elif not node.rchild:</span><br><span class="line">                # 情况2.1只有一个左孩子</span><br><span class="line">                self.remove_node21(node)</span><br><span class="line">            elif not node.lchild:</span><br><span class="line">                # 情况2.2 只有一个右孩子</span><br><span class="line">                self.remove_node22(node)</span><br><span class="line">            else:</span><br><span class="line">                #  情况3 两个孩子都有</span><br><span class="line">                min_node = node.rchild  # min_node就是右子树里最小的节点</span><br><span class="line">                while min_node == min_node.lchild:</span><br><span class="line">                    min_node = min_node.lchild</span><br><span class="line">                node.data = min_node.data</span><br><span class="line">                # 删除min_node</span><br><span class="line">                if min_node.rchild:</span><br><span class="line">                    self.remove_node22(min_node)</span><br><span class="line">                else:</span><br><span class="line">                    self.remove_node1(min_node)</span><br><span class="line"></span><br><span class="line">    def pre_order(self, root):</span><br><span class="line">        # 前序遍历</span><br><span class="line">        if root:</span><br><span class="line">            print(root.data, end=&quot;,&quot;)</span><br><span class="line">            self.pre_order(root.lchild)</span><br><span class="line">            self.pre_order(root.rchild)</span><br><span class="line"></span><br><span class="line">    def in_order(self, root):</span><br><span class="line">        # 中序遍历</span><br><span class="line">        if root:</span><br><span class="line">            self.in_order(root.lchild)</span><br><span class="line">            print(root.data, end=&quot;,&quot;)</span><br><span class="line">            self.in_order(root.rchild)</span><br><span class="line"></span><br><span class="line">    def post_order(self, root):</span><br><span class="line">        # 后序遍历</span><br><span class="line">        if root:</span><br><span class="line">            self.post_order(root.lchild)</span><br><span class="line">            self.post_order(root.rchild)</span><br><span class="line">            print(root.data, end=&quot;,&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 遍历</span><br><span class="line">tree = BST([4, 6, 7, 9, 2, 1, 3, 5, 8])</span><br><span class="line">print(&quot;前序遍历：&quot;)</span><br><span class="line">tree.pre_order(tree.root)</span><br><span class="line">print()</span><br><span class="line">print(&quot;中序遍历(对于二叉搜索树来说中序遍历一定是升序的)：&quot;)</span><br><span class="line">tree.in_order(tree.root)</span><br><span class="line">print()</span><br><span class="line">print(&quot;后序遍历：&quot;)</span><br><span class="line">tree.post_order(tree.root)</span><br><span class="line">print()</span><br><span class="line"># 查询</span><br><span class="line">li = list(range(0, 500, 2))</span><br><span class="line">random.shuffle(li)</span><br><span class="line">tree = BST(li)</span><br><span class="line">print(tree.query_norec(4))</span><br><span class="line"># 删除</span><br><span class="line">tree = BST([1, 4, 2, 5, 3, 8, 9, 6, 9, 7])</span><br><span class="line">tree.in_order(tree.root)</span><br><span class="line">tree.delete(4)</span><br><span class="line">tree.delete(5)</span><br><span class="line">tree.delete(1)</span><br><span class="line">print()</span><br><span class="line">tree.in_order(tree.root)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="AVL树-代码看不懂-没学明白-暂时记录下来"><a href="#AVL树-代码看不懂-没学明白-暂时记录下来" class="headerlink" title="AVL树(代码看不懂 没学明白 暂时记录下来)"></a>AVL树(代码看不懂 没学明白 暂时记录下来)</h3><p>AVL树是一棵自平衡的二叉搜索树，具有以下性质:<br>树的左右子树高度差的绝对值不能超过1<br>根的左右子树都是平衡二叉树<br>AVL树的扩展应用：B树(B-Tree):<br>b树是一棵自平衡的多路搜索树，常用于数据库的索引</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line">from bst import BST, BitreeNode</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class AVLNode(BitreeNode):</span><br><span class="line">    def __init__(self, data):</span><br><span class="line">        BitreeNode.__init__(self, data)</span><br><span class="line">        self.bf = 0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class AVLTree(BST):</span><br><span class="line">    def __init__(self, li=None):</span><br><span class="line">        BST.__init__(self, li)</span><br><span class="line"></span><br><span class="line">    def rotate_left(self, p, c):</span><br><span class="line">        # 根的右孩子的右子树插入导致的不平衡：左旋操作</span><br><span class="line">        s2 = c.lchild</span><br><span class="line">        p.rchild = s2</span><br><span class="line">        if s2:</span><br><span class="line">            s2.parent = p</span><br><span class="line">        c.lchild = p</span><br><span class="line">        p.parent = c</span><br><span class="line">        # 更新平衡因子</span><br><span class="line">        p.bf = 0</span><br><span class="line">        c.bf = 0</span><br><span class="line">        return c</span><br><span class="line"></span><br><span class="line">    def rotate_right(self, p, c):</span><br><span class="line">        # 根的左孩子的左子树插入导致的不平衡：右旋操作</span><br><span class="line">        s2 = c.rchild</span><br><span class="line">        p.lchild = s2</span><br><span class="line">        if s2:</span><br><span class="line">            s2.parent = p</span><br><span class="line">        c.rchild = p</span><br><span class="line">        p.parent = c</span><br><span class="line">        # 更新平衡因子</span><br><span class="line">        p.bf = 0</span><br><span class="line">        c.bf = 0</span><br><span class="line">        return c</span><br><span class="line"></span><br><span class="line">    def rotate_right_left(self, p, c):</span><br><span class="line">        # 根的右孩子的左子树插入导致的不平衡，先右旋再左旋</span><br><span class="line">        g = c.lchild</span><br><span class="line">        s3 = g.rchild</span><br><span class="line">        c.lchild = s3</span><br><span class="line">        if s3:</span><br><span class="line">            s3.parent = c</span><br><span class="line">        g.rchild = c</span><br><span class="line">        c.parent = g</span><br><span class="line">        s2 = g.lchild</span><br><span class="line">        p.rchild = s2</span><br><span class="line">        if s2:</span><br><span class="line">            s2.parent = p</span><br><span class="line">        g.lchild = p</span><br><span class="line">        p.parent = g</span><br><span class="line">        # 更新平衡因子</span><br><span class="line">        if g.bf &gt; 0:</span><br><span class="line">            p.bf = -1</span><br><span class="line">            c.bf = 0</span><br><span class="line">        elif g.bf &lt; 0:</span><br><span class="line">            p.bf = 0</span><br><span class="line">            c.bf = 1</span><br><span class="line">        else:</span><br><span class="line">            p.bf = 0</span><br><span class="line">            c.bf = 0</span><br><span class="line"></span><br><span class="line">    def rotate_left_right(self, p, c):</span><br><span class="line">        # 根的左孩子的右子树插入导致的不平衡，先左旋再右旋</span><br><span class="line">        g = c.rchild</span><br><span class="line">        s2 = g.lchild</span><br><span class="line">        c.rchild = s2</span><br><span class="line">        if s2:</span><br><span class="line">            s2.parent = c</span><br><span class="line">        g.lchild = c</span><br><span class="line">        c.parent = g</span><br><span class="line">        s3 = g.rchild</span><br><span class="line">        p.lchild = s3</span><br><span class="line">        if s3:</span><br><span class="line">            s3.parent = p</span><br><span class="line">        g.rchild = p</span><br><span class="line">        p.parent = g</span><br><span class="line">        # 更新因子</span><br><span class="line">        if g.bf &lt; 0:</span><br><span class="line">            p.bf = 1</span><br><span class="line">            c.bf = 0</span><br><span class="line">        elif g.bf &gt; 0:</span><br><span class="line">            p.bf = 0</span><br><span class="line">            c.bf = -1</span><br><span class="line">        else:</span><br><span class="line">            p.bf = 0</span><br><span class="line">            c.bf = 0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>数据结构-链表</title>
      <link href="/2023/07/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/"/>
      <url>/2023/07/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p>链表也是比较常见的数据结构，其与数组经常做对比，<br>对于数组，需要连续的内存地址来存储数据，对内存的要求较高，而链表恰恰相反，它并不需要一块连续的内存空间，它通过“指针”将一组零散的内存块串联起来使用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">class Node:</span><br><span class="line">    def __init__(self, item):</span><br><span class="line">        self.item = item</span><br><span class="line">        self.next = None</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def create_head_linklist(li):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    头插法创建链表</span><br><span class="line">    :param li:</span><br><span class="line">    :return:</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    head = Node(li[0])</span><br><span class="line">    for element in li[1:]:</span><br><span class="line">        node = Node(element)</span><br><span class="line">        node.next = head</span><br><span class="line">        head = node</span><br><span class="line">    return head</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def create_tail_linklist(li):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    尾插法创建链表</span><br><span class="line">    :param li:</span><br><span class="line">    :return:</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    head = Node(li[0])</span><br><span class="line">    tail = head</span><br><span class="line">    for element in li[1:]:</span><br><span class="line">        node = Node(element)</span><br><span class="line">        tail.next = node</span><br><span class="line">        tail = node</span><br><span class="line">    return head</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def print_linklist(lk):</span><br><span class="line">    while lk:</span><br><span class="line">        print(lk.item, end=&quot;,&quot;)</span><br><span class="line">        lk = lk.next</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">lk1 = create_head_linklist([1, 2, 3, 4, 5])</span><br><span class="line">lk2 = create_tail_linklist([4, 5, 6, 7, 8])</span><br><span class="line">print_linklist(lk1)</span><br><span class="line">print()</span><br><span class="line">print_linklist(lk2)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>数据结构-hash表</title>
      <link href="/2023/07/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-hash%E8%A1%A8/"/>
      <url>/2023/07/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-hash%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><p>hash表又叫散列表<br>hash表是一种线性表的存储结构，哈希表由一个直接寻址表和一个哈希函数组成，哈希函数h(k)将元素关键字作为自变量，返回元素的存储下标<br>由于哈希表的大小是有限的，而要存储的值的总数量无限的，由此对于任何哈希函数，都会出现两个不同元素映射到同一个位置上的情况，这种情况被称为哈希冲突<br>解决哈希冲突：<br>开放寻址法：如果哈希函数返回的位置已经有了值，则可以向后探查新的位置来存储这个值<br>1、线性探查：如果位置i被占用，则探查i+1，i+2…<br>2、二次探查：如果位置i被占用，则探查i+1的平方、i-1的平方、i+2的平方、i-2的平方<br>3、二度哈希：有n个哈希函数，当使用第一个哈希函数h1发生冲突时，尝试使用哈希函数h2、h3<br>拉链法：哈希表的每一个位置都连接一个链表，当冲突发生后，冲突的元素将被加到改位置链表的最后<br>常见的hash函数：<br>1、除法哈希：h(k) &#x3D; k % m<br>2、乘法哈希：h(k) &#x3D; floor(m*(A<em>key%1))<br>3、全域哈希：ha,b(k) &#x3D; ((a</em>key+b)%p)%m   a,b &#x3D;1,2,..p-1<br>哈希表的应用：<br>python中的字典和集合都是使用和哈希表来实现的<br>文件的哈希值若是相同的，我们就认为这两个文件是相同的，因此用户可以通过md5来验证文件是否完整，云存储服务商可以利用它来判断用户<br>要上传的文件，是否已经存在相同服务器上，从而实现秒传功能同时避免存储过的相同的副本</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line">class LinkList:</span><br><span class="line">    class Node:</span><br><span class="line">        def __init__(self, item=None):</span><br><span class="line">            self.item = item</span><br><span class="line">            self.next = None</span><br><span class="line"></span><br><span class="line">    class LinkListIterator:</span><br><span class="line">        def __init__(self, node):</span><br><span class="line">            self.node = node</span><br><span class="line"></span><br><span class="line">        def __next__(self):</span><br><span class="line">            if self.node:</span><br><span class="line">                cur_node = self.node</span><br><span class="line">                self.node = cur_node.next</span><br><span class="line">                return cur_node.item</span><br><span class="line">            else:</span><br><span class="line">                raise StopIteration</span><br><span class="line"></span><br><span class="line">        def __iter__(self):</span><br><span class="line">            return self</span><br><span class="line"></span><br><span class="line">    def __init__(self, iterable=None):</span><br><span class="line">        self.head = None</span><br><span class="line">        self.tail = None</span><br><span class="line">        if iterable:</span><br><span class="line">            self.extend(iterable)</span><br><span class="line"></span><br><span class="line">    def append(self, obj):</span><br><span class="line">        s = LinkList.Node(obj)</span><br><span class="line">        if not self.head:</span><br><span class="line">            self.head = s</span><br><span class="line">            self.tail = s</span><br><span class="line">        else:</span><br><span class="line">            self.tail.next = s</span><br><span class="line">            self.tail = s</span><br><span class="line"></span><br><span class="line">    def extend(self, iterable):</span><br><span class="line">        for obj in iterable:</span><br><span class="line">            self.append(obj)</span><br><span class="line"></span><br><span class="line">    def find(self, obj):</span><br><span class="line">        for n in self:</span><br><span class="line">            if n == obj:</span><br><span class="line">                return True</span><br><span class="line">        else:</span><br><span class="line">            return False</span><br><span class="line"></span><br><span class="line">    def __iter__(self):</span><br><span class="line">        return self.LinkListIterator(self.head)</span><br><span class="line"></span><br><span class="line">    def __repr__(self):</span><br><span class="line">        return &quot;&lt;&lt;&quot; + &quot;,&quot;.join(map(str, self)) + &quot;&gt;&gt;&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 类似于集合的结构</span><br><span class="line">class HashTable:</span><br><span class="line">    def __init__(self, size=101):</span><br><span class="line">        self.size = size</span><br><span class="line">        self.T = [LinkList() for i in range(self.size)]</span><br><span class="line"></span><br><span class="line">    def h(self, k):</span><br><span class="line">        return k % self.size</span><br><span class="line"></span><br><span class="line">    # 插入</span><br><span class="line">    def insert(self, k):</span><br><span class="line">        i = self.h(k)</span><br><span class="line">        if self.find(k):</span><br><span class="line">            print(f&quot;Duplicated Inserted:值:&#123;k&#125;重复插入了&quot;)</span><br><span class="line">        else:</span><br><span class="line">            self.T[i].append(k)</span><br><span class="line"></span><br><span class="line">    # 查找</span><br><span class="line">    def find(self, k):</span><br><span class="line">        i = self.h(k)</span><br><span class="line">        return self.T[i].find(k)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ht = HashTable()</span><br><span class="line">ht.insert(0)</span><br><span class="line">ht.insert(1)</span><br><span class="line">ht.insert(102)</span><br><span class="line">ht.insert(2)</span><br><span class="line">ht.insert(3)</span><br><span class="line">ht.insert(508)</span><br><span class="line">ht.insert(4)</span><br><span class="line">ht.insert(5)</span><br><span class="line">print(&quot;,&quot;.join(map(str, ht.T)))</span><br><span class="line">print(ht.find(102))</span><br><span class="line">print(ht.find(200))</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>经典迷宫问题</title>
      <link href="/2023/07/24/%E7%BB%8F%E5%85%B8%E8%BF%B7%E5%AE%AB%E9%97%AE%E9%A2%98/"/>
      <url>/2023/07/24/%E7%BB%8F%E5%85%B8%E8%BF%B7%E5%AE%AB%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="迷宫问题简单描述"><a href="#迷宫问题简单描述" class="headerlink" title="迷宫问题简单描述"></a>迷宫问题简单描述</h2><p>指定起点和终点，使用深度优先和广度优先两种搜索算法来完成从起点到终点的整个过程，迷宫中1表示墙0表示路<br>深度优先搜索是完成从起点到终点的任务无法解决最短路径问题、广度优先可以解决最短路径问题</p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">maze = [</span><br><span class="line">    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],</span><br><span class="line">    [1, 0, 0, 1, 0, 0, 0, 1, 0, 1],</span><br><span class="line">    [1, 0, 0, 1, 0, 0, 0, 1, 0, 1],</span><br><span class="line">    [1, 0, 0, 0, 0, 1, 1, 0, 0, 1],</span><br><span class="line">    [1, 0, 1, 1, 1, 0, 0, 0, 0, 1],</span><br><span class="line">    [1, 0, 0, 0, 1, 0, 0, 0, 0, 1],</span><br><span class="line">    [1, 0, 1, 0, 0, 0, 1, 0, 0, 1],</span><br><span class="line">    [1, 0, 1, 1, 1, 0, 1, 1, 0, 1],</span><br><span class="line">    [1, 1, 0, 0, 0, 0, 0, 0, 0, 1],</span><br><span class="line">    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"># 表示上下左右</span><br><span class="line">dirs = [</span><br><span class="line">    lambda x, y: (x + 1, y),</span><br><span class="line">    lambda x, y: (x - 1, y),</span><br><span class="line">    lambda x, y: (x, y - 1),</span><br><span class="line">    lambda x, y: (x, y + 1),</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h2 id="深度优先py代码实现"><a href="#深度优先py代码实现" class="headerlink" title="深度优先py代码实现"></a>深度优先py代码实现</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">def maze_path_depth(x1, y1, x2, y2):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    深度优先搜索-代码简单但是路径不能保证是最短</span><br><span class="line">    :param x1:起点位置</span><br><span class="line">    :param y1: 起点位置</span><br><span class="line">    :param x2: 终点位置</span><br><span class="line">    :param y2: 终点位置</span><br><span class="line">    :return:</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    stack = []</span><br><span class="line">    stack.append((x1, y1))</span><br><span class="line">    while (len(stack) &gt; 0):</span><br><span class="line">        curNode = stack[-1]  # 当前节点</span><br><span class="line">        if curNode[0] == x2 and curNode[1] == y2:</span><br><span class="line">            # 走到终点了</span><br><span class="line">            for p in stack:</span><br><span class="line">                print(p, end=&quot;-&gt;&quot;)</span><br><span class="line">            return True</span><br><span class="line">        # x，y表示四个方向，上下左右分别是 x-1,y x+1,y x,y-1 x,y+1</span><br><span class="line">        for dir in dirs:</span><br><span class="line">            nextNode = dir(curNode[0], curNode[1])</span><br><span class="line">            # 如果下一个节点能走 就入栈</span><br><span class="line">            if maze[nextNode[0]][nextNode[1]] == 0:</span><br><span class="line">                stack.append(nextNode)</span><br><span class="line">                maze[nextNode[0]][nextNode[1]] = 2  # 2表示已经走过</span><br><span class="line">                break</span><br><span class="line">        else:</span><br><span class="line">            maze[nextNode[0]][nextNode[1]] = 2  # 2表示已经走过</span><br><span class="line">            stack.pop()</span><br><span class="line">    else:</span><br><span class="line">        print(&quot;没有路&quot;)</span><br><span class="line">        return False</span><br></pre></td></tr></table></figure><h2 id="广度优先py代码实现"><a href="#广度优先py代码实现" class="headerlink" title="广度优先py代码实现"></a>广度优先py代码实现</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">from collections import deque</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def print_r(path):</span><br><span class="line">    curNode = path[-1]</span><br><span class="line">    realpath = []</span><br><span class="line">    while curNode[2] != -1:</span><br><span class="line">        realpath.append(curNode[0:2])</span><br><span class="line">        curNode = path[curNode[2]]</span><br><span class="line">    realpath.append(curNode[0:2])  # 把起点放入path</span><br><span class="line">    realpath.reverse()</span><br><span class="line">    for node in realpath:</span><br><span class="line">        print(node, end=&quot;-&gt;&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def maze_path_queue(x1, y1, x2, y2):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    广度优先搜索</span><br><span class="line">    :param x1:起点位置</span><br><span class="line">    :param y1: 起点位置</span><br><span class="line">    :param x2: 终点位置</span><br><span class="line">    :param y2: 终点位置</span><br><span class="line">    :return:</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    queue = deque()</span><br><span class="line">    queue.append((x1, y1, -1))</span><br><span class="line">    path = []</span><br><span class="line">    while len(queue) &gt; 0:</span><br><span class="line">        curNode = queue.popleft()</span><br><span class="line">        path.append(curNode)</span><br><span class="line">        if curNode[0] == x2 and curNode[1] == y2:</span><br><span class="line">            # 说明此时到达了终点</span><br><span class="line">            print_r(path)</span><br><span class="line">            return True</span><br><span class="line">        for dir in dirs:</span><br><span class="line">            nextNode = dir(curNode[0], curNode[1])</span><br><span class="line">            if maze[nextNode[0]][nextNode[1]] == 0:</span><br><span class="line">                queue.append((nextNode[0], nextNode[1], len(path) - 1))  # 后续节点进队，记录哪个节点带他来的</span><br><span class="line">                maze[nextNode[0]][nextNode[1]] = 2  # 标记为已经走过</span><br><span class="line">    else:</span><br><span class="line">        print(&quot;没有路&quot;)</span><br><span class="line">        return False</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>汉诺塔问题</title>
      <link href="/2023/07/24/%E6%B1%89%E8%AF%BA%E5%A1%94%E9%97%AE%E9%A2%98/"/>
      <url>/2023/07/24/%E6%B1%89%E8%AF%BA%E5%A1%94%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="汉诺塔问题简单描述："><a href="#汉诺塔问题简单描述：" class="headerlink" title="汉诺塔问题简单描述："></a>汉诺塔问题简单描述：</h2><p>问题规则：Hanoi(汉诺)塔问题。古代有一个焚塔，塔内有3个座A,B,C,开始时A座上有64个盘子，<br>盘子大小不等，大的在上，小的在下，有一个老和尚想把这64个盘子从A座移到C座，但规定每次只允许移到一个盘，<br>且在移动过程中在3个座上都始终保持大盘在下，小盘在上，在移动过程中可以利用B座。输出移动盘子的步骤。</p><h2 id="py代码实现"><a href="#py代码实现" class="headerlink" title="py代码实现"></a>py代码实现</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># hanoi函数的参数表示的是n个盘子从a经过b移动到c</span><br><span class="line">def hanoi(n, a, b, c):</span><br><span class="line">    if n &gt; 0:</span><br><span class="line">        hanoi(n - 1, a, c, b)</span><br><span class="line">        print(&quot;moving from %s to %s&quot; % (a, c))</span><br><span class="line">        hanoi(n - 1, b, a, c)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">hanoi(3, &quot;A&quot;, &quot;B&quot;, &quot;C&quot;)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>排序算法补充</title>
      <link href="/2023/07/24/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E8%A1%A5%E5%85%85/"/>
      <url>/2023/07/24/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E8%A1%A5%E5%85%85/</url>
      
        <content type="html"><![CDATA[<h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><p>希尔排序是一种插入排序变种属于分组插入排序</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">def insert_sort_gap(li, gap):</span><br><span class="line">    for i in range(gap, len(li)):</span><br><span class="line">        tmp = li[i]</span><br><span class="line">        j = i - gap</span><br><span class="line">        while j &gt;= 0 and li[j] &gt; tmp:</span><br><span class="line">            li[j + gap] = li[j]</span><br><span class="line">            j -= gap</span><br><span class="line">        li[j + gap] = tmp</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def shell_sort(li):</span><br><span class="line">    d = len(li) // 2</span><br><span class="line">    while d &gt;= 1:</span><br><span class="line">        insert_sort_gap(li, d)</span><br><span class="line">        d //= 2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">li = list(range(1000))</span><br><span class="line">import random</span><br><span class="line"></span><br><span class="line">random.shuffle(li)</span><br><span class="line">print(li)</span><br><span class="line">shell_sort(li)</span><br><span class="line">print(li)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2><p>基数排序就是把数据从个位数往上按顺序入桶并且按顺序出桶  即可完成排序</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">def radix_sort(li):</span><br><span class="line">    max_num = max(li)</span><br><span class="line">    it = 0</span><br><span class="line">    while 10 ** it &lt;= max_num:</span><br><span class="line">        buckets = [[] for _ in range(10)]</span><br><span class="line">        for var in li:</span><br><span class="line">            digit = (var // 10 ** it) % 10</span><br><span class="line">            buckets[digit].append(var)</span><br><span class="line">        # 分桶完成</span><br><span class="line">        li.clear()</span><br><span class="line">        for buc in buckets:</span><br><span class="line">            li.extend(buc)</span><br><span class="line">        # 把数据重新写回li</span><br><span class="line">        it += 1</span><br><span class="line"></span><br><span class="line">import random</span><br><span class="line">li = list(range(1000))</span><br><span class="line">random.shuffle(li)</span><br><span class="line">print(li)</span><br><span class="line">radix_sort(li)</span><br><span class="line">print(li)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>常用算法学习</title>
      <link href="/2023/07/24/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"/>
      <url>/2023/07/24/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="查找算法"><a href="#查找算法" class="headerlink" title="查找算法"></a>查找算法</h2><h3 id="1-线性查找"><a href="#1-线性查找" class="headerlink" title="1.线性查找"></a>1.线性查找</h3><p>就是一个一个从前往后查找</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def line_search(list,val):</span><br><span class="line">    for i in range(len(li)):</span><br><span class="line">        if list[i] == val:</span><br><span class="line">            return  i</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2-二分查找、折半查找"><a href="#2-二分查找、折半查找" class="headerlink" title="2.二分查找、折半查找"></a>2.二分查找、折半查找</h3><p>前提是列表必须是有序的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"># 该函数的参数分别是有序列表和要查找的值</span><br><span class="line">def binnary_search(li, val):</span><br><span class="line">    left = 0</span><br><span class="line">    right = len(li) - 1</span><br><span class="line">    while left &lt;= right:</span><br><span class="line">        # 条件是要保证候选区有值</span><br><span class="line">        mid = (left + right) // 2</span><br><span class="line">        if li[mid] == val:</span><br><span class="line">            # 匹配成功 返回下标</span><br><span class="line">            return mid</span><br><span class="line">        elif li[mid] &lt;= val:</span><br><span class="line">            # 中间值小于等于val说明候选区在mid右边</span><br><span class="line">            left = mid + 1</span><br><span class="line">        else:</span><br><span class="line">            # 中间值大于等于val说明候选区在mid的左边</span><br><span class="line">            right = mid - 1</span><br><span class="line">    else:</span><br><span class="line">        # 没找到</span><br><span class="line">        return None</span><br><span class="line"></span><br><span class="line">list = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</span><br><span class="line">print(f&quot;查找数据所在下标为：&#123;binnary_search(list, 2)&#125;&quot;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>python的内置查找函数index就是使用的线性查找，二分查找虽然但是有有序前提</p><h2 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h2><h3 id="1-冒泡排序"><a href="#1-冒泡排序" class="headerlink" title="1.冒泡排序"></a>1.冒泡排序</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">import random</span><br><span class="line">def bubble_sort(li):</span><br><span class="line">    for i in range(len(li)):</span><br><span class="line">        for j in range(len(li) - i - 1):</span><br><span class="line">            if li[j] &gt; li[j + 1]:</span><br><span class="line">                # 调换位置 把值大的冒出去 升序排列(把if判断条件改为小于即为降序排列)</span><br><span class="line">                li[j], li[j + 1] = li[j + 1], li[j]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 冒泡排序优化 如果在一次排序中没有顺序移动 说明之后‘未排序’的数已经做好了排序 因此就不需要再做之后的冒泡 直接返回结果即可</span><br><span class="line">def bubble_sort_plus(li):</span><br><span class="line">    for i in range(len(li)):</span><br><span class="line">        exchange = False</span><br><span class="line">        for j in range(len(li) - i - 1):</span><br><span class="line">            if li[j] &gt; li[j + 1]:</span><br><span class="line">                # 调换位置 把值大的冒出去 升序排列(把if判断条件改为小于即为降序排列)</span><br><span class="line">                li[j], li[j + 1] = li[j + 1], li[j]</span><br><span class="line">                exchange = True</span><br><span class="line">        if exchange is False:</span><br><span class="line">            return</span><br><span class="line">        # 列表生成式 生成一个长度为100的每一项为0-1000之间的数的列表</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">li = [random.randint(0, 1000) for i in range(100)]</span><br><span class="line">print(li)</span><br><span class="line">bubble_sort(li)</span><br><span class="line">print(li)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2-选择排序"><a href="#2-选择排序" class="headerlink" title="2.选择排序:"></a>2.选择排序:</h3><p>选择排序是要在无序区遍历拿到最小的数 然后跟之前所记录的最小的数做交换<br>注意：有序区、无序区、无序区最小数的位置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">def search_sort(li):</span><br><span class="line">    for i in range(len(li) - 1):</span><br><span class="line">        min_loc = i</span><br><span class="line">        for j in range(i + 1, len(li)):</span><br><span class="line">            if li[j] &lt; li[min_loc]:</span><br><span class="line">                min_loc = j</span><br><span class="line">        li[i], li[min_loc] = li[min_loc], li[i]</span><br><span class="line">        print(li)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">li = [1, 4, 2, 3, 6, 9, 7]</span><br><span class="line">print(li)</span><br><span class="line">search_sort(li)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3-插入排序"><a href="#3-插入排序" class="headerlink" title="3.插入排序"></a>3.插入排序</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">def insert_sort(li):</span><br><span class="line">    for i in range(1, len(li)):  # i表示摸到牌的下标</span><br><span class="line">        temp = li[i]</span><br><span class="line">        j = i - 1  # j是手里的牌的下标</span><br><span class="line">        if j &gt;= 0 and li[j] &gt; temp:</span><br><span class="line">            li[j + 1] = li[j]</span><br><span class="line">            j -= 1</span><br><span class="line">        li[j+1] = temp</span><br><span class="line">        print(li)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">li = [1, 4, 2, 3, 6, 9, 5]</span><br><span class="line">print(li)</span><br><span class="line">insert_sort(li)</span><br></pre></td></tr></table></figure><h3 id="4-快速排序"><a href="#4-快速排序" class="headerlink" title="4.快速排序"></a>4.快速排序</h3><p>快速排序的思路就是递归的让列表中的一个数据被放列表的合适的位置<br>一次归位要保证归位的这个数一定能到达准确的位置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"># 归位函数</span><br><span class="line">def partition(li, left, right):</span><br><span class="line">    tmp = li[left]</span><br><span class="line">    while left &lt; right:</span><br><span class="line">        while left &lt; right and li[right] &gt;= tmp:  # 在右边找比tmp小的数 进行移动</span><br><span class="line">            right -= 1  # 往左走一步</span><br><span class="line">        li[left] = li[right]  # 把右边的值写到左边空位置上</span><br><span class="line">        while left &lt; right and li[left] &lt;= tmp:  # 在左边找比tmp大的数 进行移动</span><br><span class="line">            left += 1  # 往右走一步</span><br><span class="line">        li[right] = li[left]  # 把左边的值写到右边空位上</span><br><span class="line">    li[left] = tmp  # 把tmp归位</span><br><span class="line">    return left</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 递归调用实现快速排序</span><br><span class="line">def quick_sort(li, left, right):</span><br><span class="line">    if left &lt; right:</span><br><span class="line">        mid = partition(li, left, right)  # 获取中间值</span><br><span class="line">        quick_sort(li, left, mid - 1)  # 递归左边</span><br><span class="line">        quick_sort(li, mid + 1, right)  # 递归右边</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">li = [5, 6, 3, 7, 1, 9, 8]</span><br><span class="line">quick_sort(li, 0, len(li)-1)</span><br><span class="line">print(li)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="5-堆排序"><a href="#5-堆排序" class="headerlink" title="5.堆排序"></a>5.堆排序</h3><p>学了半天python版的堆排序看不懂代码<br>于是在网上找了个能看得懂的c代码将其转换成了python代码 正常运行<br>整体思路就是先把list列表通过堆维护的性质将其建成堆、然后在排序的过程中一边交换堆顶元素和堆底元素的值同时再调用堆的维护函数保证大顶堆</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">def heapify(li, n, i):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    维护堆函数</span><br><span class="line">    :param li:待维护列表</span><br><span class="line">    :param n: 待维护列表的长度</span><br><span class="line">    :param i: 待维护节点的下标</span><br><span class="line">    :return:</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    # 父节点、左孩子、右孩子</span><br><span class="line">    largest = i</span><br><span class="line">    lson = i * 2 + 1</span><br><span class="line">    rson = i * 2 + 2</span><br><span class="line">    if lson &lt; n and li[largest] &lt; li[lson]:</span><br><span class="line">        largest = lson</span><br><span class="line">    if rson &lt; n and li[largest] &lt; li[rson]:</span><br><span class="line">        largest = rson</span><br><span class="line">    # 最开始定义的父节点等于i、如果父节点的不等于i、说明此时该交换了</span><br><span class="line">    if largest is not i:</span><br><span class="line">        li[largest], li[i] = li[i], li[largest]</span><br><span class="line">        heapify(li, n, largest)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def heap_sort(li, n):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    堆排序：分为两步1、建堆2、排序</span><br><span class="line">    :param li: 待排序数列表</span><br><span class="line">    :param n: 长度</span><br><span class="line">    :return:</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    # 建堆</span><br><span class="line">    for i in range(n // 2 - 1, -1, -1):</span><br><span class="line">        heapify(li, n, i)</span><br><span class="line">    # 排序</span><br><span class="line">    for i in range(n - 1, -1, -1):</span><br><span class="line">        # 交换堆顶和堆底的元素</span><br><span class="line">        li[i], li[0] = li[0], li[i]</span><br><span class="line">        # 传入堆和剩余元素的数量与待维护节点下标</span><br><span class="line">        heapify(li, i, 0)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    list = [2, 3, 8, 1, 4, 7, 9, 10, 17, 5]</span><br><span class="line">    print(list)</span><br><span class="line">    heap_sort(list, len(list))</span><br><span class="line">    print(list)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="6-归并排序"><a href="#6-归并排序" class="headerlink" title="6.归并排序"></a>6.归并排序</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">def merge(li, low, high, mid):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    归并排序</span><br><span class="line">    :param li: 列表</span><br><span class="line">    :param low: 左边初始下标</span><br><span class="line">    :param high: 右边的初始下标</span><br><span class="line">    :param mid: 中间的初始下标</span><br><span class="line">    :return:</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    i = low</span><br><span class="line">    j = mid + 1</span><br><span class="line">    ltmp = []</span><br><span class="line">    while i &lt;= mid and j &lt;= high:</span><br><span class="line">        if li[i] &lt; li[j]:</span><br><span class="line">            ltmp.append(li[i])</span><br><span class="line">            i += 1</span><br><span class="line">        else:</span><br><span class="line">            ltmp.append(li[j])</span><br><span class="line">            j += 1</span><br><span class="line">    # while执行完，一定有一部分没数了</span><br><span class="line">    while i &lt;= mid:</span><br><span class="line">        ltmp.append(li[i])</span><br><span class="line">        i += 1</span><br><span class="line">    while j &lt;= high:</span><br><span class="line">        ltmp.append(li[j])</span><br><span class="line">        j += 1</span><br><span class="line">    li[low:high + 1] = ltmp</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def merge_sort(li, low, high):</span><br><span class="line">    if low &lt; high:  # 至少有两个元素递归</span><br><span class="line">        mid = (low + high) // 2</span><br><span class="line">        merge_sort(li, low, mid)</span><br><span class="line">        merge_sort(li, mid + 1, high)</span><br><span class="line">        merge(li, low, high, mid)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    list = [2, 3, 8, 1, 4, 7, 9, 10, 17, 5]</span><br><span class="line">    print(list)</span><br><span class="line">    merge_sort(list, 0, len(list)-1)</span><br><span class="line">    print(list)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="排序总结"><a href="#排序总结" class="headerlink" title="排序总结"></a>排序总结</h3><p>456这三种排序算法运行的速度相当快，时间复杂度都是O(nlogn)<br>一般情况下就运行的时间而言：快速排序&lt;归并排序&lt;堆排序<br>三种算法的优缺点：<br>快速排序：在极端情况下排序的效率特别低<br>归并排序：需要额外的内存开销<br>堆排序：在这三种排序中相对较慢</p><table><thead><tr><th>排序方法</th><th align="center">最坏情况</th><th align="center">时间复杂度(最坏情况)</th><th align="center">时间复杂度(最好情况)</th><th align="center">空间复杂度</th><th align="center">稳定性</th><th align="right">代码复杂度</th></tr></thead><tbody><tr><td>冒泡排序</td><td align="center">O(n&#96;2)</td><td align="center">O(n&#96;2)</td><td align="center">O(n)</td><td align="center">O(1)</td><td align="center">稳定</td><td align="right">稳定</td></tr><tr><td>选择排序</td><td align="center">O(n&#96;2)</td><td align="center">O(n&#96;2)</td><td align="center">O(n&#96;2)</td><td align="center">O(1)</td><td align="center">不稳定</td><td align="right">简单</td></tr><tr><td>插入排序</td><td align="center">O(n&#96;2)</td><td align="center">O(n&#96;2)</td><td align="center">O(n&#96;2)</td><td align="center">O(1)</td><td align="center">稳定</td><td align="right">简单</td></tr><tr><td>快速排序</td><td align="center">O(n&#96;2)</td><td align="center">O(nlogn)</td><td align="center">O(nlogn)</td><td align="center">好:O(logn)坏:O(n)</td><td align="center">不稳定</td><td align="right">较复杂</td></tr><tr><td>堆排序</td><td align="center">O(nlogn)</td><td align="center">O(nlogn)</td><td align="center">O(nlogn)</td><td align="center">O(1)</td><td align="center">不稳定</td><td align="right">复杂</td></tr><tr><td>归并排序</td><td align="center">O(nlogn)</td><td align="center">O(nlogn)</td><td align="center">O(nlogn)</td><td align="center">O(n)</td><td align="center">稳定</td><td align="right">较复杂</td></tr></tbody></table>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>更新1</title>
      <link href="/2023/07/14/%E6%9B%B4%E6%96%B01/"/>
      <url>/2023/07/14/%E6%9B%B4%E6%96%B01/</url>
      
        <content type="html"><![CDATA[<h2 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h2><p>新增看板白色小咪、B站追番列表<del>(但是很久不在B站追)</del>、音乐播放器<del>(这玩意时怎么好时坏)</del></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>我的第一篇博文</title>
      <link href="/2023/07/14/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E6%96%87/"/>
      <url>/2023/07/14/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E6%96%87/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>之前写的新建的hexo博客由于安装包依赖等一系列问题，因为博主能力有限导致束手无策，因此删掉了整个blog目录，重新创建学习记录。</p><h2 id="相关"><a href="#相关" class="headerlink" title="相关"></a>相关</h2><p>本博客使用hexo博客框架,主题是butterfly</p><h2 id="关于我为什么要创建这个blog"><a href="#关于我为什么要创建这个blog" class="headerlink" title="关于我为什么要创建这个blog"></a>关于我为什么要创建这个blog</h2><p>希望通过blog的形式记录生活或工作上的一些事情，旨在记录，用blog的形式，希望未来能为自己留下一段回忆，共勉！</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2023/07/14/hello-world/"/>
      <url>/2023/07/14/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
