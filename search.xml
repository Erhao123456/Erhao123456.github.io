<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>建模学习</title>
      <link href="/2025/04/10/%E5%BB%BA%E6%A8%A1%E5%AD%A6%E4%B9%A0/"/>
      <url>/2025/04/10/%E5%BB%BA%E6%A8%A1%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>自动化测试-python</title>
      <link href="/2023/10/18/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95-python/"/>
      <url>/2023/10/18/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95-python/</url>
      
        <content type="html"><![CDATA[<h1 id="selenium自动化测试的基本使用"><a href="#selenium自动化测试的基本使用" class="headerlink" title="selenium自动化测试的基本使用"></a>selenium自动化测试的基本使用</h1><h2 id="如何保证自动化用例的稳定性"><a href="#如何保证自动化用例的稳定性" class="headerlink" title="如何保证自动化用例的稳定性"></a>如何保证自动化用例的稳定性</h2><p>自动化测试稳定性的主要表现在两个方面：一个是元素定位的问题、一个是用例之间的依赖问题<br>元素定位的问题可以通过只能 <strong>智能等待</strong> 的方式解决<br>用例依赖可以解耦用例之间的关系，让每一条用例都从一个共同的页面开始执行，比如首页，可以在测试框架中采用后置处理的方式让每条用例执行完都回到首页<br> <strong>智能等待</strong> :一般有三种分别是强制等待、显式等待、隐式等待<br> <strong>强制等待</strong> 是设定一个固定的时长让程序休眠一小段时间，但是时间不好把控，可能时间过长可能过短，会影响执行效率，不建议使用。<br> <strong>隐式等待</strong> 是在driver获取之后设定，driver.implicitly_wait(time)来设置，对整个生命周期内的元素都有效果，每个元素都会等待加载完全直到超过设置的等待时间，优点是对整个driver都起作用只需要设置一次，缺点是使用隐式等待该程序会一直到整个页面加载完成之后才会做下一步操作，有时候你要找的元素可能已经加载完成了，但是页面中还有其他的元素未加载出来driver还是会等待，仍然不够灵活。<br> <strong>显式等待</strong> 相比隐式等待会更加灵活，显式等待是先设置一个条件函数和一个最长等待时间，轮询判断条件函数的返回值，如果返回true，则开始执行后面的操作，否则会一直等待，直到超时报出元素未找到异常<br> <strong>Waring</strong>:来自官方的警告，不要混用显式和隐式等待，这样会导致不可预测的等待时间，例如设置显式等待15秒，隐式等待10秒，可能会导致20s后发生超时 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">显式等待案例：</span><br><span class="line">from selenium import webdriver</span><br><span class="line">from selenium.webdriver. common.by import By</span><br><span class="line">from selenium.webdriver.support.ui import WebDriverWait</span><br><span class="line">from selenium.webdriver.support import expected_conditions as EC</span><br><span class="line">driver = webdriver . Chrome()</span><br><span class="line">driver.get(&quot;http://xX.com&quot;)</span><br><span class="line">element =WebDriverWait(driver, 10).until(EC.presence_of_element_located((By.ID, &quot;Element&quot;)))</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>显示等待需要用到两个类:WebDriverWait和expected_conditions两个类,WebDriverWait指定轮询间隔、超时时间等,<br>expected_conditions指定了很多条件函数(也可以自定义条件函数),具体可以参考官网:<br><a href="https://www.selenium.dev/selenium/docs/api/py/webdriver">https://www.selenium.dev/selenium/docs/api/py/webdriver</a> support&#x2F;selenium.webdriver.support.expected conditions.html?highlight&#x3D;expected</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">包和参数解析：</span><br><span class="line">1. WebDriverWait</span><br><span class="line">WebDriverWait(driver,timeout,poll_frequency=0.5, ignored_exceptions=None)</span><br><span class="line">driver:浏览器驱动</span><br><span class="line">timeout:最长超时时间,默认以秒为单位</span><br><span class="line">poll_frequency:轮询的间隔步长,默认为0.5s</span><br><span class="line">ignored_exceptions:忽略等待时出现的特定类型的异常,默认忽略NoSuchElementExeception异常</span><br><span class="line">WebDriverWait()类中有until()和until_not()方法:</span><br><span class="line">2、until()和until_not()</span><br><span class="line">WebDriverWait(self.driver, timeout, frequency).until(EC.visibility_of_element_located(loc))</span><br><span class="line">until(), until_not()</span><br><span class="line">WebDriverWait一般是配合until()或until_not()方法,就能够根据判断条件而灵活地等待了。主要的意思就是:程序每隔xx秒看一眼,如</span><br><span class="line">果条件成立了,则执行下一步;否则继续等待,直到超过设置的最长时间,然后抛出TimeoutException异常。</span><br><span class="line">格式:</span><br><span class="line">WebDriverWait(driver, timeout).until(method, message=&#x27;&#x27;)</span><br><span class="line">WebDriverWait(driver, timeout).until_not(method, message=&#x27;&#x27;)</span><br><span class="line">3. expected_conditions</span><br><span class="line">expected_conditions是selenium的一个模块,其中包含一系列可用于判断的条件:</span><br><span class="line">官方文档链接:</span><br><span class="line">https://www.selenium.dev/selenium/docs/api/py/webdriver support/selenium.webdriver.support.expected conditions.html?highlight=expected</span><br><span class="line">通过页面标题来判断</span><br><span class="line">1.title_is(title)</span><br><span class="line">判断当前页面的title是否完全等于( == )预期字符串,返回布尔值</span><br><span class="line">2.title_contains(title)</span><br><span class="line">判断当前页面的title是否包含预期字符串,返回布尔值</span><br><span class="line"># 元素等待直到标题出现‘百度一下,你就知道”</span><br><span class="line">WebDriverWait(driver,3).until(ECS.title_is(&#x27;百度一下,你就知道&#x27;))</span><br><span class="line"># 元素等待直到标题出现包含 百度、即可</span><br><span class="line">WebDriverWait(driver, 3) . until(ECS.title_contains(&#x27;&#x27;))</span><br><span class="line">通过元素是否可见来判断</span><br><span class="line">通常在网页中并不是所有元素都是可见的,也有的是初始化时不可见,加载完成时则状态又变为可见,所以在元素等待中以下这些方式是</span><br><span class="line">经常被用到的。</span><br><span class="line">注意:以下方法的参数有2种 !! 一定不要乱写,这都是官方定义好的</span><br><span class="line">官方文档链接:</span><br><span class="line">https://www.selenium.dev/selenium/docs/api/py/webdriver_support/selenium.webdriver.support.expected conditions.html?</span><br><span class="line">highlight=expected</span><br><span class="line">参数:locator (定位器)和element(元素)的用法</span><br><span class="line">locator:</span><br><span class="line">ECS.presence_of_element_located((By.ID,&#x27;kw&#x27;))</span><br><span class="line">element:</span><br><span class="line">ECS.visibility_of(driver.find_element(By.ID,&#x27;su&#x27;))</span><br><span class="line">3.presence_of_element_located(locator)</span><br><span class="line">判断某个元素是否被加到了dom树里,并不代表该元素一定可见</span><br><span class="line"># 元素等待直到能定位到元素,这里是定位到搜索输入框</span><br><span class="line"># 这里定位时不关心元素是否可见,只要是加载到DOM中能定位到即可</span><br><span class="line">WebDriverWait (driver, 3). until(ECS.presence_of_element_located((By.ID, &#x27;kw&#x27;)))</span><br><span class="line">4.visibility_of_element_located(locator)</span><br><span class="line">判断某个元素是否可见.可见代表元素非隐藏,并且元素的宽和高都不等于0</span><br><span class="line"># 元素等待直到能定位到可见的元素,比如这里定位到搜索按钮</span><br><span class="line"># 和上面不同,这里等待的元素除加载DOM中,也必须可见</span><br><span class="line">WebDriverWait (driver, 3). until(ECS. visibility_of_element_located((By.ID, &#x27;su&#x27;)))</span><br><span class="line">PS:presence_of_element_located和visibility_of_element_located,是显示等待中最常用的判断条件,2者之间的区别就是元素是否可</span><br><span class="line">见,然后元素都必须加载到dom里。</span><br><span class="line">简单点的处理方式是:1种不行,用另一种试试</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>进程与线程</title>
      <link href="/2023/10/10/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/"/>
      <url>/2023/10/10/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h1><p> <strong>进程是资源分配的最小单位，线程是CPU调度的最小单位</strong> </p><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>一个在内存中运行的应用程序。每个进程都有自己独立的一块内存空间，一个进程可以有多个线程，比如在Windows系统中，一个运行的xx.exe就是一个进程。</p><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>进程中的一个执行任务（控制单元），负责当前进程中程序的执行。一个进程至少有一个线程，一个进程可以运行多个线程，多个线程可共享数据。</p><h1 id="进程与线程的区别"><a href="#进程与线程的区别" class="headerlink" title="进程与线程的区别"></a>进程与线程的区别</h1><p>线程具有许多传统进程所具有的特征，故又称为轻型进程(Light—Weight Process)或进程元；而把传统的进程称为重型进程(Heavy—Weight Process)，它相当于只有一个线程的任务。在引入了线程的操作系统中，通常一个进程都有若干个线程，至少包含一个线程。</p><h2 id="根本区别："><a href="#根本区别：" class="headerlink" title="根本区别："></a>根本区别：</h2><p>进程是操作系统资源分配的基本单位，而线程是处理器任务调度和执行的基本单位</p><h2 id="资源开销："><a href="#资源开销：" class="headerlink" title="资源开销："></a>资源开销：</h2><p>每个进程都有独立的代码和数据空间（程序上下文），程序之间的切换会有较大的开销；线程可以看做轻量级的进程，同一类线程共享代码和数据空间，每个线程都有自己独立的运行栈和程序计数器（PC），线程之间切换的开销小。</p><h2 id="包含关系："><a href="#包含关系：" class="headerlink" title="包含关系："></a>包含关系：</h2><p>如果一个进程内有多个线程，则执行过程不是一条线的，而是多条线（线程）共同完成的；线程是进程的一部分，所以线程也被称为轻权进程或者轻量级进程。</p><h2 id="内存分配："><a href="#内存分配：" class="headerlink" title="内存分配："></a>内存分配：</h2><p>同一进程的线程共享本进程的地址空间和资源，而进程之间的地址空间和资源是相互独立的</p><h2 id="影响关系："><a href="#影响关系：" class="headerlink" title="影响关系："></a>影响关系：</h2><p>一个进程崩溃后，在保护模式下不会对其他进程产生影响，但是一个线程崩溃整个进程都死掉。所以多进程要比多线程健壮。</p><h2 id="执行过程："><a href="#执行过程：" class="headerlink" title="执行过程："></a>执行过程：</h2><p>每个独立的进程有程序运行的入口、顺序执行序列和程序出口。但是线程不能独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制，两者均可并发执行</p><h1 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h1><h2 id="为什么进程切换开销大于线程？"><a href="#为什么进程切换开销大于线程？" class="headerlink" title="为什么进程切换开销大于线程？"></a>为什么进程切换开销大于线程？</h2><p> <strong>虚拟内存</strong> 是操作系统为每个进程提供的一种抽象，每个进程都有属于自己的、私有的、地址连续的虚拟内存，当然我们知道最终进程的数据及代码必然要放到物理内存上，那么必须有某种机制能记住虚拟地址空间中的某个数据被放到了哪个物理内存地址上，这就是所谓的 <strong>地址空间映射</strong> ，那么操作系统是如何记住这种映射关系的呢，答案就是 <strong>页表</strong> 。<br>为了加速页表，还引入了高速缓存TLB，还需要的明确的是，页表是放在内存中，每个进程有自己的页表；TLB放再CPU MMU中，是进程间共享的（不是很准确的描述，后面会细讲）每个进程有自己独立的虚拟地址空间，进程内的所有线程共享进程的虚拟地址空间<br>那回到最开始的问题， <strong>进程切换和线程切换有什么区别？</strong><br>最主要的一个区别在于进程切换涉及虚拟地址空间的切换而线程不会。因为每个进程都有自己的虚拟地址空间，而线程是共享所在进程的虚拟地址空间的，因此同一个进程中的线程进行线程切换时不涉及虚拟地址空间的转换。<strong>为什么虚拟地址空间切换会比较耗时呢？因为cache和TLB会失效</strong><br> <strong>Flushing the TLB</strong> cache和TLB会失效的前提是它们的entry不会记录pid一些处理器，每次上下文切换时都会刷新整个TLB，这可能会非常昂贵，因为这意味着新进程不得不经历缺页、查找页表和插入条目整个过程,有些处理器，会给每个TLB项添加一个额外的唯一字段ASID(address space ID)，这意味这每个地址空间都有自己的ID，且标记在TLB上。因此上下文切换的时候TLB不需要被刷新，新来的进程讲会有不同的地址空间ID，甚至可以请求相同的虚拟地址，因为地址空间ID不同，翻译之后的物理地址也会不同。这种方式能减少清空、增加系统性能，但是需要更多的TLB硬件来存储ASIB位<br> <strong>简单来说就是</strong> 进程都有自己的虚拟地址空间，把虚拟地址转换为物理地址需要查找页表，页表查找是一个很慢的过程，因此通常使用Cache来缓存常用的地址映射，这样可以加速页表查找，这个cache就是TLB，Translation Lookaside Buffer，我们不需要关心这个名字只需要知道TLB本质上就是一个cache，是用来加速页表查找的。由于每个进程都有自己的虚拟地址空间，那么显然每个进程都有自己的页表，那么当进程切换后页表也要进行切换，<strong>页表切换后TLB就失效了，cache失效导致命中率降低</strong> ，那么虚拟地址转换为物理地址就会变慢，表现出来的就是程序运行会变慢，而线程切换则不会导致TLB失效，因为线程线程无需切换地址空间，因此我们通常说线程切换要比较进程切换块，原因就在这里</p><h2 id="进程之间有哪几种通信的方式"><a href="#进程之间有哪几种通信的方式" class="headerlink" title="进程之间有哪几种通信的方式"></a>进程之间有哪几种通信的方式</h2><p><strong>管道</strong> :管道是一种过半双工的通信方式。数据只能单向流动，而且只能在具有亲缘关系的进程间使用，进程的亲缘关系通常指父子进程<br><strong>消息队列通信</strong> :消息队列由消息的链表，存放在内核中并且由消息队列标识符。消息队列克服了信号传递信息少，管道只能承载无格式字节流以及缓冲区大小受限等缺点<br><strong>信号量</strong> :信号量是一个计数器，可以用来控制多进程对共享资源的访问，它常作为一个锁机制，防止某进程正在访问共享资源时，其他进程也该访问该资源。因此，主要作为进程间以及统一进程内的不同线程的同步手段<br><strong>信号</strong> :信号是一种比较复杂的通信方式，用于通知接收进程内某个事件已经发生。<br><strong>共享内存通信</strong> :共享内存通信就是映射一段能被其他进程访问的内存，这段内存由一个进程创建，但是多个进程都可以访问。共享内存是最快的IPC( <strong>IPC就是进程之间的通信方式</strong> )方式，他是针对其他进程间通信方式运行效率低而专门设计的，它往往与其他通信机制，如信号，配合使用，来实现进程间的同步通信。<br><strong>socket</strong> :套接字也是进程间的一种通信机制，与其他通信机制不同的是，它可用于不同机器之间的进程通信。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Nginx</title>
      <link href="/2023/10/06/Nginx/"/>
      <url>/2023/10/06/Nginx/</url>
      
        <content type="html"><![CDATA[<h1 id="Nginx的应用场景"><a href="#Nginx的应用场景" class="headerlink" title="Nginx的应用场景"></a>Nginx的应用场景</h1><h2 id="HTTP服务器"><a href="#HTTP服务器" class="headerlink" title="HTTP服务器"></a>HTTP服务器</h2><p>Nginx本身也是一个静态资源服务器，当只有静态资源服务器时，就可以使用Nginx来做服务器，如果一个网站只是静态页面的话，那么就可以通过这种方式来实现部署</p><h2 id="FTP服务器"><a href="#FTP服务器" class="headerlink" title="FTP服务器"></a>FTP服务器</h2><p>FTP服务器通常是会提供一个上传功能，其他应用如果需要静态资源就该从该静态服务器中获取</p><h2 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h2><p>反向代理（reverse proxy）方式是指以代理服务器来接收internet上的连接请求，然后将请求转发给内部网络上的服务器，并将服务器上得到的结果返回给Internet上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器</p><h2 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h2><p>负载均衡也是Nginx的一个常用功能，负载均衡的意思是分摊到多个操作单元上进行执行，从而共同完成工作任务</p><h1 id="Nginx的优点"><a href="#Nginx的优点" class="headerlink" title="Nginx的优点"></a>Nginx的优点</h1><h2 id="高并发支持"><a href="#高并发支持" class="headerlink" title="高并发支持"></a>高并发支持</h2><p>单机能够支持10w+的并发连接 改并发连接取决于内存大小 极限甚至能到达百万并发 在实际生产中进行简单的调优也是能非常接近这个数值的 这个主要得益于Nginx在Linux环境下的 <strong>epoll</strong> IO多路复用模型<br>像是 <strong>apache</strong> 的底层使用的就是 <strong>select</strong> 的IO多路复用模型是需要不断去轮询数据的，因此他的性能就比较低，而epoll的他不是去轮询，他是去注册一个监听事件，每当数据有变化的时候，就会通知，这就是为什么nginx能处理高并发的原因。<br>从表面上来看epoll的性能是最好的，但是在连接数少的情况下，select和poll的性能可能都比epoll好，毕竟epoll的通知机制需要很多回调函数<br> __epoll的水平触发和边缘触发有什么区别？__：<br><img src="/../img/nginx_epoll.png" alt="水平触发和边缘触发的区别" title="水平触发和边缘触发的区别"></p><h2 id="内存消耗低"><a href="#内存消耗低" class="headerlink" title="内存消耗低"></a>内存消耗低</h2><p>同类型的web服务中Nginx比Apache占用的内存资源更少，一般情况下1w非活跃的http链接在Nginx中消耗仅2.5m内存</p><h2 id="高拓展性"><a href="#高拓展性" class="headerlink" title="高拓展性"></a>高拓展性</h2><p>低耦合的模块设计，并且有丰富的第三方模块支持</p><h2 id="高可靠性"><a href="#高可靠性" class="headerlink" title="高可靠性"></a>高可靠性</h2><p>经过十几年各种复杂场景和各大公司的生产环境验证是可靠的，并且Nginx的架构是由master进程和worker进程组成的，如果worker进程出现问题，那么master进程可以快速开启一个新的worker进程提供服务</p><h1 id="网站优化之防盗链"><a href="#网站优化之防盗链" class="headerlink" title="网站优化之防盗链"></a>网站优化之防盗链</h1><h2 id="什么是盗链"><a href="#什么是盗链" class="headerlink" title="什么是盗链"></a>什么是盗链</h2><p>简单来说就是用其他人网站里的资源来放到我的网站里，这样骗取用户的浏览和点击受益者不提供资源或者只提供很少的资源，真正的服务商却得不到任何收益</p><h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><p>防盗链基于客户端携带的referer实现，referer是记录打开一个页面之前记录是从哪个页面跳转过来的标记信息，如果别人只链接了自己网站图片或某个单独的资源，而不是打开了网站的整个页面，这就是盗链，referer就是之前的那个网站域名~<br>只需要在Nginx服务器的配置文件conf中配置防盗链定义好referer即可 修改完配置文件可以使用nginx -t命令来查看我们的修改语法是否正确</p><h1 id="开启gzip压缩来减小资源大小"><a href="#开启gzip压缩来减小资源大小" class="headerlink" title="开启gzip压缩来减小资源大小"></a>开启gzip压缩来减小资源大小</h1><p>变相的提高了网站的访问速度<br>网站的访问速度跟客户机和服务器的带宽都有关系 资源大小减小也能提高访问速度<br>一般文本文件的压缩效果是最好的 一般可以到2-3倍的压缩效果 但是流媒体文件比如图片视频等 压缩效果就相当有限了<br>如何判断一些网站有没有开启gzip压缩 可以直接看大小对比还可以看response headers（返回头）里面有没有返回content-encoding：gzip<br> <strong>gzip压缩的一些参数详解</strong><br><img src="/../img/nginx_gzip_args.png" alt="gzip压缩的一些参数详解" title="gzip参数详解"><br><img src="/../img/nginx_gzip_server.png" alt="gzip配置文件修改" title="gzip配置文件修改"></p><h1 id="开启Brotli压缩"><a href="#开启Brotli压缩" class="headerlink" title="开启Brotli压缩"></a>开启Brotli压缩</h1><p>brotli是谷歌开发的一款三方压缩软件 压缩的性能比gzip压缩要更好一些 高出25%<br>在nginx中如果不能使用brotli压缩的话，就会自动降级到gzip压缩 这两种压缩方式是可以共存在nginx中的<br>brotli压缩只支持https协议 gzip支持http和https<br>要注意的是brotli压缩使用前需要在nginx.conf中开启https的配置<br><img src="/../img/nginx_brotli_.png" alt="brotli配置文件修改" title="brotli配置文件修改"><br>如何判断一些网站有没有开启Brotli压缩 可以直接看大小对比还可以看response headers（返回头）里面有没有返回content-encoding：br<br><img src="/../img/nginx_brotli_args.png" alt="gzip参数详解" title="gzip参数详解"></p><h1 id="反向代理实现免备案域名访问"><a href="#反向代理实现免备案域名访问" class="headerlink" title="反向代理实现免备案域名访问"></a>反向代理实现免备案域名访问</h1><p>可以搞一台香港云主机之类的可以不备案访问的服务器 通过让该主机进行反向代理这个未备案的ip就能实现访问<br>国内云主机会认为是香港云主机访问云主机 而不是用户通过浏览器域名的方式来访问云主机</p><h2 id="代理与反向搭理"><a href="#代理与反向搭理" class="headerlink" title="代理与反向搭理"></a>代理与反向搭理</h2><p>试想一个场景，我的手机坏了，此时是我正好有事，将手机交给舍友帮忙送去维修，此时舍友就是我的正向 <strong>代理</strong> ，对于维修部来说，维修部有多位维修工程师<br>此时室友回去找前台来递交维修工单，让前台来完成维修工单的分配，此时前台在该路线中就担任 <strong>反向代理</strong> 的角色<br>而前台给工程师来分配工单也是有不同的分配方法的 具体的分配方式就是 <strong>（好处1）负载均衡</strong> 的算法,比如<br> <strong>轮询法</strong> ：轮询法就是按顺序一个一个分配，比如上一个分配的工程师是1号排在他下面的是2号那么下一个任务的分配就是给2号依次轮询<br> <strong>加权轮询法</strong> :加权轮询法是在轮询法的基础上，比如有的工程师能力强（服务器的配置高 负载能力高 抗压能力高）能很快完成任务而不会积压工单，而有的工程师能力低（服务器的配置低 负载能力低 抗压能力低）同等时间下不能很快的完成任务，因此此时前台（反向代理）就会加权两个工程师的工单（两个服务器的能力）给能力低的工程师分配较少的工单，给能力高的工程师分配较多的工单，尽可能的完成资源的利用<br> <strong>最小连接数法</strong> : 加权轮询后，情况有所缓解，因为有的手机维修难度大(比如更换主板)，有的维修难度小（比如插线松了，插上就好）,导致有的工程师积压工单，有的则空闲等待，为了改善这种情况，前台（反向代理）统计工程师们（服务器）的待处理工单数量，将新来的工单分配给，待处理工单数最小的的工程师，尽可能的完成工单数目整体的均衡（对应到后端服务器，它能动态的根据当前连接情况，来动态的分配连接给每一台服务器，能将请求更合理的分配到每一台服务器上）<br> <strong>源地址哈希法</strong> :回到场景中，a用户维修还是之前的问题重现，最快的方法就是找之前给他维修的工程师，这样能减少前期摸索的成本，提高维修效率，对应到负载均衡中可以使用源地址哈希法，在反向代理中存储用户a的请求和ip，同一地址的用户信息，当后端服务器的的列表不变时，每次都会映射到原服务器<br>使用反向代理可以 <strong>（好处2）防止黑客攻击</strong> ，网站不需要透露原始服务器的ip地址，这使得攻击者难以组织有针对性的攻击，例如ddos攻击，攻击者只能攻击反向代理，而反向代理服务器一般配置更多资源来抵御网络攻击<br> <strong>（好处3）缓存</strong>:回到场景中，工程师总结了简单的问题总结处理，给前台，前台可以根据该处理快速解决问题，不需要转交后台工程师处理，这样也能提高效率，对应到计算机领域，代理服务器可以缓存响应数据，随后浏览该站点的用户从反向代理服务器中获取缓存数据，无需访问后端服务器，从而实现更快的访问。</p><h1 id="限流"><a href="#限流" class="headerlink" title="限流"></a>限流</h1><p> 请求限流<br> <img src="/../img/nginx_xianliu.png" alt="请求限流" title="请求限流"><br> 连接限流<br> <img src="/../img/nginx_xianliu_conn.png" alt="连接限流" title="连接限流"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 服务器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络学习总篇</title>
      <link href="/2023/09/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%AF%87/"/>
      <url>/2023/09/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<h2 id="1概述"><a href="#1概述" class="headerlink" title="1概述"></a>1概述</h2><h3 id="1-1网络的概念"><a href="#1-1网络的概念" class="headerlink" title="1.1网络的概念"></a>1.1网络的概念</h3><p>无论是交通网络还是通信网络都有的共同点就是连线和结点<br>网络的作用就是连通和共享</p><h3 id="1-2主机网络"><a href="#1-2主机网络" class="headerlink" title="1.2主机网络"></a>1.2主机网络</h3><p>网络发展早期就是主机和主机之间的网络<br>即以主机为中心(或者“主机-终端”)的网络<br>随计算机技术的发展而产生。早期的计算机均为大型机、中型机或者小型机器<br>用户通过终端连接到大型机(主机)上，通过批处理的方式共享主机上的软硬件资源<br>特征：以单处理机为中心的联机网络，集中式控制<br>缺点：主机负荷重、可靠性差</p><h3 id="1-3终端"><a href="#1-3终端" class="headerlink" title="1.3终端"></a>1.3终端</h3><p>终端是一个主机的远程输入&#x2F;输出设备(如手机、个人pc等)<br>个人计算机可以运行terminal(cmd窗口)来模拟一个终端的工作</p><h3 id="1-4局域网"><a href="#1-4局域网" class="headerlink" title="1.4局域网"></a>1.4局域网</h3><p>按地域划分、是指某一区域内多台计算机互联组成的计算机组<br>底层采用TCP&#x2F;IP协议实现了不同的计算机局域网互联的问题 也就是我们说的internet-因特网(网络的网络:把网络和网络连接在一起就是因特网)</p><h3 id="1-5Internet相关概念"><a href="#1-5Internet相关概念" class="headerlink" title="1.5Internet相关概念"></a>1.5Internet相关概念</h3><p>互连网：由路由器将网络连接起来、组成一个功能单一的‘虚拟网路’<br>互联网：当今世界最大的互联网络、由大规模的国家骨干网络、无数的区域网络和校园网络组成、采用IP协议栈<br>通俗的说，互联网就是采用IP协议用路由器把全球异构的网络连起来形成的一个网络，实现异构网络之间的互联互通<br>异构的网络：指的是采用不同的广域网和局域网</p><h3 id="1-6互联网的组成："><a href="#1-6互联网的组成：" class="headerlink" title="1.6互联网的组成："></a>1.6互联网的组成：</h3><p>边缘部分：由所有连接在互联网上的主机组成，这部分是用户直接使用的，用来进行通讯(传送数据、音频和视频)和资源共享<br>核心部分：有大量网络和连接这些网络的路由器组成，这部分是边缘部分提供服务的(提供连通性和交换)</p><h3 id="1-7互联网的通信"><a href="#1-7互联网的通信" class="headerlink" title="1.7互联网的通信"></a>1.7互联网的通信</h3><p>两种通信方式：客户服务器方式（C&#x2F;S方式）、对等方式（P2P方式）</p><h3 id="1-8分组交换"><a href="#1-8分组交换" class="headerlink" title="1.8分组交换"></a>1.8分组交换</h3><p>分组交换采用存储转发技术，发送端把较长的报文划分成较短的固定长度的数据段、每一个数据段前面添加上首部构成分组<br>每一个分组的首部都含有地址（目的地址和源地址）等控制信息、分左右交换网中的结点交换机根据收到的分组部分中的地址信息，把分组转换到下一个结点交换机：<br>每一个分组在互联网中独立的选择传输路径<br>用这样的存储转发方式，最后分组就能到达目的地<br>假设分组在传输的过程中没有任何差错，在转发时也没有被丢弃，在接收端就会收到分组后褪去首部还原成报文，最后在接收端把收到的数据还原成原来的报文<br>优缺点：<br>优点：<br>高效：在传输过程中动态分配传输带宽，对通信链路是逐段占用的<br>灵活：为每一个分组独立的选择最合适的转发路由<br>迅速可靠：以分组作为单位，可以不先建立连接就能像其他主机发送分组<br>可靠：分布式多路由的分组交换网，使网络有很好的生存性<br>缺点：<br>时延：分组在各节点存储转发时需要排队，会造成一定的时延<br>开销：分组必须携带首部（控制信息）也造成了一定的开销<br>失序：当分组交换采用数据报服务时，可能出现失序、丢失或者重复分组</p><h3 id="1-9报文交换"><a href="#1-9报文交换" class="headerlink" title="1.9报文交换"></a>1.9报文交换</h3><p>基于存储转发原理的报文交换，每一个结点接收整个报文，然后整个报文一次发送完毕，一次一跳<br>优点：无需建立连接随时发送报文，不同时间一段一段的占用通信线路，通信线路的利用率高<br>缺点：报文交换的时延长，实时性差、只适合数字信号、报文长度没有限制，中间转发结点存储空间大</p><h3 id="1-10三种交换的比较"><a href="#1-10三种交换的比较" class="headerlink" title="1.10三种交换的比较"></a>1.10三种交换的比较</h3><p>如果要传送大量的数据并且传送时间远大于建立连接的时间则电报交换的传输效率较快<br>报文交换和分组交换不需要预先分配传输带宽，在传送突发数据时可以提高整个网络的信道利用率<br>由于一个分组的长度远小于整个报文的长度，因此分组交换比报文交换的时延小，同时也具有更好的灵活性</p><h3 id="1-11计算机网络分类"><a href="#1-11计算机网络分类" class="headerlink" title="1.11计算机网络分类"></a>1.11计算机网络分类</h3><p><img src="/../img/network_fenlei.png" alt="本地相对路径" title="计算机网络分类"></p><h3 id="1-12性能指标"><a href="#1-12性能指标" class="headerlink" title="1.12性能指标"></a>1.12性能指标</h3><p><strong>速率</strong> ：速率是指连接在计算机网络上的主机在数字信道上传送数据的速率。是计算机网络中最重要的一个性能指标。又称为数据率(data rate)或比特率(bit rate) ，速率的单位是bit&#x2F;s(比特每秒）<br><img src="/../img/network_speed.png" alt="本地相对路径" title="速率"><br><strong>带宽</strong> ：本意是指某个信号具有的频带宽度 信号的带宽是指该信号所包含的各种不同频率成分所占据的频率范围。一条通信链路，带宽越宽，所能传输的最高数据率也越高。<br><img src="/../img/network_daikuan.png" alt="本地相对路径" title="带宽"><br><strong>吞吐量</strong> ：吞吐量表示单位时间内通过某个网络（通信线路、接口）的实际的数据量。吞吐量受制于带宽或者网络的额定速率。例如：对于一个1Gbit&#x2F;s的以太网，意味着其额定速率为1Gbit&#x2F;s，那么这个数值也是该以太网的吞吐量的绝对上限值。</p><p><strong>时延</strong> ：时延(delay 或 latency)是指数据（一个报文或分组，甚至比特）从网络(或链路)的一端传送到另一端所需的时间。有时也称为延迟或迟延。时延包括：<strong>发送时延</strong> (主机或路由器发送数据帧所需要的时间)、<strong>传播时延</strong> (电磁波在信道中传播一定的距离需要花费的时间)、<strong>处理时延</strong> (主机或者路由器接受到分组时要花费一定的时间去处理)、<strong>排队时延</strong> (分组在网络传输时，进入路由器后要在输入队列中排队等待处理，路由器确定转发接口后，还要在输出队列中排队等待转发，这就是排队时延)</p><p><strong>时延带宽积</strong> :时延带宽积指传播时延*带宽，表示一条链路上传播的所有比特（以比特为单位）。</p><p><strong>往返时间RTT</strong> :往返时延 RTT (Round-Trip Time) 表示从发送端发送数据开始，到发送端收到来自接收端的确认（接收端收到数据后立即发送确认），总共经历的时延。</p><p><strong>利用率</strong> :信道利用率指出某信道有百分之几的时间是被利用的（有数据通过）。完全空闲的信道的利用率是零。<br>网络利用率则是全网络的信道利用率的加权平均值。<br>信道利用率并非越高越好，信道或网络的利用率过高会产生非常大的时延。</p><h3 id="1-13具有五层协议的体系结构"><a href="#1-13具有五层协议的体系结构" class="headerlink" title="1.13具有五层协议的体系结构"></a>1.13具有五层协议的体系结构</h3><p><img src="/../img/network_xieyi.png" alt="本地相对路径" title="具有五层协议的体系结构"><br><strong>OSI的体系协议</strong> 太过理论 实现起来太复杂 业内使用的还是 <strong>TCP&#x2F;IP的体系结构</strong><br>五层协议的具体作用:<br><img src="/../img/network_xieyi_jutizuoyong.png" alt="本地相对路径" title="五层协议的具体作用"><br>主机之间发送数据:<br><img src="/../img/network_zhuji_shujufasong.png" alt="本地相对路径" title="主机之间发送数据"></p><h2 id="2物理层"><a href="#2物理层" class="headerlink" title="2物理层"></a>2物理层</h2><h3 id="2-1物理层功能"><a href="#2-1物理层功能" class="headerlink" title="2.1物理层功能"></a>2.1物理层功能</h3><p>物理层的主要功能就是解决比特传输速率的问题，即为透明的传送比特流，关心的是点到点的问题<br>透明传输是指不管所传输的是什么样的比特组合都能够在链路上传输<br>要尽可能的屏蔽掉不同的传输媒体和通信手段的差异<br><img src="/../img/netwotk_physics.png" alt="本地相对路径" title="物理层的特性"><br> <strong>信号类型</strong> ：<br>铜缆：基于电平<br>光纤：基于光脉冲<br>无线：基于微波</p><h3 id="2-2三种通信方式"><a href="#2-2三种通信方式" class="headerlink" title="2.2三种通信方式"></a>2.2三种通信方式</h3><p> <strong>单工通信</strong> ：只有一个方向上的通信而没有反方向的交互，比如电视、广播<br> <strong>半双工通信</strong> ：通信双方可以发送或者接收数据，但是不能同时发送和接收数据，比如对讲机<br> <strong>全双工通信</strong> ：通信双方可以同时发送和接收信息，比如电话</p><h3 id="2-3基带信号和调制"><a href="#2-3基带信号和调制" class="headerlink" title="2.3基带信号和调制"></a>2.3基带信号和调制</h3><p>基带信号是指信源发出的没有经过调制的原始信号（直接表达了要传输的信息的信号）<br>基带信号往往包含了较多的低频成分甚至直流成分，而许多的信道并不能直接传输这种低频分量或者直流分量，因此必须对基带信号进行调制<br>由模拟信号源产生的信号成为 <strong>模拟基带信号</strong> （说话的声波）<br>由计算机产生的二进制信号一般称为 <strong>数字基带信号</strong><br>没有特别声明的话，一般指的基带信号就是数字基带信号</p><h3 id="2-4基带传输和宽带传输"><a href="#2-4基带传输和宽带传输" class="headerlink" title="2.4基带传输和宽带传输"></a>2.4基带传输和宽带传输</h3><p> <strong>基带传输</strong> ：将基带信号（0和1用两种不同的电压表示：编码）直接送到数字信道上的传输方式、传输的是基带信号：适合近距离传输<br> <strong>宽带传输</strong> ：将基带信号经过调制（带通调制）后送到模拟信道上的传输方式，也称为频带传输、传输的是宽带信号（带通信号）：适合远距离传输<br> <strong>带通调试</strong> ：使用载波进行调试，把基带信号的频率范围搬移到较高频段，并转化为模拟信号，这样就能够在更好的模拟信道内进行传输(即仅在一段频率范围内能够通过信道)<br> <img src="/../img/network_bianma_tiaozhi.png" alt="本地相对路径" title="编码与调制"></p><h3 id="2-5几种编码方式"><a href="#2-5几种编码方式" class="headerlink" title="2.5几种编码方式"></a>2.5几种编码方式</h3><p> <strong>非归零编码（NRZ）</strong> ：正电平代表1，负电平代表0<br> <strong>归零编码</strong> ：正脉冲代表1，负脉冲代表0<br> <strong>曼彻斯特编码</strong> ：从高到低跳变表示1，从低到高跳变表示0，也可以反过来定义<br> <strong>差分曼彻斯特编码</strong> ：在每一位的中心处始终都有跳变，位开始边界有跳变代表0，而位开始边界没有跳变代表1<br> <img src="/../img/network_bianma_.png" alt="本地相对路径" title="几种编码方式"></p><h3 id="2-6码元"><a href="#2-6码元" class="headerlink" title="2.6码元"></a>2.6码元</h3><p>在使用时间域（或简称为时域）的波形表示数字信号时（固定时长的信号波形），代表不同离散数值的基本波形：<br>1码元可以携带多个比特的信息量<br>当码元的离散状态有M个时（M&gt;2）此时码元成为M进制码元<br> <img src="/../img/network_mayuan.png" alt="本地相对路径" title="码元"></p><h3 id="2-7信道复用技术"><a href="#2-7信道复用技术" class="headerlink" title="2.7信道复用技术"></a>2.7信道复用技术</h3><p> <strong>多路复用技术</strong> ：把多个信号组合在一条物理信道上进行传输，使得多个计算机或者终端设备共享信道资源，提高信道利用率，把一条广播信道 <strong>逻辑</strong> 上分为几条用于两个节点之间通信的 <strong>互不干扰</strong> 的信道，就是把广播信道转变为点对点信道<br> <strong>频分多路复用</strong><br><img src="/../img/network_duolufuyong_FDM.png" alt="本地相对路径" title="频分多路复用"><br> <strong>时分多路复用</strong>:由于计算机数据的突发性质，无法保证每个信道中每个时刻都有数据，使用时分复用系统传输数据，子信道的利用率一般是不是高的,由此引出了 <strong>统计时分复用</strong><br><img src="/../img/network_duolufuyong_TDM.png" alt="本地相对路径" title="时分多路复用"><br><img src="/../img/network_duolufuyong_STDM.png" alt="本地相对路径" title="统计时分多路复用"><br> <strong>波分复用</strong><br><img src="/../img/network_duolufuyong_WDM.png" alt="本地相对路径" title="波分复用"><br> <strong>码分复用</strong><br> 码片序列：每一个比特时间划分为m个短的间隔，被称为码片也叫码片序列<br> 每个站被指派唯一一个m 比特的码片序列<br> 如发送比特1，则发送自己的m比特码片序列<br> 如发送比特0，则发送该码片序列的二进制反码<br> 例如，s站的8bit码片序列是00011011<br> 发送比特1时就发送00011011<br> 发送比特0时就发送11100100<br> s站的码片序列就是（-1 -1 -1 +1 +1 -1 +1 +1）<br><img src="/../img/network_duolufuyong_CDM.png" alt="本地相对路径" title="码分复用"><br><img src="/../img/network_duolufuyong_CDM_.png" alt="本地相对路径" title="码分复用"></p><h2 id="3数据链路层"><a href="#3数据链路层" class="headerlink" title="3数据链路层"></a>3数据链路层</h2><h3 id="3-1数据链路层的信道类型"><a href="#3-1数据链路层的信道类型" class="headerlink" title="3.1数据链路层的信道类型"></a>3.1数据链路层的信道类型</h3><p> <strong>点对点信道</strong> :这种信道使用一对一的点对点通信方式，控制协议相对简单<br> <strong>广播信道</strong> :使用一对多的广播通信方式，通信过程比较 <strong>复杂</strong> 。广播信道上连接的主机很多，因此必须使用专用的 <strong>共享协议</strong> 来协调这些主机的数据发送，控制协议相对复杂</p><h3 id="3-2数据链路层的一些基本术语"><a href="#3-2数据链路层的一些基本术语" class="headerlink" title="3.2数据链路层的一些基本术语"></a>3.2数据链路层的一些基本术语</h3><p>数据链路层不必考虑物理层如何实现比特传输的细节，甚至可以更简单的设想好像是沿着两个数据链路层之间的水平方向把帧直接发送给对象<br> <strong>链路</strong> :结点间的物理通道。是一条无源的点到点的物理线路段（光纤、双绞线等），中间没有任何的其他交换结点。一条线路只是一条通路的一个组成部分。<br> <strong>数据链路</strong> :是结点间的逻辑通道。除了物理线路以外，还必须有通信协议来控制这些数据的传输，若把实现这些协议的硬件和软件加到链路上，就构成了数据链路，因此数据链路&#x3D;链路+协议<br> 链路中通信双方的信道使用形式不同，会有相应的不同的控制协议<br> <strong>数据链路的例子</strong> :城市交通&#x3D;街道+汽车交通规则 铁路交通&#x3D;铁轨+火车运行规则<br> <strong>帧</strong> :链路层协议数据单元，封装网络层的数据报<br> <strong>数据链路层</strong> :负责通过一条链路从一个结点向物理链路直接相连的相邻接点传送帧。<br> <strong>网卡</strong> 实现的物理层和数据链路层协议</p><h3 id="3-3数据链路层的三个基本功能"><a href="#3-3数据链路层的三个基本功能" class="headerlink" title="3.3数据链路层的三个基本功能"></a>3.3数据链路层的三个基本功能</h3><p> <strong>封装成帧</strong> :把若干比特打包成帧，便于检错和判断开始与帧结束 封装成帧就是在一段数据的前后分别添加首部和尾部，然后就构成了一个帧，首部和尾部的一个重要作用就是进行帧定界，确定帧的界限，帧的定界可以使用特殊的帧定界符，控制字符SOH放在帧的最前面表示帧的首部开始，控制字符EOT放在最后表示帧的结束<br> <strong>透明传输</strong> :成帧的标识可以作为数据传输 如果数据中正好也有‘SOH’ ‘EOT’的话就采用一种 <strong>字节填充</strong> （ <strong>字符填充</strong> ）的方法在‘SOH’或者‘EOT’的前面加上转义字符‘ESC’ 如果转义字符也在数据中那么就在转义字符前面在加一个转义字符表示一个‘ESC’<br> <strong>差错检测</strong> :检查帧的传输是否有比特错误 在传输过程中可能产生比特差错 1变成0 0变成1 就可以启动差错检测<br> <strong>CRC循环冗余检验</strong> ：模2运算 即异或运算 不同为1 相同为0 两0为0<br>可以实现：在物理层的基础上向网络层提供服务、加强物理层传输原始比特的功能、对网络层表现为一条无差错的链路、将可能出错的物理连接变为逻辑上无差错的数据链路<br><img src="/../img/network_shujulianlu_CRC.png" alt="本地相对路径" title="CRC冗余码的计算"></p><h3 id="3-4点对点协议PPP"><a href="#3-4点对点协议PPP" class="headerlink" title="3.4点对点协议PPP"></a>3.4点对点协议PPP</h3><p> PPP协议有 <strong>三个组成部分</strong> ：<br> 1 一个将IP数据报封装到串行链路的方法。PPP既支持异步链路，也支持同步链路。IP数据报就是PPP帧中的信息部分，长度受限于最大传送单元MTU的限制。<br> 2 一个用来建立、配置和测试数据链路连接的链路控制协议LCP。<br> 3 一套网络控制协议NCP，每一个协议支持一个网络层协议，如IP、AppleTalk等。</p><h3 id="3-5CSMA-CD协议"><a href="#3-5CSMA-CD协议" class="headerlink" title="3.5CSMA&#x2F;CD协议"></a>3.5CSMA&#x2F;CD协议</h3><p><img src="/../img/network_shujulianlu_CSMACD.png" alt="本地相对路径" title="CSMA/CD协议"></p><h2 id="4网络层"><a href="#4网络层" class="headerlink" title="4网络层"></a>4网络层</h2><h3 id="4-1虚电路服务与数据报服务的对比"><a href="#4-1虚电路服务与数据报服务的对比" class="headerlink" title="4.1虚电路服务与数据报服务的对比"></a>4.1虚电路服务与数据报服务的对比</h3><p><img src="/../img/network_wangluo_.png" alt="本地相对路径" title="虚电路服务与数据报服务的对比"></p><h3 id="4-2IP协议"><a href="#4-2IP协议" class="headerlink" title="4.2IP协议"></a>4.2IP协议</h3><p>包含两个方面：<br>IP头部信息。IP头部信息出现在每个IP数据报中，用于指定IP通信的源端IP地址、目的端IP地址，指导IP分片和重组，以及指定部分通信行为。<br>IP数据报的路由和转发。IP数据报的路由和转发发生在除目标机器之外的所有主机和路由器上。它们决定数据报是否应该转发以及如何转发。</p><p>IP协议是TCP&#x2F;IP协议族的动力，它为上层协议提供无状态、无连接、不可靠的服务。<br>无状态是指IP通信双方不同步传输数据的状态信息，因此所有IP数据报的发送、传输和接收都是相互独立、没有上下文关系的。这种服务最大的缺点就是无法处理乱序和重复的IP数据报。面向连接的协议，比如TCP协议，能够自己处理乱序的、重复的报文段，它递交给上层协议的内容绝对是有序的、正确的。无状态服务的优点也很明显：简单、高效。我们无需为保持通信的状态而分配一些内核资源，也无需每次传输数据时都携带状态信息。</p><p>无连接是指IP通信双方都不长久地维持对方的任何信息。这样上层协议每次发送数据的时候，都必须明确指定对方的IP地址。</p><p>不可靠是指IP协议不能保证IP数据报准确地到达接收端，它只是承诺尽最大努力。很多情况都可以导致IP数据报发送失败。比如，某个中转路由器发现IP数据报在网络上存活地时间太长，那么它将丢弃该报文，并返回一个ICMP错误消息给发送端。因此，使用IP服务地上层协议需要自己实现数据确认、超时重传等机制以达到可靠传输的目的。</p><h3 id="4-3IP地址"><a href="#4-3IP地址" class="headerlink" title="4.3IP地址"></a>4.3IP地址</h3><p><img src="/../img/network_wangluo_IP.png" alt="本地相对路径" title="IP地址"></p><h3 id="4-4八位二进制到十进制之间的转换"><a href="#4-4八位二进制到十进制之间的转换" class="headerlink" title="4.4八位二进制到十进制之间的转换"></a>4.4八位二进制到十进制之间的转换</h3><p><img src="/../img/network_wangluo_bin.png" alt="本地相对路径" title="八位二进制到十进制之间的转换"></p><h3 id="4-5一般不使用特殊的IP地址"><a href="#4-5一般不使用特殊的IP地址" class="headerlink" title="4.5一般不使用特殊的IP地址"></a>4.5一般不使用特殊的IP地址</h3><p><img src="/../img/network_wangluo_IP_.png" alt="本地相对路径" title="一般不使用的特殊IP地址"></p><h3 id="4-6默认的子网掩码"><a href="#4-6默认的子网掩码" class="headerlink" title="4.6默认的子网掩码"></a>4.6默认的子网掩码</h3><p><img src="/../img/network_wangluo_ziwangyanma.png" alt="本地相对路径" title="默认的子网掩码"><br>子网掩码是一个网络或者一个子网的重要属性<br>路由器在和相邻路由器交换路由信息时，必须把自己所在的网络或者子网的子网掩码告诉相邻路由器<br>路由器的路由表中的每一个项目，除了要给出目的网络地址外还必须同时给出该网络的子网掩码<br>若一个路由器连接在两个子网上就拥有了两个网络地址和两个子网掩码</p><h3 id="4-7怎么计算网路地址"><a href="#4-7怎么计算网路地址" class="headerlink" title="4.7怎么计算网路地址"></a>4.7怎么计算网路地址</h3><p><img src="/../img/network_wangluo_jisuan.png" alt="本地相对路径" title="计算网路地址"></p><h2 id="5运输层"><a href="#5运输层" class="headerlink" title="5运输层"></a>5运输层</h2><p>TCP协议（传输控制协议） TCP传送的数据单位是TCP报文段<br>UDP协议（用户数据报协议）UDP传送的数据单位是UDP报文或用户数据报</p><h2 id="6应用层"><a href="#6应用层" class="headerlink" title="6应用层"></a>6应用层</h2><h3 id="6-1域名空间"><a href="#6-1域名空间" class="headerlink" title="6.1域名空间"></a>6.1域名空间</h3><p><img src="/../img/network_app_yuming.png" alt="本地相对路径" title="域名空间"></p><h3 id="6-2报文相应格式"><a href="#6-2报文相应格式" class="headerlink" title="6.2报文相应格式"></a>6.2报文相应格式</h3><p><img src="/../img/network_xiangying_zhuangtaima.png" alt="本地相对路径" title="状态码"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>递归的应用</title>
      <link href="/2023/08/31/%E9%80%92%E5%BD%92%E7%9A%84%E5%BA%94%E7%94%A8/"/>
      <url>/2023/08/31/%E9%80%92%E5%BD%92%E7%9A%84%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="递归解决整数转换为任意进制"><a href="#递归解决整数转换为任意进制" class="headerlink" title="递归解决整数转换为任意进制"></a>递归解决整数转换为任意进制</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">def toStr(n, base):</span><br><span class="line">    convertString = &#x27;0123456789ABCDEF&#x27;</span><br><span class="line">    if n &lt; base:</span><br><span class="line">        # 最小规模</span><br><span class="line">        return convertString[n]</span><br><span class="line">    else:</span><br><span class="line">        return toStr(n // base, base) + convertString[n % base]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    print(toStr(1453, 16))  # 16进制</span><br><span class="line">    print(toStr(1453, 2))  # 2进制</span><br><span class="line">    print(toStr(1453, 8))  # 8进制</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>双端队列的应用</title>
      <link href="/2023/08/31/%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97%E7%9A%84%E5%BA%94%E7%94%A8/"/>
      <url>/2023/08/31/%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97%E7%9A%84%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="双端队列解决回文数问题"><a href="#双端队列解决回文数问题" class="headerlink" title="双端队列解决回文数问题"></a>双端队列解决回文数问题</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">from Deque import Deque</span><br><span class="line"># Deque是自定义的双端队列</span><br><span class="line"></span><br><span class="line">def palChecker(aString):</span><br><span class="line">    dq = Deque()</span><br><span class="line">    for ch in aString:</span><br><span class="line">        dq.addRear(ch)</span><br><span class="line">    stillEqual = True</span><br><span class="line">    while dq.size() &gt; 1 and stillEqual:</span><br><span class="line">        # 双端队列两边同时出队 然后判断是否一致 不一致就返回False</span><br><span class="line">        first = dq.removeFront()</span><br><span class="line">        last = dq.removeRear()</span><br><span class="line">        if first != last:</span><br><span class="line">            stillEqual = False</span><br><span class="line">    return stillEqual</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    print(palChecker(&#x27;reader&#x27;))</span><br><span class="line">    print(palChecker(&#x27;上海自来水来自海上&#x27;))</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>栈的应用</title>
      <link href="/2023/08/31/%E6%A0%88%E7%9A%84%E5%BA%94%E7%94%A8/"/>
      <url>/2023/08/31/%E6%A0%88%E7%9A%84%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="后缀表达式的求值"><a href="#后缀表达式的求值" class="headerlink" title="后缀表达式的求值"></a>后缀表达式的求值</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"># 栈的实现</span><br><span class="line">class Stack:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.items = []</span><br><span class="line"></span><br><span class="line">    def isEmpty(self):</span><br><span class="line">        return self.items == []</span><br><span class="line"></span><br><span class="line">    def push(self, item):</span><br><span class="line">        self.items.append(item)</span><br><span class="line"></span><br><span class="line">    def pop(self):</span><br><span class="line">        return self.items.pop()</span><br><span class="line"></span><br><span class="line">    def peek(self):</span><br><span class="line">        return self.items[len(self.items) - 1]</span><br><span class="line"></span><br><span class="line">    def size(self):</span><br><span class="line">        return len(self.items)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def postfixEval(postfixExpr):</span><br><span class="line">    s = Stack()</span><br><span class="line">    tokenlist = []</span><br><span class="line">    postfixExpr = str(postfixExpr)</span><br><span class="line">    for postfixExp in postfixExpr:</span><br><span class="line">        tokenlist.append(postfixExp)</span><br><span class="line">    print(tokenlist)</span><br><span class="line">    for token in tokenlist:</span><br><span class="line">        if token in &#x27;0123456789&#x27;:</span><br><span class="line">            s.push(int(token))</span><br><span class="line">        else:</span><br><span class="line">            operand2 = s.pop()</span><br><span class="line">            operand1 = s.pop()</span><br><span class="line">            result = doMath(token, operand1, operand2)</span><br><span class="line">            s.push(result)</span><br><span class="line">    return s.pop()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def doMath(op, op1, op2):</span><br><span class="line">    if op == &#x27;*&#x27;:</span><br><span class="line">        return op1 * op2</span><br><span class="line">    elif op == &#x27;/&#x27;:</span><br><span class="line">        return op1 / op2</span><br><span class="line">    elif op == &#x27;+&#x27;:</span><br><span class="line">        return op1 + op2</span><br><span class="line">    else:</span><br><span class="line">        return op1 - op2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    # 根据后缀表达式的运算规则 从前往后 *的优先级是最高的 因此 456*+的运算顺序是先算5*6 然后5*6的结果再+4</span><br><span class="line">    print(postfixEval(&#x27;456*+&#x27;))</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="简单的括号匹配"><a href="#简单的括号匹配" class="headerlink" title="简单的括号匹配"></a>简单的括号匹配</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"># 匹配函数</span><br><span class="line">def parChecker(symbolString):</span><br><span class="line">    s = Stack()</span><br><span class="line">    balanced = True</span><br><span class="line">    index = 0</span><br><span class="line">    while index &lt; len(symbolString) and balanced:</span><br><span class="line">        symbol = symbolString[index]</span><br><span class="line">        if symbol in &#x27;([&#123;&#x27;:</span><br><span class="line">            s.push(symbol)</span><br><span class="line">        else:</span><br><span class="line">            if s.isEmpty():</span><br><span class="line">                balanced = False</span><br><span class="line">            else:</span><br><span class="line">                top = s.pop()</span><br><span class="line">                if not matches(top, symbol):</span><br><span class="line">                    balanced = False</span><br><span class="line">        index += 1</span><br><span class="line">    if balanced and s.isEmpty():</span><br><span class="line">        return True</span><br><span class="line">    else:</span><br><span class="line">        return False</span><br><span class="line"></span><br><span class="line"># 利用位置来匹配成对的括号 位置一样说明是成对的 位置不一样说明不是成对的</span><br><span class="line">def matches(open, close):</span><br><span class="line">    opens = &quot;([&#123;&quot;</span><br><span class="line">    closers = &quot;)]&#125;&quot;</span><br><span class="line">    return opens.index(open) == closers.index(close)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    print(parChecker(&#x27;[&#123;&#125;()]&#x27;))</span><br><span class="line">    print(parChecker(&#x27;[&#123;&#125;(])&#x27;))</span><br><span class="line">    print(parChecker(&#x27;&#123;&#125;&#x27;))</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构-栈与队列</title>
      <link href="/2023/08/31/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/"/>
      <url>/2023/08/31/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h3 id="栈Stack"><a href="#栈Stack" class="headerlink" title="栈Stack"></a>栈Stack</h3><p>特点就是FILO 先进后出</p><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Stack:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.items = []</span><br><span class="line"></span><br><span class="line">    def isEmpty(self):</span><br><span class="line">        # 判空</span><br><span class="line">        return self.items == []</span><br><span class="line"></span><br><span class="line">    def push(self, item):</span><br><span class="line">        # 进栈</span><br><span class="line">        self.items.append(item)</span><br><span class="line"></span><br><span class="line">    def pop(self):</span><br><span class="line">        # 出栈</span><br><span class="line">        return self.items.pop()</span><br><span class="line"></span><br><span class="line">    def peek(self):</span><br><span class="line">        # 返回栈顶元素</span><br><span class="line">        return self.items[len(self.items) - 1]</span><br><span class="line"></span><br><span class="line">    def size(self):</span><br><span class="line">        # 栈的大小</span><br><span class="line">        return len(self.items)</span><br></pre></td></tr></table></figure><h3 id="队列Queue"><a href="#队列Queue" class="headerlink" title="队列Queue"></a>队列Queue</h3><p>特点是FIFO 先进先出</p><h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Queue:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.items = []</span><br><span class="line"></span><br><span class="line">    def isEmpty(self):</span><br><span class="line">        # 判空</span><br><span class="line">        return self.items == []</span><br><span class="line"></span><br><span class="line">    def enqueue(self, item):</span><br><span class="line">        # 进队 时间复杂度是O(n)</span><br><span class="line">        self.items.append(item)</span><br><span class="line"></span><br><span class="line">    def dequeue(self):</span><br><span class="line">        # 出队 时间复杂度是O(1)</span><br><span class="line">        return self.items[-1]</span><br><span class="line"></span><br><span class="line">    def size(self):</span><br><span class="line">        # 队列大小</span><br><span class="line">        return len(self.items)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="双端队列Deque"><a href="#双端队列Deque" class="headerlink" title="双端队列Deque"></a>双端队列Deque</h3><p>两端都是可进可出</p><h4 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">class Deque:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        # 初始化 list下标0作为deque的尾端 下标-1作为deque的首端</span><br><span class="line">        # 操作复杂度：addFront、removeFront是O(1) addRear、removeRear是O(N)</span><br><span class="line">        self.items = []</span><br><span class="line"></span><br><span class="line">    def isEmpty(self):</span><br><span class="line">        # 判空</span><br><span class="line">        return self.items == []</span><br><span class="line"></span><br><span class="line">    def addFront(self, item):</span><br><span class="line">        # 队首添加</span><br><span class="line">        self.items.append(item)</span><br><span class="line"></span><br><span class="line">    def addRear(self, item):</span><br><span class="line">        # 队尾添加</span><br><span class="line">        self.items.insert(0, item)</span><br><span class="line"></span><br><span class="line">    def removeFront(self):</span><br><span class="line">        # 首端出队</span><br><span class="line">        return self.items.pop()</span><br><span class="line"></span><br><span class="line">    def removeRear(self):</span><br><span class="line">        # 尾端出队</span><br><span class="line">        return self.items.pop(0)</span><br><span class="line"></span><br><span class="line">    def size(self):</span><br><span class="line">        # 大小</span><br><span class="line">        return len(self.items)</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日一题-删除有序数组中的重复项</title>
      <link href="/2023/08/29/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/"/>
      <url>/2023/08/29/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/</url>
      
        <content type="html"><![CDATA[<h3 id="题目简介"><a href="#题目简介" class="headerlink" title="题目简介"></a>题目简介</h3><p>给你一个 升序排列 的数组 nums<br>请你<strong>原地</strong>删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。元素的 相对顺序 应该保持 一致 。然后返回 nums 中唯一元素的个数。<br>考虑 nums 的唯一元素的数量为 k ，你需要做以下事情确保你的题解可以被通过：<br>更改数组 nums ，使 nums 的前 k 个元素包含唯一元素，并按照它们最初在 nums 中出现的顺序排列。nums 的其余元素与 nums 的大小不重要。<br>返回 k 。</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>使用双指针的方法解决<br>fast快指针用来寻找与前一项不同的两个相邻元素<br>slow慢指针用来标记可以覆盖的元素</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def removeDuplicates(self, nums):</span><br><span class="line">        if nums is []:</span><br><span class="line">            return 0</span><br><span class="line">        nums_len = len(nums)</span><br><span class="line">        fast = slow = 1</span><br><span class="line">        # 条件是快指针fast不越界</span><br><span class="line">        while fast &lt; nums_len:</span><br><span class="line">            # fast指针用来寻找不相等的两个相邻元素</span><br><span class="line">            # slow指针用来标记可以覆盖的元素</span><br><span class="line">            if nums[fast] != nums[fast - 1]:</span><br><span class="line">                nums[slow] = nums[fast]</span><br><span class="line">                slow += 1</span><br><span class="line">            fast += 1</span><br><span class="line">        print(nums[:slow])</span><br><span class="line">        return slow</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    s = Solution()</span><br><span class="line">    nums = [0, 0, 1, 1, 1, 2, 2, 3, 3, 4]</span><br><span class="line">    print(s.removeDuplicates(nums=nums))</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 力扣题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>查找最长公共前缀</title>
      <link href="/2023/08/24/%E6%9F%A5%E6%89%BE%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80/"/>
      <url>/2023/08/24/%E6%9F%A5%E6%89%BE%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80/</url>
      
        <content type="html"><![CDATA[<h3 id="问题简介"><a href="#问题简介" class="headerlink" title="问题简介"></a>问题简介</h3><p>编写一个函数来查找字符串数组中的最长公共前缀。<br>如果不存在公共前缀，返回空字符串 “”。<br>示例 1：<br>输入：strs &#x3D; [“flower”,”flow”,”flight”]<br>输出：”fl”<br>示例 2：<br>输入：strs &#x3D; [“dog”,”racecar”,”car”]<br>输出：””<br>解释：输入不存在公共前缀。</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><h4 id="横向扫描"><a href="#横向扫描" class="headerlink" title="横向扫描"></a>横向扫描</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution(object):</span><br><span class="line">    def longestCommonPrefix1(self, strs):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        横向扫描 字符串两两对比获得最长公共子序列</span><br><span class="line">        :type strs: List[str]</span><br><span class="line">        :rtype: str</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        if not strs:</span><br><span class="line">            return &quot;&quot;</span><br><span class="line"></span><br><span class="line">        prefix, count = strs[0], len(strs)</span><br><span class="line">        for i in range(1, count):</span><br><span class="line">            prefix = self.lcp(prefix, strs[i])</span><br><span class="line">            if not prefix:</span><br><span class="line">                break</span><br><span class="line">        return prefix</span><br><span class="line">    def lcp(self, str1, str2):</span><br><span class="line">        length, index = min(len(str1), len(str2)), 0</span><br><span class="line">        while index &lt; length and str1[index] == str2[index]:</span><br><span class="line">            index += 1</span><br><span class="line">        return str1[:index]</span><br></pre></td></tr></table></figure><h4 id="纵向扫描"><a href="#纵向扫描" class="headerlink" title="纵向扫描"></a>纵向扫描</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution(object):</span><br><span class="line">    def longestCommonPrefix2(self, strs):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        纵向扫描 一次性对比所有的字符串</span><br><span class="line">        :type strs: List[str]</span><br><span class="line">        :rtype: str</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        if not strs:</span><br><span class="line">            return &quot;&quot;</span><br><span class="line">        length, count = len(strs[0]), len(strs)</span><br><span class="line">        for i in range(count):</span><br><span class="line">            c = strs[0][i]</span><br><span class="line">            # Python 内置的 any(x) 函数接受一个可迭代的元素 x 作为参数，</span><br><span class="line">            # 如 list、元组或字典。如果在iterable中至少有一个元素使用隐式布尔转换计算为True，它返回True，否则返回False</span><br><span class="line">            # 如果iterable是空的，例如，any([])，它返回False，因为任何元素都不满足条件。</span><br><span class="line">            if any(i == len(strs[j]) or strs[j][i] != c for j in range(1, count)):</span><br><span class="line">                return strs[0][:i]</span><br><span class="line">        return strs[0]</span><br></pre></td></tr></table></figure><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    s = Solution()</span><br><span class="line">    str = [&quot;flower&quot;, &quot;flow&quot;, &quot;flight&quot;]</span><br><span class="line">    print(s.longestCommonPrefix1(str))</span><br><span class="line">    print(s.longestCommonPrefix2(str))</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 力扣题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>回文数的判断方法</title>
      <link href="/2023/08/23/%E5%9B%9E%E6%96%87%E6%95%B0%E7%9A%84%E5%88%A4%E6%96%AD%E6%96%B9%E6%B3%95/"/>
      <url>/2023/08/23/%E5%9B%9E%E6%96%87%E6%95%B0%E7%9A%84%E5%88%A4%E6%96%AD%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="判断回文数-有很多方法-记录几种方法如下"><a href="#判断回文数-有很多方法-记录几种方法如下" class="headerlink" title="判断回文数 有很多方法 记录几种方法如下"></a>判断回文数 有很多方法 记录几种方法如下</h2><h3 id="方法1"><a href="#方法1" class="headerlink" title="方法1"></a>方法1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def judge1(data):</span><br><span class="line">    data = str(data)</span><br><span class="line">    if data == &#x27;&#x27;.join(reversed(data)):</span><br><span class="line">        return True</span><br><span class="line">    else:</span><br><span class="line">        return False</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="方法2"><a href="#方法2" class="headerlink" title="方法2"></a>方法2</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def judge2(data):</span><br><span class="line">    data = str(data)</span><br><span class="line">    if data == data[::-1]:</span><br><span class="line">        return True</span><br><span class="line">    else:</span><br><span class="line">        return False</span><br></pre></td></tr></table></figure><h3 id="方法3"><a href="#方法3" class="headerlink" title="方法3"></a>方法3</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">def judge3(data):</span><br><span class="line">    # judge1和2都是利用str类型做判断 judge3使用的是整形</span><br><span class="line">    help = 1</span><br><span class="line">    # 生成一个辅助变量help 跟data的位数一致</span><br><span class="line">    while (data / help &gt;= 10):</span><br><span class="line">        help *= 10</span><br><span class="line">    print(help)</span><br><span class="line">    while (data != 0):</span><br><span class="line">        # 对比每一位是否相等</span><br><span class="line">        if (data // help != data % 10):</span><br><span class="line">            return False</span><br><span class="line">        # 调整data和help的位数</span><br><span class="line">        data = (data % help) // 10</span><br><span class="line">        help //= 100</span><br><span class="line">        print(data)</span><br><span class="line">        print(help)</span><br><span class="line">    return True</span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    data = 123321</span><br><span class="line">    if judge3(data):</span><br><span class="line">        print(f&quot;&#123;data&#125;是回文数&quot;)</span><br><span class="line">    else:</span><br><span class="line">        print(f&#x27;&#123;data&#125;不是回文数&#x27;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日一题-超级回文数</title>
      <link href="/2023/08/23/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-%E8%B6%85%E7%BA%A7%E5%9B%9E%E6%96%87%E6%95%B0/"/>
      <url>/2023/08/23/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-%E8%B6%85%E7%BA%A7%E5%9B%9E%E6%96%87%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="题目简介"><a href="#题目简介" class="headerlink" title="题目简介"></a>题目简介</h3><p>如果一个正整数自身是一个回文数，而且他也是一个回文数的平方，那么我们称这个数为超级回文数<br>现在我们给定义两个正整数L和R（字符串形式表示）返回包含在范围[L,R]中的超级回文数的数目<br>回文数就是从左往右和从右往左的顺序一致的整数例如121 232<br>实例:<br>输入L&#x3D;’4’R&#x3D;’1000’<br>输出 4<br>解释：4，9,121以及484是超级回文数 要注意的是676不是超级回文数 26*26 &#x3D; 676 但是26不是回文数</p><h3 id="函数解释"><a href="#函数解释" class="headerlink" title="函数解释"></a>函数解释</h3><pre><code>减小问题的规模 提高计算效率 修改最大限制 题目要求的是R小于10的18次方 运算量太大经过分析可以得知 如果把R先开方再对半除就能得到最大限制limit是10的5次方从0开始使用函数palindrome_number_make去创建回文数再平方该回文数传参给函数palindrome_number_judge判断是不是回文数再判断生成的回文数的平方是不是在题目所给的范围内，如果满足以上要求那么就是超级回文数让result加1最后将结果返回</code></pre><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">def palindrome_number_judge(data):</span><br><span class="line">    # 判断传入的data是不是回文数</span><br><span class="line">    data = str(data)</span><br><span class="line">    if data == data[::-1]:</span><br><span class="line">        return True</span><br><span class="line">    else:</span><br><span class="line">        return False</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def palindrome_number_make(data):</span><br><span class="line">    # 加工回文数生成 一个data生成两个回文数分别是奇数长度回文数和偶数长度回文数</span><br><span class="line">    # 比如data = 1，然后加工出的回文数是11和1</span><br><span class="line">    # data是123，加工出的回文数是123321和12321</span><br><span class="line">    if data &gt;= 10:</span><br><span class="line">        data = str(data)</span><br><span class="line">        data_1 = data + data[::-1]</span><br><span class="line">        data_2 = data + data[-2::-1]</span><br><span class="line">    else:</span><br><span class="line">        data = str(data)</span><br><span class="line">        data_1 = data</span><br><span class="line">        data_2 = data + data[::-1]</span><br><span class="line">    data_1 = int(data_1)</span><br><span class="line">    data_2 = int(data_2)</span><br><span class="line">    return data_1, data_2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def reduce_que_size(L, R):</span><br><span class="line"></span><br><span class="line">    limit = 100000</span><br><span class="line">    result = 0</span><br><span class="line">    for data in range(limit):</span><br><span class="line">        data_1, data_2 = palindrome_number_make(data)</span><br><span class="line">        if data_1 ** 2 &gt; R:</span><br><span class="line">            break</span><br><span class="line">        if palindrome_number_judge(data_1 * data_1) and L &lt;= data_1 ** 2:</span><br><span class="line">            result += 1</span><br><span class="line"></span><br><span class="line">    for data in range(limit):</span><br><span class="line">        data_1, data_2 = palindrome_number_make(data)</span><br><span class="line">        if data_2 ** 2 &gt; R:</span><br><span class="line">            break</span><br><span class="line">        if palindrome_number_judge(data_2 * data_2) and L &lt;= data_2 ** 2:</span><br><span class="line">            result += 1</span><br><span class="line">    return result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    print(reduce_que_size(1, 5))</span><br><span class="line">    print(palindrome_number_make(9))</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 力扣题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日一题-无线环绕字符串中寻找非空子串问题</title>
      <link href="/2023/08/22/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-%E6%97%A0%E7%BA%BF%E7%8E%AF%E7%BB%95%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E5%AF%BB%E6%89%BE%E9%9D%9E%E7%A9%BA%E5%AD%90%E4%B8%B2%E9%97%AE%E9%A2%98/"/>
      <url>/2023/08/22/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-%E6%97%A0%E7%BA%BF%E7%8E%AF%E7%BB%95%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E5%AF%BB%E6%89%BE%E9%9D%9E%E7%A9%BA%E5%AD%90%E4%B8%B2%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="题目简介"><a href="#题目简介" class="headerlink" title="题目简介"></a>题目简介</h3><p>无线环绕字符串寻找非空子串问题：假设有一个想象的字符串f：…a-z a-z a-z…这样循环，现有一字符串s，请找出字符串s中不重复的<br>非空的子串在想象串f中的不重复非空子串的个数</p><h3 id="解析："><a href="#解析：" class="headerlink" title="解析："></a>解析：</h3><p>将字符串s从左到右依次寻找，第一个以a结尾的子串在f中的个数是1是a，第二个以a结尾的子串在f中的个数是3分别是a za yza，可以看出第二个以a结尾的子串<br>在f中的个数包含了第一个以a结尾的子串，因此可以知道，以相同字母结尾的子串在f中的个数取最大值即可，所以以s串中的每一个字母结尾的子串在f中能找到的<br>个数分别是 a:1 b:2 y:1 z:2 a: 3 b :4,然后将数据整合放入dict中可以得到a:3 b:4 y:1 z:2，将每一个字母的value值加起来就是本题的解</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">def build_f():</span><br><span class="line">    # f串的构建</span><br><span class="line">    f = [chr(i) for i in range(97, 123)]</span><br><span class="line">    f = &quot;&quot;.join(f)</span><br><span class="line">    # 假设是3倍a-z</span><br><span class="line">    f = f * 3</span><br><span class="line">    return f</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def search_str(s):</span><br><span class="line">    # 搜索字符串方法</span><br><span class="line">    # 默认长度为1 str_len是前一个字符成长的长度</span><br><span class="line">    str_len = 1</span><br><span class="line">    str_dict = &#123;&#125;</span><br><span class="line">    for i in range(len(s)):</span><br><span class="line">        cur = s[i]  # 当前的字符串</span><br><span class="line">        pre = s[i - 1]  # 之前的字符串</span><br><span class="line">        if cur == &#x27;a&#x27; and pre == &#x27;z&#x27;:</span><br><span class="line">            str_len += 1</span><br><span class="line">        elif chr(ord(pre) + 1) == cur:</span><br><span class="line">            str_len += 1</span><br><span class="line">        else:</span><br><span class="line">            str_len = 1</span><br><span class="line">        # 将数据放入dict中</span><br><span class="line">        if str_dict.get(s[i]):</span><br><span class="line">            if str_len&gt;str_dict[s[i]]:</span><br><span class="line">                str_dict.update(&#123;s[i]: str_len&#125;)</span><br><span class="line">        else:</span><br><span class="line">            str_dict.update(&#123;s[i]: str_len&#125;)</span><br><span class="line"></span><br><span class="line">    return str_dict</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    # f = &#x27;...a-z a-z a-z...&#x27;</span><br><span class="line">    s = &#x27;abyzab&#x27;</span><br><span class="line">    # f串没用上 只是一个假设的串</span><br><span class="line">    f = build_f()</span><br><span class="line">    print(search_str(s))</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 力扣题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法进阶-动态规划</title>
      <link href="/2023/07/27/%E7%AE%97%E6%B3%95%E8%BF%9B%E9%98%B6-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
      <url>/2023/07/27/%E7%AE%97%E6%B3%95%E8%BF%9B%E9%98%B6-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
      
        <content type="html"><![CDATA[<h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>动态规划（英语：Dynamic programming，简称 DP），是一种在数学、管理科学、计算机科学、经济学和生物信息学中使用的，通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。动态规划常常适用于有重叠子问题和最优子结构性质的问题。<br>以上定义来自维基百科，看定义感觉还是有点抽象。简单来说，动态规划其实就是，给定一个问题，我们把它拆成一个个子问题，直到子问题可以直接解决。然后呢，把子问题答案保存起来，以减少重复计算。再根据子问题答案反推，得出原问题解的一种方法。<br>动态规划最核心的思想，就在于拆分子问题，记住过往，减少重复计算。<br>摘自：<a href="https://zhuanlan.zhihu.com/p/365698607">https://zhuanlan.zhihu.com/p/365698607</a></p><h3 id="斐波那契数列看动态规划"><a href="#斐波那契数列看动态规划" class="headerlink" title="斐波那契数列看动态规划"></a>斐波那契数列看动态规划</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">def fibnacci(n):</span><br><span class="line">    f = [0, 1, 1]</span><br><span class="line">    if n &gt; 2:</span><br><span class="line">        for i in range(n - 2):</span><br><span class="line">            num = f[-1] + f[-2]</span><br><span class="line">            f.append(num)</span><br><span class="line">    return f[n]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(fibnacci(100)) </span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法进阶 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法进阶-贪心算法</title>
      <link href="/2023/07/26/%E7%AE%97%E6%B3%95%E8%BF%9B%E9%98%B6-%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
      <url>/2023/07/26/%E7%AE%97%E6%B3%95%E8%BF%9B%E9%98%B6-%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h2><p>又称贪婪算法，是指在对问题求解时，总是做出在当前看来是最好的选择，也就是说，不从整体最优上加以考虑<br>贪心算法所做的是在某种意义上的局部最优解<br>贪心算法并不保证会得到最优解，但是在某些问题上贪心算法的解就是最优解。<br>要会判断一个问题是否能用贪心算法解决</p><h3 id="模拟商店找零问题"><a href="#模拟商店找零问题" class="headerlink" title="模拟商店找零问题"></a>模拟商店找零问题</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># change函数需要两个参数t是找零面值list，n是你输入的要找零金额</span><br><span class="line"># 找零的面值如下：</span><br><span class="line">t = [100, 50, 20, 5, 1]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def change(t, n):</span><br><span class="line">    m = [0 for _ in range(len(t))]</span><br><span class="line">    for i, money in enumerate(t):</span><br><span class="line">    # enumerate用来给t列表的每一项一个索引，默认从0开始，用在for循环中就是把索引值赋给i</span><br><span class="line">        m[i] = n // money</span><br><span class="line">        n = n % money</span><br><span class="line">    return m, n</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 打印366元的找零结果</span><br><span class="line">print(change(t, 376))</span><br></pre></td></tr></table></figure><h3 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h3><p>0-1背包：对于一个商品，要么拿走要么留下，不能拿走1部分<br>分数背包：对一个商品，可以拿走其中一部分<br>举例：v和w分别是价值和重量<br>商品1：v1&#x3D; 60 w1 &#x3D;10<br>商品2：v2 &#x3D; 100 w2 &#x3D; 20<br>商品3：v3 &#x3D; 120 w3 &#x3D; 30<br>背包容量 w&#x3D;50</p><h4 id="分数背包的实现"><a href="#分数背包的实现" class="headerlink" title="分数背包的实现"></a>分数背包的实现</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">goods = [(60, 10), (120, 30), (100, 20)]</span><br><span class="line"># 单位重量下更值钱的商品 降序排列</span><br><span class="line">goods.sort(key=lambda x: x[0] / x[1], reverse=True)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def fractional_bakcpack(goods, w):</span><br><span class="line">    m = [0 for _ in range(len(goods))]</span><br><span class="line">    total_v = 0</span><br><span class="line">    for i, (prize, weight) in enumerate(goods):</span><br><span class="line">        if w &gt;= weight:</span><br><span class="line">            m[i] = 1</span><br><span class="line">            total_v += prize</span><br><span class="line">            w -= weight</span><br><span class="line">        else:</span><br><span class="line">            m[i] = w / weight</span><br><span class="line">            total_v += m[i] * prize</span><br><span class="line">            w = 0</span><br><span class="line">            break</span><br><span class="line">    return total_v,m</span><br><span class="line"></span><br><span class="line">print(goods)</span><br><span class="line">print(fractional_bakcpack(goods, 50))</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="拼接最大数字问题"><a href="#拼接最大数字问题" class="headerlink" title="拼接最大数字问题"></a>拼接最大数字问题</h3><p>问题描述：<br>有n个非负整数，将其按照字符串拼接的方式拼接为一个整数，如何拼接可以使得到的的整数最大？<br>例如：32,94,128,1286,6,71 可以拼接的最大整数为94716321286128</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">from functools import cmp_to_key</span><br><span class="line">li = [32,94,128,1286,6,71]</span><br><span class="line">def xy_cmp(x,y):</span><br><span class="line">    if x+y &lt;y+x:</span><br><span class="line">        return 1</span><br><span class="line">    elif x+y&gt;y+x:</span><br><span class="line">        return -1</span><br><span class="line">    else:</span><br><span class="line">        return 0</span><br><span class="line"></span><br><span class="line">def number_join(li):</span><br><span class="line">    li = list(map(str,li))</span><br><span class="line">    li.sort(key=cmp_to_key(xy_cmp))</span><br><span class="line">    return &quot;&quot;.join(li)</span><br><span class="line"></span><br><span class="line">print(number_join(li))</span><br></pre></td></tr></table></figure><h3 id="活动选择问题"><a href="#活动选择问题" class="headerlink" title="活动选择问题"></a>活动选择问题</h3><p>问题概述：<br>假设有n个活动，这些活动要占用同一片场地，而场地在某个时刻只能供一个和活动使用。<br>每个活动都有一个开始时间si和结束时间fi（题目中时间以整数表示），表示活动在[si,fi)区间占用场地<br>问：安排哪些活动能够使改场地举办的活动个数最多？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">activities = [</span><br><span class="line">    (1, 4),</span><br><span class="line">    (3, 5),</span><br><span class="line">    (0, 6),</span><br><span class="line">    (5, 7),</span><br><span class="line">    (3, 9),</span><br><span class="line">    (5, 9),</span><br><span class="line">    (6, 10),</span><br><span class="line">    (8, 11),</span><br><span class="line">    (8, 12),</span><br><span class="line">    (2, 14),</span><br><span class="line">    (12, 16)</span><br><span class="line">]</span><br><span class="line"># 排序保证活动是按照结束时间排好序的</span><br><span class="line">activities.sort(key=lambda x: x[1])</span><br><span class="line">print(activities)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def activity_selection(a):</span><br><span class="line">    res = [a[0]]</span><br><span class="line">    for i in range(1, len(a)):</span><br><span class="line">        if a[i][0] &gt;= res[-1][1]:  # 当前活动开始时间小于等于最后一个入选活动的结束时间</span><br><span class="line">            # 不冲突</span><br><span class="line">            res.append(a[i])</span><br><span class="line">    return res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(activity_selection(activities))</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法进阶 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构-树与二叉树</title>
      <link href="/2023/07/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>/2023/07/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><p>树结构是一种包括节点(nodes)和边(edges)的拥有层级关系的一种结构， 它的形式和家谱树非常类似.<br>linux 文件结构（tree 命令），它的结构也是一棵树。<br>根节点(root): 树的最上层的节点，任何非空的树都有一个节点<br>路径(path): 从起始节点到终止节点经历过的边<br>父亲(parent)：除了根节点，每个节点的上一层边连接的节点就是它的父亲(节点)<br>孩子(children): 每个节点由边指向的下一层节点<br>兄弟(siblings): 同一个父亲并且处在同一层的节点<br>子树(subtree): 每个节点包含它所有的后代组成的子树<br>叶子节点(leaf node): 没有孩子的节点成为叶子节点</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">class Node:</span><br><span class="line">    # 链式存储的方式存储树</span><br><span class="line">    def __init__(self, name, type=&#x27;dir&#x27;):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.type = type</span><br><span class="line">        self.children = []</span><br><span class="line">        self.parent = None</span><br><span class="line"></span><br><span class="line">    def __repr__(self):</span><br><span class="line">        return self.name</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class FileSystemTree:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.root = Node(&quot;/&quot;)</span><br><span class="line">        self.now = self.root</span><br><span class="line"></span><br><span class="line">    def mkdir(self, name):</span><br><span class="line">        if name[-1] != &quot;/&quot;:</span><br><span class="line">            name += &quot;/&quot;</span><br><span class="line">        node = Node(name)</span><br><span class="line">        self.now.children.append(node)</span><br><span class="line">        node.parent = self.now</span><br><span class="line"></span><br><span class="line">    def ls(self):</span><br><span class="line">        return self.now.children</span><br><span class="line"></span><br><span class="line">    def cd(self, name):</span><br><span class="line">        if name[-1] != &quot;/&quot;:</span><br><span class="line">            name += &quot;/&quot;</span><br><span class="line">        if name == &quot;../&quot;:</span><br><span class="line">            self.now = self.now.parent</span><br><span class="line">            return</span><br><span class="line">        for child in self.now.children:</span><br><span class="line">            if child.name == name:</span><br><span class="line">                self.now = child</span><br><span class="line">                return</span><br><span class="line">        raise ValueError(&quot;invalid dir&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">tree = FileSystemTree()</span><br><span class="line">tree.mkdir(&quot;var/&quot;)</span><br><span class="line">tree.mkdir(&quot;bin/&quot;)</span><br><span class="line">tree.mkdir(&quot;usr/&quot;)</span><br><span class="line">print(tree.ls())</span><br><span class="line">tree.cd(&quot;bin/&quot;)</span><br><span class="line">tree.mkdir(&quot;pyhton/&quot;)</span><br><span class="line">print(tree.ls())</span><br><span class="line">tree.cd(&quot;../&quot;)</span><br><span class="line">print(tree.ls())</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><p>了解完树的结构以后，我们来看树结构里一种简单但是却比较常用的树-二叉树。<br>二叉树是一种简单的树，它的每个节点最多只能包含两个孩子.<br>通过上边这幅图再来看几个二叉树相关的概念:<br>节点深度(depth): 节点对应的 level 数字<br>树的高度(height): 二叉树的高度就是 level 数 + 1，因为 level 从 0开始计算的<br>树的宽度(width): 二叉树的宽度指的是包含最多节点的层级的节点数<br>树的 size：二叉树的节点总个数。</p><h3 id="满二叉树-full-binary-tree"><a href="#满二叉树-full-binary-tree" class="headerlink" title="满二叉树(full binary tree)"></a>满二叉树(full binary tree)</h3><p>如果每个内部节点（非叶节点）都包含两个孩子，就成为满二叉树。</p><h3 id="完美二叉树-perfect-binary-tree"><a href="#完美二叉树-perfect-binary-tree" class="headerlink" title="完美二叉树(perfect binary tree)"></a>完美二叉树(perfect binary tree)</h3><p>当所有的叶子节点都在同一层就是完美二叉树，毫无间隙填充了 h 层。</p><h3 id="完全二叉树-complete-binary-tree"><a href="#完全二叉树-complete-binary-tree" class="headerlink" title="完全二叉树(complete binary tree)"></a>完全二叉树(complete binary tree)</h3><p>当一个高度为 h 的完美二叉树减少到 h-1，并且最底层的槽被毫无间隙地从左到右填充，我们就叫它完全二叉树</p><h3 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h3><p>二叉树其实是一种递归结构，因为单独拿出来一个 subtree 子树出来，其实它还是一棵树。那遍历它就很方便啦，我们可以直接用递归的方式来遍历它。但是当处理顺序不同的时候，树又分为三种遍历方式:</p><p>先(根)序遍历: 先处理根，之后是左子树，然后是右子树<br>中(根)序遍历: 先处理左子树，之后是根，最后是右子树<br>后(根)序遍历: 先处理左子树，之后是右子树，最后是根</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">class BitreeNode:</span><br><span class="line">    def __init__(self, data):</span><br><span class="line">        self.data = data</span><br><span class="line">        self.lchild = None  # 左孩子</span><br><span class="line">        self.rchild = None  # 右孩子</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 手动创建二叉树创建节点</span><br><span class="line">a = BitreeNode(&quot;A&quot;)</span><br><span class="line">b = BitreeNode(&quot;B&quot;)</span><br><span class="line">c = BitreeNode(&quot;C&quot;)</span><br><span class="line">d = BitreeNode(&quot;D&quot;)</span><br><span class="line">e = BitreeNode(&quot;E&quot;)</span><br><span class="line">f = BitreeNode(&quot;F&quot;)</span><br><span class="line">g = BitreeNode(&quot;G&quot;)</span><br><span class="line"></span><br><span class="line">e.lchild = a</span><br><span class="line">e.rchild = g</span><br><span class="line">a.rchild = c</span><br><span class="line">c.lchild = b</span><br><span class="line">c.rchild = d</span><br><span class="line">g.rchild = f</span><br><span class="line"></span><br><span class="line">root = e</span><br><span class="line">print(root.lchild.rchild.data)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def pre_order(root):</span><br><span class="line">    # 前序遍历</span><br><span class="line">    if root:</span><br><span class="line">        print(root.data, end=&quot;,&quot;)</span><br><span class="line">        pre_order(root.lchild)</span><br><span class="line">        pre_order(root.rchild)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def in_order(root):</span><br><span class="line">    # 中序遍历</span><br><span class="line">    if root:</span><br><span class="line">        in_order(root.lchild)</span><br><span class="line">        print(root.data, end=&quot;,&quot;)</span><br><span class="line">        in_order(root.rchild)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def post_order(root):</span><br><span class="line">    # 后序遍历</span><br><span class="line">    if root:</span><br><span class="line">        post_order(root.lchild)</span><br><span class="line">        post_order(root.rchild)</span><br><span class="line">        print(root.data, end=&quot;,&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">from collections import deque</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def level_order(root):</span><br><span class="line">    # 层次遍历</span><br><span class="line">    queue = deque()</span><br><span class="line">    queue.append(root)</span><br><span class="line">    while len(queue) &gt; 0:</span><br><span class="line">        node = queue.popleft()</span><br><span class="line">        print(node.data, end=&#x27;,&#x27;)</span><br><span class="line">        if node.lchild:</span><br><span class="line">            queue.append(node.lchild)</span><br><span class="line">        if node.rchild:</span><br><span class="line">            queue.append(node.rchild)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pre_order(root)</span><br><span class="line">print()</span><br><span class="line">in_order(root)</span><br><span class="line">print()</span><br><span class="line">post_order(root)</span><br><span class="line">print()</span><br><span class="line">level_order(root)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h2><p>二叉搜索树是一个二叉树且满足在性质：<br>设x是二叉树的一个节点。如果y是x左子树的一个节点，那么y.key&lt;&#x3D;x.key;<br>如果y是x右子树的一个节点，那么y.key&gt;&#x3D;x.key<br>二叉搜索树的操作：查询、插入、删除</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br></pre></td><td class="code"><pre><span class="line">import random</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class BitreeNode:</span><br><span class="line">    def __init__(self, data):</span><br><span class="line">        self.data = data</span><br><span class="line">        self.lchild = None  # 左孩子</span><br><span class="line">        self.rchild = None  # 右孩子</span><br><span class="line">        self.parent = None  # 父节点</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class BST:</span><br><span class="line">    def __init__(self, li=None):</span><br><span class="line">        self.root = None</span><br><span class="line">        if li:</span><br><span class="line">            for val in li:</span><br><span class="line">                self.insert_norec(val)</span><br><span class="line"></span><br><span class="line">    def insert(self, node, val):</span><br><span class="line">        if not node:</span><br><span class="line">            node = BitreeNode(val)</span><br><span class="line">        elif val &lt; node.data:</span><br><span class="line">            node.lchild = self.insert(node.lchild, val)</span><br><span class="line">            node.lchild.parent = node</span><br><span class="line">        elif val &gt; node.data:</span><br><span class="line">            node.rchild = self.insert(node.rchild, val)</span><br><span class="line">            node.rchild.parent = node</span><br><span class="line">        else:</span><br><span class="line">            pass</span><br><span class="line">        return node</span><br><span class="line"></span><br><span class="line">    def insert_norec(self, val):</span><br><span class="line">        # 非递归插入</span><br><span class="line">        p = self.root</span><br><span class="line">        if not p:  # 空数</span><br><span class="line">            self.root = BitreeNode(val)</span><br><span class="line">            return</span><br><span class="line">        while True:</span><br><span class="line">            if val &lt; p.data:</span><br><span class="line">                if p.lchild:</span><br><span class="line">                    p = p.lchild</span><br><span class="line">                else:  # 左孩子不存在时</span><br><span class="line">                    p.lchild = BitreeNode(val)</span><br><span class="line">                    p.lchild.parent = p</span><br><span class="line">                    return</span><br><span class="line">            elif val &gt; p.data:</span><br><span class="line">                if p.rchild:</span><br><span class="line">                    p = p.rchild</span><br><span class="line">                else:</span><br><span class="line">                    p.rchild = BitreeNode(val)</span><br><span class="line">                    p.rchild.parent = p</span><br><span class="line">                    return</span><br><span class="line">            else:</span><br><span class="line">                return</span><br><span class="line"></span><br><span class="line">    def query(self, node, val):</span><br><span class="line">        # 查询</span><br><span class="line">        if not node:</span><br><span class="line">            return None</span><br><span class="line">        if node.data &lt; val:</span><br><span class="line">            return self.query(node.rchild, val)</span><br><span class="line">        elif node.data &gt; val:</span><br><span class="line">            return self.query(node.rchild, val)</span><br><span class="line">        else:</span><br><span class="line">            return node</span><br><span class="line"></span><br><span class="line">    def query_norec(self, val):</span><br><span class="line">        # 非递归查询</span><br><span class="line">        p = self.root</span><br><span class="line">        while p:</span><br><span class="line">            if p.data &lt; val:</span><br><span class="line">                p = p.rchild</span><br><span class="line">            elif p.data &gt; val:</span><br><span class="line">                p = p.lchild</span><br><span class="line">            else:</span><br><span class="line">                return p</span><br><span class="line">        else:</span><br><span class="line">            return None</span><br><span class="line"></span><br><span class="line">    def remove_node1(self, node):</span><br><span class="line">        # 删除的情况1 node是叶子节点没有孩子</span><br><span class="line">        if not node.parent:</span><br><span class="line">            # 判断是不是根节点</span><br><span class="line">            self.root = None</span><br><span class="line">        if node.parent == node.parent.lchild:</span><br><span class="line">            # node是父亲的左孩子</span><br><span class="line">            node.parent.lchild = None</span><br><span class="line">        else:</span><br><span class="line">            # node是父亲的右孩子</span><br><span class="line">            node.parent.rchild = None</span><br><span class="line"></span><br><span class="line">    def remove_node21(self, node):</span><br><span class="line">        # 删除的情况2.1 node只有一个左孩子</span><br><span class="line">        if not node.parent:</span><br><span class="line">            self.root = node.lchild</span><br><span class="line">            node.lchild.parent = None</span><br><span class="line">        elif node == node.parent.lchild:</span><br><span class="line">            node.parent.lchild = node.lchild</span><br><span class="line">            node.lchild.parent = node.parent</span><br><span class="line">        else:</span><br><span class="line">            node.parent.rchild = node.lchild</span><br><span class="line">            node.lchild.parent = node.parent</span><br><span class="line"></span><br><span class="line">    def remove_node22(self, node):</span><br><span class="line">        # 删除情况2.2 node只有一个右孩子</span><br><span class="line">        if not node.parent:</span><br><span class="line">            self.root = node.rchild</span><br><span class="line">            node.rchild.parent = None</span><br><span class="line">        elif node == node.parent.lchild:</span><br><span class="line">            node.parent.lchild = node.rchild</span><br><span class="line">            node.rchild.parent = node.parent</span><br><span class="line">        else:</span><br><span class="line">            node.parent.rchild = node.rchild</span><br><span class="line">            node.rchild.parent = node.parent</span><br><span class="line"></span><br><span class="line">    def delete(self, val):</span><br><span class="line">        if self.root:</span><br><span class="line">            # 不是空树再删除</span><br><span class="line">            node = self.query_norec(val)</span><br><span class="line">            if not node:</span><br><span class="line">                return False</span><br><span class="line">            # 存在node</span><br><span class="line">            if not node.lchild and not node.rchild:</span><br><span class="line">                # 情况1 没有左孩子也没有右孩子</span><br><span class="line">                self.remove_node1(node)</span><br><span class="line">            elif not node.rchild:</span><br><span class="line">                # 情况2.1只有一个左孩子</span><br><span class="line">                self.remove_node21(node)</span><br><span class="line">            elif not node.lchild:</span><br><span class="line">                # 情况2.2 只有一个右孩子</span><br><span class="line">                self.remove_node22(node)</span><br><span class="line">            else:</span><br><span class="line">                #  情况3 两个孩子都有</span><br><span class="line">                min_node = node.rchild  # min_node就是右子树里最小的节点</span><br><span class="line">                while min_node == min_node.lchild:</span><br><span class="line">                    min_node = min_node.lchild</span><br><span class="line">                node.data = min_node.data</span><br><span class="line">                # 删除min_node</span><br><span class="line">                if min_node.rchild:</span><br><span class="line">                    self.remove_node22(min_node)</span><br><span class="line">                else:</span><br><span class="line">                    self.remove_node1(min_node)</span><br><span class="line"></span><br><span class="line">    def pre_order(self, root):</span><br><span class="line">        # 前序遍历</span><br><span class="line">        if root:</span><br><span class="line">            print(root.data, end=&quot;,&quot;)</span><br><span class="line">            self.pre_order(root.lchild)</span><br><span class="line">            self.pre_order(root.rchild)</span><br><span class="line"></span><br><span class="line">    def in_order(self, root):</span><br><span class="line">        # 中序遍历</span><br><span class="line">        if root:</span><br><span class="line">            self.in_order(root.lchild)</span><br><span class="line">            print(root.data, end=&quot;,&quot;)</span><br><span class="line">            self.in_order(root.rchild)</span><br><span class="line"></span><br><span class="line">    def post_order(self, root):</span><br><span class="line">        # 后序遍历</span><br><span class="line">        if root:</span><br><span class="line">            self.post_order(root.lchild)</span><br><span class="line">            self.post_order(root.rchild)</span><br><span class="line">            print(root.data, end=&quot;,&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 遍历</span><br><span class="line">tree = BST([4, 6, 7, 9, 2, 1, 3, 5, 8])</span><br><span class="line">print(&quot;前序遍历：&quot;)</span><br><span class="line">tree.pre_order(tree.root)</span><br><span class="line">print()</span><br><span class="line">print(&quot;中序遍历(对于二叉搜索树来说中序遍历一定是升序的)：&quot;)</span><br><span class="line">tree.in_order(tree.root)</span><br><span class="line">print()</span><br><span class="line">print(&quot;后序遍历：&quot;)</span><br><span class="line">tree.post_order(tree.root)</span><br><span class="line">print()</span><br><span class="line"># 查询</span><br><span class="line">li = list(range(0, 500, 2))</span><br><span class="line">random.shuffle(li)</span><br><span class="line">tree = BST(li)</span><br><span class="line">print(tree.query_norec(4))</span><br><span class="line"># 删除</span><br><span class="line">tree = BST([1, 4, 2, 5, 3, 8, 9, 6, 9, 7])</span><br><span class="line">tree.in_order(tree.root)</span><br><span class="line">tree.delete(4)</span><br><span class="line">tree.delete(5)</span><br><span class="line">tree.delete(1)</span><br><span class="line">print()</span><br><span class="line">tree.in_order(tree.root)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="AVL树-代码看不懂-没学明白-暂时记录下来"><a href="#AVL树-代码看不懂-没学明白-暂时记录下来" class="headerlink" title="AVL树(代码看不懂 没学明白 暂时记录下来)"></a>AVL树(代码看不懂 没学明白 暂时记录下来)</h3><p>AVL树是一棵自平衡的二叉搜索树，具有以下性质:<br>树的左右子树高度差的绝对值不能超过1<br>根的左右子树都是平衡二叉树<br>AVL树的扩展应用：B树(B-Tree):<br>b树是一棵自平衡的多路搜索树，常用于数据库的索引</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line">from bst import BST, BitreeNode</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class AVLNode(BitreeNode):</span><br><span class="line">    def __init__(self, data):</span><br><span class="line">        BitreeNode.__init__(self, data)</span><br><span class="line">        self.bf = 0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class AVLTree(BST):</span><br><span class="line">    def __init__(self, li=None):</span><br><span class="line">        BST.__init__(self, li)</span><br><span class="line"></span><br><span class="line">    def rotate_left(self, p, c):</span><br><span class="line">        # 根的右孩子的右子树插入导致的不平衡：左旋操作</span><br><span class="line">        s2 = c.lchild</span><br><span class="line">        p.rchild = s2</span><br><span class="line">        if s2:</span><br><span class="line">            s2.parent = p</span><br><span class="line">        c.lchild = p</span><br><span class="line">        p.parent = c</span><br><span class="line">        # 更新平衡因子</span><br><span class="line">        p.bf = 0</span><br><span class="line">        c.bf = 0</span><br><span class="line">        return c</span><br><span class="line"></span><br><span class="line">    def rotate_right(self, p, c):</span><br><span class="line">        # 根的左孩子的左子树插入导致的不平衡：右旋操作</span><br><span class="line">        s2 = c.rchild</span><br><span class="line">        p.lchild = s2</span><br><span class="line">        if s2:</span><br><span class="line">            s2.parent = p</span><br><span class="line">        c.rchild = p</span><br><span class="line">        p.parent = c</span><br><span class="line">        # 更新平衡因子</span><br><span class="line">        p.bf = 0</span><br><span class="line">        c.bf = 0</span><br><span class="line">        return c</span><br><span class="line"></span><br><span class="line">    def rotate_right_left(self, p, c):</span><br><span class="line">        # 根的右孩子的左子树插入导致的不平衡，先右旋再左旋</span><br><span class="line">        g = c.lchild</span><br><span class="line">        s3 = g.rchild</span><br><span class="line">        c.lchild = s3</span><br><span class="line">        if s3:</span><br><span class="line">            s3.parent = c</span><br><span class="line">        g.rchild = c</span><br><span class="line">        c.parent = g</span><br><span class="line">        s2 = g.lchild</span><br><span class="line">        p.rchild = s2</span><br><span class="line">        if s2:</span><br><span class="line">            s2.parent = p</span><br><span class="line">        g.lchild = p</span><br><span class="line">        p.parent = g</span><br><span class="line">        # 更新平衡因子</span><br><span class="line">        if g.bf &gt; 0:</span><br><span class="line">            p.bf = -1</span><br><span class="line">            c.bf = 0</span><br><span class="line">        elif g.bf &lt; 0:</span><br><span class="line">            p.bf = 0</span><br><span class="line">            c.bf = 1</span><br><span class="line">        else:</span><br><span class="line">            p.bf = 0</span><br><span class="line">            c.bf = 0</span><br><span class="line"></span><br><span class="line">    def rotate_left_right(self, p, c):</span><br><span class="line">        # 根的左孩子的右子树插入导致的不平衡，先左旋再右旋</span><br><span class="line">        g = c.rchild</span><br><span class="line">        s2 = g.lchild</span><br><span class="line">        c.rchild = s2</span><br><span class="line">        if s2:</span><br><span class="line">            s2.parent = c</span><br><span class="line">        g.lchild = c</span><br><span class="line">        c.parent = g</span><br><span class="line">        s3 = g.rchild</span><br><span class="line">        p.lchild = s3</span><br><span class="line">        if s3:</span><br><span class="line">            s3.parent = p</span><br><span class="line">        g.rchild = p</span><br><span class="line">        p.parent = g</span><br><span class="line">        # 更新因子</span><br><span class="line">        if g.bf &lt; 0:</span><br><span class="line">            p.bf = 1</span><br><span class="line">            c.bf = 0</span><br><span class="line">        elif g.bf &gt; 0:</span><br><span class="line">            p.bf = 0</span><br><span class="line">            c.bf = -1</span><br><span class="line">        else:</span><br><span class="line">            p.bf = 0</span><br><span class="line">            c.bf = 0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构-链表</title>
      <link href="/2023/07/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/"/>
      <url>/2023/07/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p>链表也是比较常见的数据结构，其与数组经常做对比，<br>对于数组，需要连续的内存地址来存储数据，对内存的要求较高，而链表恰恰相反，它并不需要一块连续的内存空间，它通过“指针”将一组零散的内存块串联起来使用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">class Node:</span><br><span class="line">    def __init__(self, item):</span><br><span class="line">        self.item = item</span><br><span class="line">        self.next = None</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def create_head_linklist(li):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    头插法创建链表</span><br><span class="line">    :param li:</span><br><span class="line">    :return:</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    head = Node(li[0])</span><br><span class="line">    for element in li[1:]:</span><br><span class="line">        node = Node(element)</span><br><span class="line">        node.next = head</span><br><span class="line">        head = node</span><br><span class="line">    return head</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def create_tail_linklist(li):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    尾插法创建链表</span><br><span class="line">    :param li:</span><br><span class="line">    :return:</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    head = Node(li[0])</span><br><span class="line">    tail = head</span><br><span class="line">    for element in li[1:]:</span><br><span class="line">        node = Node(element)</span><br><span class="line">        tail.next = node</span><br><span class="line">        tail = node</span><br><span class="line">    return head</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def print_linklist(lk):</span><br><span class="line">    while lk:</span><br><span class="line">        print(lk.item, end=&quot;,&quot;)</span><br><span class="line">        lk = lk.next</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">lk1 = create_head_linklist([1, 2, 3, 4, 5])</span><br><span class="line">lk2 = create_tail_linklist([4, 5, 6, 7, 8])</span><br><span class="line">print_linklist(lk1)</span><br><span class="line">print()</span><br><span class="line">print_linklist(lk2)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构-hash表</title>
      <link href="/2023/07/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-hash%E8%A1%A8/"/>
      <url>/2023/07/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-hash%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><p>hash表又叫散列表<br>hash表是一种线性表的存储结构，哈希表由一个直接寻址表和一个哈希函数组成，哈希函数h(k)将元素关键字作为自变量，返回元素的存储下标<br>由于哈希表的大小是有限的，而要存储的值的总数量无限的，由此对于任何哈希函数，都会出现两个不同元素映射到同一个位置上的情况，这种情况被称为哈希冲突<br>解决哈希冲突：<br>开放寻址法：如果哈希函数返回的位置已经有了值，则可以向后探查新的位置来存储这个值<br>1、线性探查：如果位置i被占用，则探查i+1，i+2…<br>2、二次探查：如果位置i被占用，则探查i+1的平方、i-1的平方、i+2的平方、i-2的平方<br>3、二度哈希：有n个哈希函数，当使用第一个哈希函数h1发生冲突时，尝试使用哈希函数h2、h3<br>拉链法：哈希表的每一个位置都连接一个链表，当冲突发生后，冲突的元素将被加到改位置链表的最后<br>常见的hash函数：<br>1、除法哈希：h(k) &#x3D; k % m<br>2、乘法哈希：h(k) &#x3D; floor(m*(A<em>key%1))<br>3、全域哈希：ha,b(k) &#x3D; ((a</em>key+b)%p)%m   a,b &#x3D;1,2,..p-1<br>哈希表的应用：<br>python中的字典和集合都是使用和哈希表来实现的<br>文件的哈希值若是相同的，我们就认为这两个文件是相同的，因此用户可以通过md5来验证文件是否完整，云存储服务商可以利用它来判断用户<br>要上传的文件，是否已经存在相同服务器上，从而实现秒传功能同时避免存储过的相同的副本</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line">class LinkList:</span><br><span class="line">    class Node:</span><br><span class="line">        def __init__(self, item=None):</span><br><span class="line">            self.item = item</span><br><span class="line">            self.next = None</span><br><span class="line"></span><br><span class="line">    class LinkListIterator:</span><br><span class="line">        def __init__(self, node):</span><br><span class="line">            self.node = node</span><br><span class="line"></span><br><span class="line">        def __next__(self):</span><br><span class="line">            if self.node:</span><br><span class="line">                cur_node = self.node</span><br><span class="line">                self.node = cur_node.next</span><br><span class="line">                return cur_node.item</span><br><span class="line">            else:</span><br><span class="line">                raise StopIteration</span><br><span class="line"></span><br><span class="line">        def __iter__(self):</span><br><span class="line">            return self</span><br><span class="line"></span><br><span class="line">    def __init__(self, iterable=None):</span><br><span class="line">        self.head = None</span><br><span class="line">        self.tail = None</span><br><span class="line">        if iterable:</span><br><span class="line">            self.extend(iterable)</span><br><span class="line"></span><br><span class="line">    def append(self, obj):</span><br><span class="line">        s = LinkList.Node(obj)</span><br><span class="line">        if not self.head:</span><br><span class="line">            self.head = s</span><br><span class="line">            self.tail = s</span><br><span class="line">        else:</span><br><span class="line">            self.tail.next = s</span><br><span class="line">            self.tail = s</span><br><span class="line"></span><br><span class="line">    def extend(self, iterable):</span><br><span class="line">        for obj in iterable:</span><br><span class="line">            self.append(obj)</span><br><span class="line"></span><br><span class="line">    def find(self, obj):</span><br><span class="line">        for n in self:</span><br><span class="line">            if n == obj:</span><br><span class="line">                return True</span><br><span class="line">        else:</span><br><span class="line">            return False</span><br><span class="line"></span><br><span class="line">    def __iter__(self):</span><br><span class="line">        return self.LinkListIterator(self.head)</span><br><span class="line"></span><br><span class="line">    def __repr__(self):</span><br><span class="line">        return &quot;&lt;&lt;&quot; + &quot;,&quot;.join(map(str, self)) + &quot;&gt;&gt;&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 类似于集合的结构</span><br><span class="line">class HashTable:</span><br><span class="line">    def __init__(self, size=101):</span><br><span class="line">        self.size = size</span><br><span class="line">        self.T = [LinkList() for i in range(self.size)]</span><br><span class="line"></span><br><span class="line">    def h(self, k):</span><br><span class="line">        return k % self.size</span><br><span class="line"></span><br><span class="line">    # 插入</span><br><span class="line">    def insert(self, k):</span><br><span class="line">        i = self.h(k)</span><br><span class="line">        if self.find(k):</span><br><span class="line">            print(f&quot;Duplicated Inserted:值:&#123;k&#125;重复插入了&quot;)</span><br><span class="line">        else:</span><br><span class="line">            self.T[i].append(k)</span><br><span class="line"></span><br><span class="line">    # 查找</span><br><span class="line">    def find(self, k):</span><br><span class="line">        i = self.h(k)</span><br><span class="line">        return self.T[i].find(k)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ht = HashTable()</span><br><span class="line">ht.insert(0)</span><br><span class="line">ht.insert(1)</span><br><span class="line">ht.insert(102)</span><br><span class="line">ht.insert(2)</span><br><span class="line">ht.insert(3)</span><br><span class="line">ht.insert(508)</span><br><span class="line">ht.insert(4)</span><br><span class="line">ht.insert(5)</span><br><span class="line">print(&quot;,&quot;.join(map(str, ht.T)))</span><br><span class="line">print(ht.find(102))</span><br><span class="line">print(ht.find(200))</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>经典迷宫问题</title>
      <link href="/2023/07/24/%E7%BB%8F%E5%85%B8%E8%BF%B7%E5%AE%AB%E9%97%AE%E9%A2%98/"/>
      <url>/2023/07/24/%E7%BB%8F%E5%85%B8%E8%BF%B7%E5%AE%AB%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="迷宫问题简单描述"><a href="#迷宫问题简单描述" class="headerlink" title="迷宫问题简单描述"></a>迷宫问题简单描述</h2><p>指定起点和终点，使用深度优先和广度优先两种搜索算法来完成从起点到终点的整个过程，迷宫中1表示墙0表示路<br>深度优先搜索是完成从起点到终点的任务无法解决最短路径问题、广度优先可以解决最短路径问题</p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">maze = [</span><br><span class="line">    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],</span><br><span class="line">    [1, 0, 0, 1, 0, 0, 0, 1, 0, 1],</span><br><span class="line">    [1, 0, 0, 1, 0, 0, 0, 1, 0, 1],</span><br><span class="line">    [1, 0, 0, 0, 0, 1, 1, 0, 0, 1],</span><br><span class="line">    [1, 0, 1, 1, 1, 0, 0, 0, 0, 1],</span><br><span class="line">    [1, 0, 0, 0, 1, 0, 0, 0, 0, 1],</span><br><span class="line">    [1, 0, 1, 0, 0, 0, 1, 0, 0, 1],</span><br><span class="line">    [1, 0, 1, 1, 1, 0, 1, 1, 0, 1],</span><br><span class="line">    [1, 1, 0, 0, 0, 0, 0, 0, 0, 1],</span><br><span class="line">    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"># 表示上下左右</span><br><span class="line">dirs = [</span><br><span class="line">    lambda x, y: (x + 1, y),</span><br><span class="line">    lambda x, y: (x - 1, y),</span><br><span class="line">    lambda x, y: (x, y - 1),</span><br><span class="line">    lambda x, y: (x, y + 1),</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h2 id="深度优先py代码实现"><a href="#深度优先py代码实现" class="headerlink" title="深度优先py代码实现"></a>深度优先py代码实现</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">def maze_path_depth(x1, y1, x2, y2):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    深度优先搜索-代码简单但是路径不能保证是最短</span><br><span class="line">    :param x1:起点位置</span><br><span class="line">    :param y1: 起点位置</span><br><span class="line">    :param x2: 终点位置</span><br><span class="line">    :param y2: 终点位置</span><br><span class="line">    :return:</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    stack = []</span><br><span class="line">    stack.append((x1, y1))</span><br><span class="line">    while (len(stack) &gt; 0):</span><br><span class="line">        curNode = stack[-1]  # 当前节点</span><br><span class="line">        if curNode[0] == x2 and curNode[1] == y2:</span><br><span class="line">            # 走到终点了</span><br><span class="line">            for p in stack:</span><br><span class="line">                print(p, end=&quot;-&gt;&quot;)</span><br><span class="line">            return True</span><br><span class="line">        # x，y表示四个方向，上下左右分别是 x-1,y x+1,y x,y-1 x,y+1</span><br><span class="line">        for dir in dirs:</span><br><span class="line">            nextNode = dir(curNode[0], curNode[1])</span><br><span class="line">            # 如果下一个节点能走 就入栈</span><br><span class="line">            if maze[nextNode[0]][nextNode[1]] == 0:</span><br><span class="line">                stack.append(nextNode)</span><br><span class="line">                maze[nextNode[0]][nextNode[1]] = 2  # 2表示已经走过</span><br><span class="line">                break</span><br><span class="line">        else:</span><br><span class="line">            maze[nextNode[0]][nextNode[1]] = 2  # 2表示已经走过</span><br><span class="line">            stack.pop()</span><br><span class="line">    else:</span><br><span class="line">        print(&quot;没有路&quot;)</span><br><span class="line">        return False</span><br></pre></td></tr></table></figure><h2 id="广度优先py代码实现"><a href="#广度优先py代码实现" class="headerlink" title="广度优先py代码实现"></a>广度优先py代码实现</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">from collections import deque</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def print_r(path):</span><br><span class="line">    curNode = path[-1]</span><br><span class="line">    realpath = []</span><br><span class="line">    while curNode[2] != -1:</span><br><span class="line">        realpath.append(curNode[0:2])</span><br><span class="line">        curNode = path[curNode[2]]</span><br><span class="line">    realpath.append(curNode[0:2])  # 把起点放入path</span><br><span class="line">    realpath.reverse()</span><br><span class="line">    for node in realpath:</span><br><span class="line">        print(node, end=&quot;-&gt;&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def maze_path_queue(x1, y1, x2, y2):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    广度优先搜索</span><br><span class="line">    :param x1:起点位置</span><br><span class="line">    :param y1: 起点位置</span><br><span class="line">    :param x2: 终点位置</span><br><span class="line">    :param y2: 终点位置</span><br><span class="line">    :return:</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    queue = deque()</span><br><span class="line">    queue.append((x1, y1, -1))</span><br><span class="line">    path = []</span><br><span class="line">    while len(queue) &gt; 0:</span><br><span class="line">        curNode = queue.popleft()</span><br><span class="line">        path.append(curNode)</span><br><span class="line">        if curNode[0] == x2 and curNode[1] == y2:</span><br><span class="line">            # 说明此时到达了终点</span><br><span class="line">            print_r(path)</span><br><span class="line">            return True</span><br><span class="line">        for dir in dirs:</span><br><span class="line">            nextNode = dir(curNode[0], curNode[1])</span><br><span class="line">            if maze[nextNode[0]][nextNode[1]] == 0:</span><br><span class="line">                queue.append((nextNode[0], nextNode[1], len(path) - 1))  # 后续节点进队，记录哪个节点带他来的</span><br><span class="line">                maze[nextNode[0]][nextNode[1]] = 2  # 标记为已经走过</span><br><span class="line">    else:</span><br><span class="line">        print(&quot;没有路&quot;)</span><br><span class="line">        return False</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>汉诺塔问题</title>
      <link href="/2023/07/24/%E6%B1%89%E8%AF%BA%E5%A1%94%E9%97%AE%E9%A2%98/"/>
      <url>/2023/07/24/%E6%B1%89%E8%AF%BA%E5%A1%94%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="汉诺塔问题简单描述："><a href="#汉诺塔问题简单描述：" class="headerlink" title="汉诺塔问题简单描述："></a>汉诺塔问题简单描述：</h2><p>问题规则：Hanoi(汉诺)塔问题。古代有一个焚塔，塔内有3个座A,B,C,开始时A座上有64个盘子，<br>盘子大小不等，大的在上，小的在下，有一个老和尚想把这64个盘子从A座移到C座，但规定每次只允许移到一个盘，<br>且在移动过程中在3个座上都始终保持大盘在下，小盘在上，在移动过程中可以利用B座。输出移动盘子的步骤。</p><h2 id="py代码实现"><a href="#py代码实现" class="headerlink" title="py代码实现"></a>py代码实现</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># hanoi函数的参数表示的是n个盘子从a经过b移动到c</span><br><span class="line">def hanoi(n, a, b, c):</span><br><span class="line">    if n &gt; 0:</span><br><span class="line">        hanoi(n - 1, a, c, b)</span><br><span class="line">        print(&quot;moving from %s to %s&quot; % (a, c))</span><br><span class="line">        hanoi(n - 1, b, a, c)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">hanoi(3, &quot;A&quot;, &quot;B&quot;, &quot;C&quot;)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排序算法补充</title>
      <link href="/2023/07/24/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E8%A1%A5%E5%85%85/"/>
      <url>/2023/07/24/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E8%A1%A5%E5%85%85/</url>
      
        <content type="html"><![CDATA[<h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><p>希尔排序是一种插入排序变种属于分组插入排序</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">def insert_sort_gap(li, gap):</span><br><span class="line">    for i in range(gap, len(li)):</span><br><span class="line">        tmp = li[i]</span><br><span class="line">        j = i - gap</span><br><span class="line">        while j &gt;= 0 and li[j] &gt; tmp:</span><br><span class="line">            li[j + gap] = li[j]</span><br><span class="line">            j -= gap</span><br><span class="line">        li[j + gap] = tmp</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def shell_sort(li):</span><br><span class="line">    d = len(li) // 2</span><br><span class="line">    while d &gt;= 1:</span><br><span class="line">        insert_sort_gap(li, d)</span><br><span class="line">        d //= 2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">li = list(range(1000))</span><br><span class="line">import random</span><br><span class="line"></span><br><span class="line">random.shuffle(li)</span><br><span class="line">print(li)</span><br><span class="line">shell_sort(li)</span><br><span class="line">print(li)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2><p>基数排序就是把数据从个位数往上按顺序入桶并且按顺序出桶  即可完成排序</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">def radix_sort(li):</span><br><span class="line">    max_num = max(li)</span><br><span class="line">    it = 0</span><br><span class="line">    while 10 ** it &lt;= max_num:</span><br><span class="line">        buckets = [[] for _ in range(10)]</span><br><span class="line">        for var in li:</span><br><span class="line">            digit = (var // 10 ** it) % 10</span><br><span class="line">            buckets[digit].append(var)</span><br><span class="line">        # 分桶完成</span><br><span class="line">        li.clear()</span><br><span class="line">        for buc in buckets:</span><br><span class="line">            li.extend(buc)</span><br><span class="line">        # 把数据重新写回li</span><br><span class="line">        it += 1</span><br><span class="line"></span><br><span class="line">import random</span><br><span class="line">li = list(range(1000))</span><br><span class="line">random.shuffle(li)</span><br><span class="line">print(li)</span><br><span class="line">radix_sort(li)</span><br><span class="line">print(li)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用算法学习</title>
      <link href="/2023/07/24/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"/>
      <url>/2023/07/24/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="查找算法"><a href="#查找算法" class="headerlink" title="查找算法"></a>查找算法</h2><h3 id="1-线性查找"><a href="#1-线性查找" class="headerlink" title="1.线性查找"></a>1.线性查找</h3><p>就是一个一个从前往后查找</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def line_search(list,val):</span><br><span class="line">    for i in range(len(li)):</span><br><span class="line">        if list[i] == val:</span><br><span class="line">            return  i</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2-二分查找、折半查找"><a href="#2-二分查找、折半查找" class="headerlink" title="2.二分查找、折半查找"></a>2.二分查找、折半查找</h3><p>前提是列表必须是有序的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"># 该函数的参数分别是有序列表和要查找的值</span><br><span class="line">def binnary_search(li, val):</span><br><span class="line">    left = 0</span><br><span class="line">    right = len(li) - 1</span><br><span class="line">    while left &lt;= right:</span><br><span class="line">        # 条件是要保证候选区有值</span><br><span class="line">        mid = (left + right) // 2</span><br><span class="line">        if li[mid] == val:</span><br><span class="line">            # 匹配成功 返回下标</span><br><span class="line">            return mid</span><br><span class="line">        elif li[mid] &lt;= val:</span><br><span class="line">            # 中间值小于等于val说明候选区在mid右边</span><br><span class="line">            left = mid + 1</span><br><span class="line">        else:</span><br><span class="line">            # 中间值大于等于val说明候选区在mid的左边</span><br><span class="line">            right = mid - 1</span><br><span class="line">    else:</span><br><span class="line">        # 没找到</span><br><span class="line">        return None</span><br><span class="line"></span><br><span class="line">list = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</span><br><span class="line">print(f&quot;查找数据所在下标为：&#123;binnary_search(list, 2)&#125;&quot;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>python的内置查找函数index就是使用的线性查找，二分查找虽然但是有有序前提</p><h2 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h2><h3 id="1-冒泡排序"><a href="#1-冒泡排序" class="headerlink" title="1.冒泡排序"></a>1.冒泡排序</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">import random</span><br><span class="line">def bubble_sort(li):</span><br><span class="line">    for i in range(len(li)):</span><br><span class="line">        for j in range(len(li) - i - 1):</span><br><span class="line">            if li[j] &gt; li[j + 1]:</span><br><span class="line">                # 调换位置 把值大的冒出去 升序排列(把if判断条件改为小于即为降序排列)</span><br><span class="line">                li[j], li[j + 1] = li[j + 1], li[j]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 冒泡排序优化 如果在一次排序中没有顺序移动 说明之后‘未排序’的数已经做好了排序 因此就不需要再做之后的冒泡 直接返回结果即可</span><br><span class="line">def bubble_sort_plus(li):</span><br><span class="line">    for i in range(len(li)):</span><br><span class="line">        exchange = False</span><br><span class="line">        for j in range(len(li) - i - 1):</span><br><span class="line">            if li[j] &gt; li[j + 1]:</span><br><span class="line">                # 调换位置 把值大的冒出去 升序排列(把if判断条件改为小于即为降序排列)</span><br><span class="line">                li[j], li[j + 1] = li[j + 1], li[j]</span><br><span class="line">                exchange = True</span><br><span class="line">        if exchange is False:</span><br><span class="line">            return</span><br><span class="line">        # 列表生成式 生成一个长度为100的每一项为0-1000之间的数的列表</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">li = [random.randint(0, 1000) for i in range(100)]</span><br><span class="line">print(li)</span><br><span class="line">bubble_sort(li)</span><br><span class="line">print(li)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2-选择排序"><a href="#2-选择排序" class="headerlink" title="2.选择排序:"></a>2.选择排序:</h3><p>选择排序是要在无序区遍历拿到最小的数 然后跟之前所记录的最小的数做交换<br>注意：有序区、无序区、无序区最小数的位置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">def search_sort(li):</span><br><span class="line">    for i in range(len(li) - 1):</span><br><span class="line">        min_loc = i</span><br><span class="line">        for j in range(i + 1, len(li)):</span><br><span class="line">            if li[j] &lt; li[min_loc]:</span><br><span class="line">                min_loc = j</span><br><span class="line">        li[i], li[min_loc] = li[min_loc], li[i]</span><br><span class="line">        print(li)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">li = [1, 4, 2, 3, 6, 9, 7]</span><br><span class="line">print(li)</span><br><span class="line">search_sort(li)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3-插入排序"><a href="#3-插入排序" class="headerlink" title="3.插入排序"></a>3.插入排序</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">def insert_sort(li):</span><br><span class="line">    for i in range(1, len(li)):  # i表示摸到牌的下标</span><br><span class="line">        temp = li[i]</span><br><span class="line">        j = i - 1  # j是手里的牌的下标</span><br><span class="line">        if j &gt;= 0 and li[j] &gt; temp:</span><br><span class="line">            li[j + 1] = li[j]</span><br><span class="line">            j -= 1</span><br><span class="line">        li[j+1] = temp</span><br><span class="line">        print(li)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">li = [1, 4, 2, 3, 6, 9, 5]</span><br><span class="line">print(li)</span><br><span class="line">insert_sort(li)</span><br></pre></td></tr></table></figure><h3 id="4-快速排序"><a href="#4-快速排序" class="headerlink" title="4.快速排序"></a>4.快速排序</h3><p>快速排序的思路就是递归的让列表中的一个数据被放列表的合适的位置<br>一次归位要保证归位的这个数一定能到达准确的位置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"># 归位函数</span><br><span class="line">def partition(li, left, right):</span><br><span class="line">    tmp = li[left]</span><br><span class="line">    while left &lt; right:</span><br><span class="line">        while left &lt; right and li[right] &gt;= tmp:  # 在右边找比tmp小的数 进行移动</span><br><span class="line">            right -= 1  # 往左走一步</span><br><span class="line">        li[left] = li[right]  # 把右边的值写到左边空位置上</span><br><span class="line">        while left &lt; right and li[left] &lt;= tmp:  # 在左边找比tmp大的数 进行移动</span><br><span class="line">            left += 1  # 往右走一步</span><br><span class="line">        li[right] = li[left]  # 把左边的值写到右边空位上</span><br><span class="line">    li[left] = tmp  # 把tmp归位</span><br><span class="line">    return left</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 递归调用实现快速排序</span><br><span class="line">def quick_sort(li, left, right):</span><br><span class="line">    if left &lt; right:</span><br><span class="line">        mid = partition(li, left, right)  # 获取中间值</span><br><span class="line">        quick_sort(li, left, mid - 1)  # 递归左边</span><br><span class="line">        quick_sort(li, mid + 1, right)  # 递归右边</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">li = [5, 6, 3, 7, 1, 9, 8]</span><br><span class="line">quick_sort(li, 0, len(li)-1)</span><br><span class="line">print(li)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="5-堆排序"><a href="#5-堆排序" class="headerlink" title="5.堆排序"></a>5.堆排序</h3><p>学了半天python版的堆排序看不懂代码<br>于是在网上找了个能看得懂的c代码将其转换成了python代码 正常运行<br>整体思路就是先把list列表通过堆维护的性质将其建成堆、然后在排序的过程中一边交换堆顶元素和堆底元素的值同时再调用堆的维护函数保证大顶堆</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">def heapify(li, n, i):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    维护堆函数</span><br><span class="line">    :param li:待维护列表</span><br><span class="line">    :param n: 待维护列表的长度</span><br><span class="line">    :param i: 待维护节点的下标</span><br><span class="line">    :return:</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    # 父节点、左孩子、右孩子</span><br><span class="line">    largest = i</span><br><span class="line">    lson = i * 2 + 1</span><br><span class="line">    rson = i * 2 + 2</span><br><span class="line">    if lson &lt; n and li[largest] &lt; li[lson]:</span><br><span class="line">        largest = lson</span><br><span class="line">    if rson &lt; n and li[largest] &lt; li[rson]:</span><br><span class="line">        largest = rson</span><br><span class="line">    # 最开始定义的父节点等于i、如果父节点的不等于i、说明此时该交换了</span><br><span class="line">    if largest is not i:</span><br><span class="line">        li[largest], li[i] = li[i], li[largest]</span><br><span class="line">        heapify(li, n, largest)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def heap_sort(li, n):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    堆排序：分为两步1、建堆2、排序</span><br><span class="line">    :param li: 待排序数列表</span><br><span class="line">    :param n: 长度</span><br><span class="line">    :return:</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    # 建堆</span><br><span class="line">    for i in range(n // 2 - 1, -1, -1):</span><br><span class="line">        heapify(li, n, i)</span><br><span class="line">    # 排序</span><br><span class="line">    for i in range(n - 1, -1, -1):</span><br><span class="line">        # 交换堆顶和堆底的元素</span><br><span class="line">        li[i], li[0] = li[0], li[i]</span><br><span class="line">        # 传入堆和剩余元素的数量与待维护节点下标</span><br><span class="line">        heapify(li, i, 0)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    list = [2, 3, 8, 1, 4, 7, 9, 10, 17, 5]</span><br><span class="line">    print(list)</span><br><span class="line">    heap_sort(list, len(list))</span><br><span class="line">    print(list)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="6-归并排序"><a href="#6-归并排序" class="headerlink" title="6.归并排序"></a>6.归并排序</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">def merge(li, low, high, mid):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    归并排序</span><br><span class="line">    :param li: 列表</span><br><span class="line">    :param low: 左边初始下标</span><br><span class="line">    :param high: 右边的初始下标</span><br><span class="line">    :param mid: 中间的初始下标</span><br><span class="line">    :return:</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    i = low</span><br><span class="line">    j = mid + 1</span><br><span class="line">    ltmp = []</span><br><span class="line">    while i &lt;= mid and j &lt;= high:</span><br><span class="line">        if li[i] &lt; li[j]:</span><br><span class="line">            ltmp.append(li[i])</span><br><span class="line">            i += 1</span><br><span class="line">        else:</span><br><span class="line">            ltmp.append(li[j])</span><br><span class="line">            j += 1</span><br><span class="line">    # while执行完，一定有一部分没数了</span><br><span class="line">    while i &lt;= mid:</span><br><span class="line">        ltmp.append(li[i])</span><br><span class="line">        i += 1</span><br><span class="line">    while j &lt;= high:</span><br><span class="line">        ltmp.append(li[j])</span><br><span class="line">        j += 1</span><br><span class="line">    li[low:high + 1] = ltmp</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def merge_sort(li, low, high):</span><br><span class="line">    if low &lt; high:  # 至少有两个元素递归</span><br><span class="line">        mid = (low + high) // 2</span><br><span class="line">        merge_sort(li, low, mid)</span><br><span class="line">        merge_sort(li, mid + 1, high)</span><br><span class="line">        merge(li, low, high, mid)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    list = [2, 3, 8, 1, 4, 7, 9, 10, 17, 5]</span><br><span class="line">    print(list)</span><br><span class="line">    merge_sort(list, 0, len(list)-1)</span><br><span class="line">    print(list)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="排序总结"><a href="#排序总结" class="headerlink" title="排序总结"></a>排序总结</h3><p>456这三种排序算法运行的速度相当快，时间复杂度都是O(nlogn)<br>一般情况下就运行的时间而言：快速排序&lt;归并排序&lt;堆排序<br>三种算法的优缺点：<br>快速排序：在极端情况下排序的效率特别低<br>归并排序：需要额外的内存开销<br>堆排序：在这三种排序中相对较慢</p><table><thead><tr><th>排序方法</th><th align="center">最坏情况</th><th align="center">时间复杂度(最坏情况)</th><th align="center">时间复杂度(最好情况)</th><th align="center">空间复杂度</th><th align="center">稳定性</th><th align="right">代码复杂度</th></tr></thead><tbody><tr><td>冒泡排序</td><td align="center">O(n&#96;2)</td><td align="center">O(n&#96;2)</td><td align="center">O(n)</td><td align="center">O(1)</td><td align="center">稳定</td><td align="right">稳定</td></tr><tr><td>选择排序</td><td align="center">O(n&#96;2)</td><td align="center">O(n&#96;2)</td><td align="center">O(n&#96;2)</td><td align="center">O(1)</td><td align="center">不稳定</td><td align="right">简单</td></tr><tr><td>插入排序</td><td align="center">O(n&#96;2)</td><td align="center">O(n&#96;2)</td><td align="center">O(n&#96;2)</td><td align="center">O(1)</td><td align="center">稳定</td><td align="right">简单</td></tr><tr><td>快速排序</td><td align="center">O(n&#96;2)</td><td align="center">O(nlogn)</td><td align="center">O(nlogn)</td><td align="center">好:O(logn)坏:O(n)</td><td align="center">不稳定</td><td align="right">较复杂</td></tr><tr><td>堆排序</td><td align="center">O(nlogn)</td><td align="center">O(nlogn)</td><td align="center">O(nlogn)</td><td align="center">O(1)</td><td align="center">不稳定</td><td align="right">复杂</td></tr><tr><td>归并排序</td><td align="center">O(nlogn)</td><td align="center">O(nlogn)</td><td align="center">O(nlogn)</td><td align="center">O(n)</td><td align="center">稳定</td><td align="right">较复杂</td></tr></tbody></table>]]></content>
      
      
      
        <tags>
            
            <tag> 算法学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>更新1</title>
      <link href="/2023/07/14/%E6%9B%B4%E6%96%B01/"/>
      <url>/2023/07/14/%E6%9B%B4%E6%96%B01/</url>
      
        <content type="html"><![CDATA[<h2 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h2><p>新增看板白色小咪、B站追番列表<del>(但是很久不在B站追)</del>、音乐播放器<del>(这玩意时怎么好时坏)</del></p>]]></content>
      
      
      
        <tags>
            
            <tag> 更新 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的第一篇博文</title>
      <link href="/2023/07/14/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E6%96%87/"/>
      <url>/2023/07/14/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E6%96%87/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>之前写的新建的hexo博客由于安装包依赖等一系列问题，因为博主能力有限导致束手无策，因此删掉了整个blog目录，重新创建学习记录。</p><h2 id="相关"><a href="#相关" class="headerlink" title="相关"></a>相关</h2><p>本博客使用hexo博客框架,主题是butterfly</p><h2 id="关于我为什么要创建这个blog"><a href="#关于我为什么要创建这个blog" class="headerlink" title="关于我为什么要创建这个blog"></a>关于我为什么要创建这个blog</h2><p>希望通过blog的形式记录生活或工作上的一些事情，旨在记录，用blog的形式，希望未来能为自己留下一段回忆，共勉！</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
