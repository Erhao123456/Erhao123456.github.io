<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>计算机网络学习总篇</title>
      <link href="/2023/09/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%AF%87/"/>
      <url>/2023/09/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<h2 id="1概述"><a href="#1概述" class="headerlink" title="1概述"></a>1概述</h2><h3 id="1-1网络的概念"><a href="#1-1网络的概念" class="headerlink" title="1.1网络的概念"></a>1.1网络的概念</h3><p>无论是交通网络还是通信网络都有的共同点就是连线和结点<br>网络的作用就是连通和共享</p><h3 id="1-2主机网络"><a href="#1-2主机网络" class="headerlink" title="1.2主机网络"></a>1.2主机网络</h3><p>网络发展早期就是主机和主机之间的网络<br>即以主机为中心(或者“主机-终端”)的网络<br>随计算机技术的发展而产生。早期的计算机均为大型机、中型机或者小型机器<br>用户通过终端连接到大型机(主机)上，通过批处理的方式共享主机上的软硬件资源<br>特征：以单处理机为中心的联机网络，集中式控制<br>缺点：主机负荷重、可靠性差</p><h3 id="1-3终端"><a href="#1-3终端" class="headerlink" title="1.3终端"></a>1.3终端</h3><p>终端是一个主机的远程输入&#x2F;输出设备(如手机、个人pc等)<br>个人计算机可以运行terminal(cmd窗口)来模拟一个终端的工作</p><h3 id="1-4局域网"><a href="#1-4局域网" class="headerlink" title="1.4局域网"></a>1.4局域网</h3><p>按地域划分、是指某一区域内多台计算机互联组成的计算机组<br>底层采用TCP&#x2F;IP协议实现了不同的计算机局域网互联的问题 也就是我们说的internet-因特网(网络的网络:把网络和网络连接在一起就是因特网)</p><h3 id="1-5Internet相关概念"><a href="#1-5Internet相关概念" class="headerlink" title="1.5Internet相关概念"></a>1.5Internet相关概念</h3><p>互连网：由路由器将网络连接起来、组成一个功能单一的‘虚拟网路’<br>互联网：当今世界最大的互联网络、由大规模的国家骨干网络、无数的区域网络和校园网络组成、采用IP协议栈<br>通俗的说，互联网就是采用IP协议用路由器把全球异构的网络连起来形成的一个网络，实现异构网络之间的互联互通<br>异构的网络：指的是采用不同的广域网和局域网</p><h3 id="1-6互联网的组成："><a href="#1-6互联网的组成：" class="headerlink" title="1.6互联网的组成："></a>1.6互联网的组成：</h3><p>边缘部分：由所有连接在互联网上的主机组成，这部分是用户直接使用的，用来进行通讯(传送数据、音频和视频)和资源共享<br>核心部分：有大量网络和连接这些网络的路由器组成，这部分是边缘部分提供服务的(提供连通性和交换)</p><h3 id="1-7互联网的通信"><a href="#1-7互联网的通信" class="headerlink" title="1.7互联网的通信"></a>1.7互联网的通信</h3><p>两种通信方式：客户服务器方式（C&#x2F;S方式）、对等方式（P2P方式）</p><h3 id="1-8分组交换"><a href="#1-8分组交换" class="headerlink" title="1.8分组交换"></a>1.8分组交换</h3><p>分组交换采用存储转发技术，发送端把较长的报文划分成较短的固定长度的数据段、每一个数据段前面添加上首部构成分组<br>每一个分组的首部都含有地址（目的地址和源地址）等控制信息、分左右交换网中的结点交换机根据收到的分组部分中的地址信息，把分组转换到下一个结点交换机：<br>每一个分组在互联网中独立的选择传输路径<br>用这样的存储转发方式，最后分组就能到达目的地<br>假设分组在传输的过程中没有任何差错，在转发时也没有被丢弃，在接收端就会收到分组后褪去首部还原成报文，最后在接收端把收到的数据还原成原来的报文<br>优缺点：<br>优点：<br>高效：在传输过程中动态分配传输带宽，对通信链路是逐段占用的<br>灵活：为每一个分组独立的选择最合适的转发路由<br>迅速可靠：以分组作为单位，可以不先建立连接就能像其他主机发送分组<br>可靠：分布式多路由的分组交换网，使网络有很好的生存性<br>缺点：<br>时延：分组在各节点存储转发时需要排队，会造成一定的时延<br>开销：分组必须携带首部（控制信息）也造成了一定的开销<br>失序：当分组交换采用数据报服务时，可能出现失序、丢失或者重复分组</p><h3 id="1-9报文交换"><a href="#1-9报文交换" class="headerlink" title="1.9报文交换"></a>1.9报文交换</h3><p>基于存储转发原理的报文交换，每一个结点接收整个报文，然后整个报文一次发送完毕，一次一跳<br>优点：无需建立连接随时发送报文，不同时间一段一段的占用通信线路，通信线路的利用率高<br>缺点：报文交换的时延长，实时性差、只适合数字信号、报文长度没有限制，中间转发结点存储空间大</p><h3 id="1-10三种交换的比较"><a href="#1-10三种交换的比较" class="headerlink" title="1.10三种交换的比较"></a>1.10三种交换的比较</h3><p>如果要传送大量的数据并且传送时间远大于建立连接的时间则电报交换的传输效率较快<br>报文交换和分组交换不需要预先分配传输带宽，在传送突发数据时可以提高整个网络的信道利用率<br>由于一个分组的长度远小于整个报文的长度，因此分组交换比报文交换的时延小，同时也具有更好的灵活性</p><h3 id="1-11计算机网络分类"><a href="#1-11计算机网络分类" class="headerlink" title="1.11计算机网络分类"></a>1.11计算机网络分类</h3><p><img src="/../img/network_fenlei.png" alt="本地相对路径" title="计算机网络分类"></p><h3 id="1-12性能指标"><a href="#1-12性能指标" class="headerlink" title="1.12性能指标"></a>1.12性能指标</h3><p><strong>速率</strong> ：速率是指连接在计算机网络上的主机在数字信道上传送数据的速率。是计算机网络中最重要的一个性能指标。又称为数据率(data rate)或比特率(bit rate) ，速率的单位是bit&#x2F;s(比特每秒）<br><img src="/../img/network_speed.png" alt="本地相对路径" title="速率"><br><strong>带宽</strong> ：本意是指某个信号具有的频带宽度 信号的带宽是指该信号所包含的各种不同频率成分所占据的频率范围。一条通信链路，带宽越宽，所能传输的最高数据率也越高。<br><img src="/../img/network_daikuan.png" alt="本地相对路径" title="带宽"><br><strong>吞吐量</strong> ：吞吐量表示单位时间内通过某个网络（通信线路、接口）的实际的数据量。吞吐量受制于带宽或者网络的额定速率。例如：对于一个1Gbit&#x2F;s的以太网，意味着其额定速率为1Gbit&#x2F;s，那么这个数值也是该以太网的吞吐量的绝对上限值。</p><p><strong>时延</strong> ：时延(delay 或 latency)是指数据（一个报文或分组，甚至比特）从网络(或链路)的一端传送到另一端所需的时间。有时也称为延迟或迟延。时延包括：<strong>发送时延</strong> (主机或路由器发送数据帧所需要的时间)、<strong>传播时延</strong> (电磁波在信道中传播一定的距离需要花费的时间)、<strong>处理时延</strong> (主机或者路由器接受到分组时要花费一定的时间去处理)、<strong>排队时延</strong> (分组在网络传输时，进入路由器后要在输入队列中排队等待处理，路由器确定转发接口后，还要在输出队列中排队等待转发，这就是排队时延)</p><p><strong>时延带宽积</strong> :时延带宽积指传播时延*带宽，表示一条链路上传播的所有比特（以比特为单位）。</p><p><strong>往返时间RTT</strong> :往返时延 RTT (Round-Trip Time) 表示从发送端发送数据开始，到发送端收到来自接收端的确认（接收端收到数据后立即发送确认），总共经历的时延。</p><p><strong>利用率</strong> :信道利用率指出某信道有百分之几的时间是被利用的（有数据通过）。完全空闲的信道的利用率是零。<br>网络利用率则是全网络的信道利用率的加权平均值。<br>信道利用率并非越高越好，信道或网络的利用率过高会产生非常大的时延。</p><h3 id="1-13具有五层协议的体系结构"><a href="#1-13具有五层协议的体系结构" class="headerlink" title="1.13具有五层协议的体系结构"></a>1.13具有五层协议的体系结构</h3><p><img src="/../img/network_xieyi.png" alt="本地相对路径" title="具有五层协议的体系结构"><br><strong>OSI的体系协议</strong> 太过理论 实现起来太复杂 业内使用的还是 <strong>TCP&#x2F;IP的体系结构</strong><br>五层协议的具体作用:<br><img src="/../img/network_xieyi_jutizuoyong.png" alt="本地相对路径" title="五层协议的具体作用"><br>主机之间发送数据:<br><img src="/../img/network_zhuji_shujufasong.png" alt="本地相对路径" title="主机之间发送数据"></p><h2 id="2物理层"><a href="#2物理层" class="headerlink" title="2物理层"></a>2物理层</h2><h3 id="2-1物理层功能"><a href="#2-1物理层功能" class="headerlink" title="2.1物理层功能"></a>2.1物理层功能</h3><p>物理层的主要功能就是解决比特传输速率的问题，即为透明的传送比特流，关心的是点到点的问题<br>透明传输是指不管所传输的是什么样的比特组合都能够在链路上传输<br>要尽可能的屏蔽掉不同的传输媒体和通信手段的差异<br><img src="/../img/netwotk_physics.png" alt="本地相对路径" title="物理层的特性"><br> <strong>信号类型</strong> ：<br>铜缆：基于电平<br>光纤：基于光脉冲<br>无线：基于微波</p><h3 id="2-2三种通信方式"><a href="#2-2三种通信方式" class="headerlink" title="2.2三种通信方式"></a>2.2三种通信方式</h3><p> <strong>单工通信</strong> ：只有一个方向上的通信而没有反方向的交互，比如电视、广播<br> <strong>半双工通信</strong> ：通信双方可以发送或者接收数据，但是不能同时发送和接收数据，比如对讲机<br> <strong>全双工通信</strong> ：通信双方可以同时发送和接收信息，比如电话</p><h3 id="2-3基带信号和调制"><a href="#2-3基带信号和调制" class="headerlink" title="2.3基带信号和调制"></a>2.3基带信号和调制</h3><p>基带信号是指信源发出的没有经过调制的原始信号（直接表达了要传输的信息的信号）<br>基带信号往往包含了较多的低频成分甚至直流成分，而许多的信道并不能直接传输这种低频分量或者直流分量，因此必须对基带信号进行调制<br>由模拟信号源产生的信号成为 <strong>模拟基带信号</strong> （说话的声波）<br>由计算机产生的二进制信号一般称为 <strong>数字基带信号</strong><br>没有特别声明的话，一般指的基带信号就是数字基带信号</p><h3 id="2-4基带传输和宽带传输"><a href="#2-4基带传输和宽带传输" class="headerlink" title="2.4基带传输和宽带传输"></a>2.4基带传输和宽带传输</h3><p> <strong>基带传输</strong> ：将基带信号（0和1用两种不同的电压表示：编码）直接送到数字信道上的传输方式、传输的是基带信号：适合近距离传输<br> <strong>宽带传输</strong> ：将基带信号经过调制（带通调制）后送到模拟信道上的传输方式，也称为频带传输、传输的是宽带信号（带通信号）：适合远距离传输<br> <strong>带通调试</strong> ：使用载波进行调试，把基带信号的频率范围搬移到较高频段，并转化为模拟信号，这样就能够在更好的模拟信道内进行传输(即仅在一段频率范围内能够通过信道)<br> <img src="/../img/network_bianma_tiaozhi.png" alt="本地相对路径" title="编码与调制"></p><h3 id="2-5几种编码方式"><a href="#2-5几种编码方式" class="headerlink" title="2.5几种编码方式"></a>2.5几种编码方式</h3><p> <strong>非归零编码（NRZ）</strong> ：正电平代表1，负电平代表0<br> <strong>归零编码</strong> ：正脉冲代表1，负脉冲代表0<br> <strong>曼彻斯特编码</strong> ：从高到低跳变表示1，从低到高跳变表示0，也可以反过来定义<br> <strong>差分曼彻斯特编码</strong> ：在每一位的中心处始终都有跳变，位开始边界有跳变代表0，而位开始边界没有跳变代表1<br> <img src="/../img/network_bianma_.png" alt="本地相对路径" title="几种编码方式"></p><h3 id="2-6码元"><a href="#2-6码元" class="headerlink" title="2.6码元"></a>2.6码元</h3><p>在使用时间域（或简称为时域）的波形表示数字信号时（固定时长的信号波形），代表不同离散数值的基本波形：<br>1码元可以携带多个比特的信息量<br>当码元的离散状态有M个时（M&gt;2）此时码元成为M进制码元<br> <img src="/../img/network_mayuan.png" alt="本地相对路径" title="码元"></p><h3 id="2-7信道复用技术"><a href="#2-7信道复用技术" class="headerlink" title="2.7信道复用技术"></a>2.7信道复用技术</h3><p> <strong>多路复用技术</strong> ：把多个信号组合在一条物理信道上进行传输，使得多个计算机或者终端设备共享信道资源，提高信道利用率，把一条广播信道 <strong>逻辑</strong> 上分为几条用于两个节点之间通信的 <strong>互不干扰</strong> 的信道，就是把广播信道转变为点对点信道<br> <strong>频分多路复用</strong><br><img src="/../img/network_duolufuyong_FDM.png" alt="本地相对路径" title="频分多路复用"><br> <strong>时分多路复用</strong>:由于计算机数据的突发性质，无法保证每个信道中每个时刻都有数据，使用时分复用系统传输数据，子信道的利用率一般是不是高的,由此引出了 <strong>统计时分复用</strong><br><img src="/../img/network_duolufuyong_TDM.png" alt="本地相对路径" title="时分多路复用"><br><img src="/../img/network_duolufuyong_STDM.png" alt="本地相对路径" title="统计时分多路复用"><br> <strong>波分复用</strong><br><img src="/../img/network_duolufuyong_WDM.png" alt="本地相对路径" title="波分复用"><br> <strong>码分复用</strong><br> 码片序列：每一个比特时间划分为m个短的间隔，被称为码片也叫码片序列<br> 每个站被指派唯一一个m 比特的码片序列<br> 如发送比特1，则发送自己的m比特码片序列<br> 如发送比特0，则发送该码片序列的二进制反码<br> 例如，s站的8bit码片序列是00011011<br> 发送比特1时就发送00011011<br> 发送比特0时就发送11100100<br> s站的码片序列就是（-1 -1 -1 +1 +1 -1 +1 +1）<br><img src="/../img/network_duolufuyong_CDM.png" alt="本地相对路径" title="码分复用"><br><img src="/../img/network_duolufuyong_CDM_.png" alt="本地相对路径" title="码分复用"></p><h2 id="3数据链路层"><a href="#3数据链路层" class="headerlink" title="3数据链路层"></a>3数据链路层</h2><h3 id="3-1数据链路层的信道类型"><a href="#3-1数据链路层的信道类型" class="headerlink" title="3.1数据链路层的信道类型"></a>3.1数据链路层的信道类型</h3><p> <strong>点对点信道</strong> :这种信道使用一对一的点对点通信方式，控制协议相对简单<br> <strong>广播信道</strong> :使用一对多的广播通信方式，通信过程比较 <strong>复杂</strong> 。广播信道上连接的主机很多，因此必须使用专用的 <strong>共享协议</strong> 来协调这些主机的数据发送，控制协议相对复杂</p><h3 id="3-2数据链路层的一些基本术语"><a href="#3-2数据链路层的一些基本术语" class="headerlink" title="3.2数据链路层的一些基本术语"></a>3.2数据链路层的一些基本术语</h3><p>数据链路层不必考虑物理层如何实现比特传输的细节，甚至可以更简单的设想好像是沿着两个数据链路层之间的水平方向把帧直接发送给对象<br> <strong>链路</strong> :结点间的物理通道。是一条无源的点到点的物理线路段（光纤、双绞线等），中间没有任何的其他交换结点。一条线路只是一条通路的一个组成部分。<br> <strong>数据链路</strong> :是结点间的逻辑通道。除了物理线路以外，还必须有通信协议来控制这些数据的传输，若把实现这些协议的硬件和软件加到链路上，就构成了数据链路，因此数据链路&#x3D;链路+协议<br> 链路中通信双方的信道使用形式不同，会有相应的不同的控制协议<br> <strong>数据链路的例子</strong> :城市交通&#x3D;街道+汽车交通规则 铁路交通&#x3D;铁轨+火车运行规则<br> <strong>帧</strong> :链路层协议数据单元，封装网络层的数据报<br> <strong>数据链路层</strong> :负责通过一条链路从一个结点向物理链路直接相连的相邻接点传送帧。<br> <strong>网卡</strong> 实现的物理层和数据链路层协议</p><h3 id="3-3数据链路层的三个基本功能"><a href="#3-3数据链路层的三个基本功能" class="headerlink" title="3.3数据链路层的三个基本功能"></a>3.3数据链路层的三个基本功能</h3><p> <strong>封装成帧</strong> :把若干比特打包成帧，便于检错和判断开始与帧结束 封装成帧就是在一段数据的前后分别添加首部和尾部，然后就构成了一个帧，首部和尾部的一个重要作用就是进行帧定界，确定帧的界限，帧的定界可以使用特殊的帧定界符，控制字符SOH放在帧的最前面表示帧的首部开始，控制字符EOT放在最后表示帧的结束<br> <strong>透明传输</strong> :成帧的标识可以作为数据传输 如果数据中正好也有‘SOH’ ‘EOT’的话就采用一种 <strong>字节填充</strong> （ <strong>字符填充</strong> ）的方法在‘SOH’或者‘EOT’的前面加上转义字符‘ESC’ 如果转义字符也在数据中那么就在转义字符前面在加一个转义字符表示一个‘ESC’<br> <strong>差错检测</strong> :检查帧的传输是否有比特错误 在传输过程中可能产生比特差错 1变成0 0变成1 就可以启动差错检测<br> <strong>CRC循环冗余检验</strong> ：模2运算 即异或运算 不同为1 相同为0 两0为0<br>可以实现：在物理层的基础上向网络层提供服务、加强物理层传输原始比特的功能、对网络层表现为一条无差错的链路、将可能出错的物理连接变为逻辑上无差错的数据链路<br><img src="/../img/network_shujulianlu_CRC.png" alt="本地相对路径" title="CRC冗余码的计算"></p><h3 id="3-4点对点协议PPP"><a href="#3-4点对点协议PPP" class="headerlink" title="3.4点对点协议PPP"></a>3.4点对点协议PPP</h3><p> PPP协议有 <strong>三个组成部分</strong> ：<br> 1 一个将IP数据报封装到串行链路的方法。PPP既支持异步链路，也支持同步链路。IP数据报就是PPP帧中的信息部分，长度受限于最大传送单元MTU的限制。<br> 2 一个用来建立、配置和测试数据链路连接的链路控制协议LCP。<br> 3 一套网络控制协议NCP，每一个协议支持一个网络层协议，如IP、AppleTalk等。</p><h3 id="3-5CSMA-CD协议"><a href="#3-5CSMA-CD协议" class="headerlink" title="3.5CSMA&#x2F;CD协议"></a>3.5CSMA&#x2F;CD协议</h3><p><img src="/../img/network_shujulianlu_CSMACD.png" alt="本地相对路径" title="CSMA/CD协议"></p><h2 id="4网络层"><a href="#4网络层" class="headerlink" title="4网络层"></a>4网络层</h2><h3 id="4-1虚电路服务与数据报服务的对比"><a href="#4-1虚电路服务与数据报服务的对比" class="headerlink" title="4.1虚电路服务与数据报服务的对比"></a>4.1虚电路服务与数据报服务的对比</h3><p><img src="/../img/network_wangluo_.png" alt="本地相对路径" title="虚电路服务与数据报服务的对比"></p><h3 id="4-2IP协议"><a href="#4-2IP协议" class="headerlink" title="4.2IP协议"></a>4.2IP协议</h3><p>包含两个方面：<br>IP头部信息。IP头部信息出现在每个IP数据报中，用于指定IP通信的源端IP地址、目的端IP地址，指导IP分片和重组，以及指定部分通信行为。<br>IP数据报的路由和转发。IP数据报的路由和转发发生在除目标机器之外的所有主机和路由器上。它们决定数据报是否应该转发以及如何转发。</p><p>IP协议是TCP&#x2F;IP协议族的动力，它为上层协议提供无状态、无连接、不可靠的服务。<br>无状态是指IP通信双方不同步传输数据的状态信息，因此所有IP数据报的发送、传输和接收都是相互独立、没有上下文关系的。这种服务最大的缺点就是无法处理乱序和重复的IP数据报。面向连接的协议，比如TCP协议，能够自己处理乱序的、重复的报文段，它递交给上层协议的内容绝对是有序的、正确的。无状态服务的优点也很明显：简单、高效。我们无需为保持通信的状态而分配一些内核资源，也无需每次传输数据时都携带状态信息。</p><p>无连接是指IP通信双方都不长久地维持对方的任何信息。这样上层协议每次发送数据的时候，都必须明确指定对方的IP地址。</p><p>不可靠是指IP协议不能保证IP数据报准确地到达接收端，它只是承诺尽最大努力。很多情况都可以导致IP数据报发送失败。比如，某个中转路由器发现IP数据报在网络上存活地时间太长，那么它将丢弃该报文，并返回一个ICMP错误消息给发送端。因此，使用IP服务地上层协议需要自己实现数据确认、超时重传等机制以达到可靠传输的目的。</p><h3 id="4-3IP地址"><a href="#4-3IP地址" class="headerlink" title="4.3IP地址"></a>4.3IP地址</h3><p><img src="/../img/network_wangluo_IP.png" alt="本地相对路径" title="IP地址"></p><h3 id="4-4八位二进制到十进制之间的转换"><a href="#4-4八位二进制到十进制之间的转换" class="headerlink" title="4.4八位二进制到十进制之间的转换"></a>4.4八位二进制到十进制之间的转换</h3><p><img src="/../img/network_wangluo_bin.png" alt="本地相对路径" title="八位二进制到十进制之间的转换"></p><h3 id="4-5一般不使用特殊的IP地址"><a href="#4-5一般不使用特殊的IP地址" class="headerlink" title="4.5一般不使用特殊的IP地址"></a>4.5一般不使用特殊的IP地址</h3><p><img src="/../img/network_wangluo_IP_.png" alt="本地相对路径" title="一般不使用的特殊IP地址"></p><h3 id="4-6默认的子网掩码"><a href="#4-6默认的子网掩码" class="headerlink" title="4.6默认的子网掩码"></a>4.6默认的子网掩码</h3><p><img src="/../img/network_wangluo_ziwangyanma.png" alt="本地相对路径" title="默认的子网掩码"><br>子网掩码是一个网络或者一个子网的重要属性<br>路由器在和相邻路由器交换路由信息时，必须把自己所在的网络或者子网的子网掩码告诉相邻路由器<br>路由器的路由表中的每一个项目，除了要给出目的网络地址外还必须同时给出该网络的子网掩码<br>若一个路由器连接在两个子网上就拥有了两个网络地址和两个子网掩码</p><h3 id="4-7怎么计算网路地址"><a href="#4-7怎么计算网路地址" class="headerlink" title="4.7怎么计算网路地址"></a>4.7怎么计算网路地址</h3><p><img src="/../img/network_wangluo_jisuan.png" alt="本地相对路径" title="计算网路地址"></p><h2 id="5运输层"><a href="#5运输层" class="headerlink" title="5运输层"></a>5运输层</h2><p>TCP协议（传输控制协议） TCP传送的数据单位是TCP报文段<br>UDP协议（用户数据报协议）UDP传送的数据单位是UDP报文或用户数据报</p><h2 id="6应用层"><a href="#6应用层" class="headerlink" title="6应用层"></a>6应用层</h2><h3 id="6-1域名空间"><a href="#6-1域名空间" class="headerlink" title="6.1域名空间"></a>6.1域名空间</h3><p><img src="/../img/network_app_yuming.png" alt="本地相对路径" title="域名空间"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>递归的应用</title>
      <link href="/2023/08/31/%E9%80%92%E5%BD%92%E7%9A%84%E5%BA%94%E7%94%A8/"/>
      <url>/2023/08/31/%E9%80%92%E5%BD%92%E7%9A%84%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="递归解决整数转换为任意进制"><a href="#递归解决整数转换为任意进制" class="headerlink" title="递归解决整数转换为任意进制"></a>递归解决整数转换为任意进制</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">def toStr(n, base):</span><br><span class="line">    convertString = &#x27;0123456789ABCDEF&#x27;</span><br><span class="line">    if n &lt; base:</span><br><span class="line">        # 最小规模</span><br><span class="line">        return convertString[n]</span><br><span class="line">    else:</span><br><span class="line">        return toStr(n // base, base) + convertString[n % base]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    print(toStr(1453, 16))  # 16进制</span><br><span class="line">    print(toStr(1453, 2))  # 2进制</span><br><span class="line">    print(toStr(1453, 8))  # 8进制</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>双端队列的应用</title>
      <link href="/2023/08/31/%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97%E7%9A%84%E5%BA%94%E7%94%A8/"/>
      <url>/2023/08/31/%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97%E7%9A%84%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="双端队列解决回文数问题"><a href="#双端队列解决回文数问题" class="headerlink" title="双端队列解决回文数问题"></a>双端队列解决回文数问题</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">from Deque import Deque</span><br><span class="line"># Deque是自定义的双端队列</span><br><span class="line"></span><br><span class="line">def palChecker(aString):</span><br><span class="line">    dq = Deque()</span><br><span class="line">    for ch in aString:</span><br><span class="line">        dq.addRear(ch)</span><br><span class="line">    stillEqual = True</span><br><span class="line">    while dq.size() &gt; 1 and stillEqual:</span><br><span class="line">        # 双端队列两边同时出队 然后判断是否一致 不一致就返回False</span><br><span class="line">        first = dq.removeFront()</span><br><span class="line">        last = dq.removeRear()</span><br><span class="line">        if first != last:</span><br><span class="line">            stillEqual = False</span><br><span class="line">    return stillEqual</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    print(palChecker(&#x27;reader&#x27;))</span><br><span class="line">    print(palChecker(&#x27;上海自来水来自海上&#x27;))</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>栈的应用</title>
      <link href="/2023/08/31/%E6%A0%88%E7%9A%84%E5%BA%94%E7%94%A8/"/>
      <url>/2023/08/31/%E6%A0%88%E7%9A%84%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="后缀表达式的求值"><a href="#后缀表达式的求值" class="headerlink" title="后缀表达式的求值"></a>后缀表达式的求值</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"># 栈的实现</span><br><span class="line">class Stack:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.items = []</span><br><span class="line"></span><br><span class="line">    def isEmpty(self):</span><br><span class="line">        return self.items == []</span><br><span class="line"></span><br><span class="line">    def push(self, item):</span><br><span class="line">        self.items.append(item)</span><br><span class="line"></span><br><span class="line">    def pop(self):</span><br><span class="line">        return self.items.pop()</span><br><span class="line"></span><br><span class="line">    def peek(self):</span><br><span class="line">        return self.items[len(self.items) - 1]</span><br><span class="line"></span><br><span class="line">    def size(self):</span><br><span class="line">        return len(self.items)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def postfixEval(postfixExpr):</span><br><span class="line">    s = Stack()</span><br><span class="line">    tokenlist = []</span><br><span class="line">    postfixExpr = str(postfixExpr)</span><br><span class="line">    for postfixExp in postfixExpr:</span><br><span class="line">        tokenlist.append(postfixExp)</span><br><span class="line">    print(tokenlist)</span><br><span class="line">    for token in tokenlist:</span><br><span class="line">        if token in &#x27;0123456789&#x27;:</span><br><span class="line">            s.push(int(token))</span><br><span class="line">        else:</span><br><span class="line">            operand2 = s.pop()</span><br><span class="line">            operand1 = s.pop()</span><br><span class="line">            result = doMath(token, operand1, operand2)</span><br><span class="line">            s.push(result)</span><br><span class="line">    return s.pop()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def doMath(op, op1, op2):</span><br><span class="line">    if op == &#x27;*&#x27;:</span><br><span class="line">        return op1 * op2</span><br><span class="line">    elif op == &#x27;/&#x27;:</span><br><span class="line">        return op1 / op2</span><br><span class="line">    elif op == &#x27;+&#x27;:</span><br><span class="line">        return op1 + op2</span><br><span class="line">    else:</span><br><span class="line">        return op1 - op2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    # 根据后缀表达式的运算规则 从前往后 *的优先级是最高的 因此 456*+的运算顺序是先算5*6 然后5*6的结果再+4</span><br><span class="line">    print(postfixEval(&#x27;456*+&#x27;))</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="简单的括号匹配"><a href="#简单的括号匹配" class="headerlink" title="简单的括号匹配"></a>简单的括号匹配</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"># 匹配函数</span><br><span class="line">def parChecker(symbolString):</span><br><span class="line">    s = Stack()</span><br><span class="line">    balanced = True</span><br><span class="line">    index = 0</span><br><span class="line">    while index &lt; len(symbolString) and balanced:</span><br><span class="line">        symbol = symbolString[index]</span><br><span class="line">        if symbol in &#x27;([&#123;&#x27;:</span><br><span class="line">            s.push(symbol)</span><br><span class="line">        else:</span><br><span class="line">            if s.isEmpty():</span><br><span class="line">                balanced = False</span><br><span class="line">            else:</span><br><span class="line">                top = s.pop()</span><br><span class="line">                if not matches(top, symbol):</span><br><span class="line">                    balanced = False</span><br><span class="line">        index += 1</span><br><span class="line">    if balanced and s.isEmpty():</span><br><span class="line">        return True</span><br><span class="line">    else:</span><br><span class="line">        return False</span><br><span class="line"></span><br><span class="line"># 利用位置来匹配成对的括号 位置一样说明是成对的 位置不一样说明不是成对的</span><br><span class="line">def matches(open, close):</span><br><span class="line">    opens = &quot;([&#123;&quot;</span><br><span class="line">    closers = &quot;)]&#125;&quot;</span><br><span class="line">    return opens.index(open) == closers.index(close)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    print(parChecker(&#x27;[&#123;&#125;()]&#x27;))</span><br><span class="line">    print(parChecker(&#x27;[&#123;&#125;(])&#x27;))</span><br><span class="line">    print(parChecker(&#x27;&#123;&#125;&#x27;))</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构-栈与队列</title>
      <link href="/2023/08/31/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/"/>
      <url>/2023/08/31/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h3 id="栈Stack"><a href="#栈Stack" class="headerlink" title="栈Stack"></a>栈Stack</h3><p>特点就是FILO 先进后出</p><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Stack:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.items = []</span><br><span class="line"></span><br><span class="line">    def isEmpty(self):</span><br><span class="line">        # 判空</span><br><span class="line">        return self.items == []</span><br><span class="line"></span><br><span class="line">    def push(self, item):</span><br><span class="line">        # 进栈</span><br><span class="line">        self.items.append(item)</span><br><span class="line"></span><br><span class="line">    def pop(self):</span><br><span class="line">        # 出栈</span><br><span class="line">        return self.items.pop()</span><br><span class="line"></span><br><span class="line">    def peek(self):</span><br><span class="line">        # 返回栈顶元素</span><br><span class="line">        return self.items[len(self.items) - 1]</span><br><span class="line"></span><br><span class="line">    def size(self):</span><br><span class="line">        # 栈的大小</span><br><span class="line">        return len(self.items)</span><br></pre></td></tr></table></figure><h3 id="队列Queue"><a href="#队列Queue" class="headerlink" title="队列Queue"></a>队列Queue</h3><p>特点是FIFO 先进先出</p><h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Queue:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.items = []</span><br><span class="line"></span><br><span class="line">    def isEmpty(self):</span><br><span class="line">        # 判空</span><br><span class="line">        return self.items == []</span><br><span class="line"></span><br><span class="line">    def enqueue(self, item):</span><br><span class="line">        # 进队 时间复杂度是O(n)</span><br><span class="line">        self.items.append(item)</span><br><span class="line"></span><br><span class="line">    def dequeue(self):</span><br><span class="line">        # 出队 时间复杂度是O(1)</span><br><span class="line">        return self.items[-1]</span><br><span class="line"></span><br><span class="line">    def size(self):</span><br><span class="line">        # 队列大小</span><br><span class="line">        return len(self.items)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="双端队列Deque"><a href="#双端队列Deque" class="headerlink" title="双端队列Deque"></a>双端队列Deque</h3><p>两端都是可进可出</p><h4 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">class Deque:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        # 初始化 list下标0作为deque的尾端 下标-1作为deque的首端</span><br><span class="line">        # 操作复杂度：addFront、removeFront是O(1) addRear、removeRear是O(N)</span><br><span class="line">        self.items = []</span><br><span class="line"></span><br><span class="line">    def isEmpty(self):</span><br><span class="line">        # 判空</span><br><span class="line">        return self.items == []</span><br><span class="line"></span><br><span class="line">    def addFront(self, item):</span><br><span class="line">        # 队首添加</span><br><span class="line">        self.items.append(item)</span><br><span class="line"></span><br><span class="line">    def addRear(self, item):</span><br><span class="line">        # 队尾添加</span><br><span class="line">        self.items.insert(0, item)</span><br><span class="line"></span><br><span class="line">    def removeFront(self):</span><br><span class="line">        # 首端出队</span><br><span class="line">        return self.items.pop()</span><br><span class="line"></span><br><span class="line">    def removeRear(self):</span><br><span class="line">        # 尾端出队</span><br><span class="line">        return self.items.pop(0)</span><br><span class="line"></span><br><span class="line">    def size(self):</span><br><span class="line">        # 大小</span><br><span class="line">        return len(self.items)</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日一题-删除有序数组中的重复项</title>
      <link href="/2023/08/29/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/"/>
      <url>/2023/08/29/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/</url>
      
        <content type="html"><![CDATA[<h3 id="题目简介"><a href="#题目简介" class="headerlink" title="题目简介"></a>题目简介</h3><p>给你一个 升序排列 的数组 nums<br>请你<strong>原地</strong>删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。元素的 相对顺序 应该保持 一致 。然后返回 nums 中唯一元素的个数。<br>考虑 nums 的唯一元素的数量为 k ，你需要做以下事情确保你的题解可以被通过：<br>更改数组 nums ，使 nums 的前 k 个元素包含唯一元素，并按照它们最初在 nums 中出现的顺序排列。nums 的其余元素与 nums 的大小不重要。<br>返回 k 。</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>使用双指针的方法解决<br>fast快指针用来寻找与前一项不同的两个相邻元素<br>slow慢指针用来标记可以覆盖的元素</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def removeDuplicates(self, nums):</span><br><span class="line">        if nums is []:</span><br><span class="line">            return 0</span><br><span class="line">        nums_len = len(nums)</span><br><span class="line">        fast = slow = 1</span><br><span class="line">        # 条件是快指针fast不越界</span><br><span class="line">        while fast &lt; nums_len:</span><br><span class="line">            # fast指针用来寻找不相等的两个相邻元素</span><br><span class="line">            # slow指针用来标记可以覆盖的元素</span><br><span class="line">            if nums[fast] != nums[fast - 1]:</span><br><span class="line">                nums[slow] = nums[fast]</span><br><span class="line">                slow += 1</span><br><span class="line">            fast += 1</span><br><span class="line">        print(nums[:slow])</span><br><span class="line">        return slow</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    s = Solution()</span><br><span class="line">    nums = [0, 0, 1, 1, 1, 2, 2, 3, 3, 4]</span><br><span class="line">    print(s.removeDuplicates(nums=nums))</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 力扣题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>查找最长公共前缀</title>
      <link href="/2023/08/24/%E6%9F%A5%E6%89%BE%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80/"/>
      <url>/2023/08/24/%E6%9F%A5%E6%89%BE%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80/</url>
      
        <content type="html"><![CDATA[<h3 id="问题简介"><a href="#问题简介" class="headerlink" title="问题简介"></a>问题简介</h3><p>编写一个函数来查找字符串数组中的最长公共前缀。<br>如果不存在公共前缀，返回空字符串 “”。<br>示例 1：<br>输入：strs &#x3D; [“flower”,”flow”,”flight”]<br>输出：”fl”<br>示例 2：<br>输入：strs &#x3D; [“dog”,”racecar”,”car”]<br>输出：””<br>解释：输入不存在公共前缀。</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><h4 id="横向扫描"><a href="#横向扫描" class="headerlink" title="横向扫描"></a>横向扫描</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution(object):</span><br><span class="line">    def longestCommonPrefix1(self, strs):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        横向扫描 字符串两两对比获得最长公共子序列</span><br><span class="line">        :type strs: List[str]</span><br><span class="line">        :rtype: str</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        if not strs:</span><br><span class="line">            return &quot;&quot;</span><br><span class="line"></span><br><span class="line">        prefix, count = strs[0], len(strs)</span><br><span class="line">        for i in range(1, count):</span><br><span class="line">            prefix = self.lcp(prefix, strs[i])</span><br><span class="line">            if not prefix:</span><br><span class="line">                break</span><br><span class="line">        return prefix</span><br><span class="line">    def lcp(self, str1, str2):</span><br><span class="line">        length, index = min(len(str1), len(str2)), 0</span><br><span class="line">        while index &lt; length and str1[index] == str2[index]:</span><br><span class="line">            index += 1</span><br><span class="line">        return str1[:index]</span><br></pre></td></tr></table></figure><h4 id="纵向扫描"><a href="#纵向扫描" class="headerlink" title="纵向扫描"></a>纵向扫描</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution(object):</span><br><span class="line">    def longestCommonPrefix2(self, strs):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        纵向扫描 一次性对比所有的字符串</span><br><span class="line">        :type strs: List[str]</span><br><span class="line">        :rtype: str</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        if not strs:</span><br><span class="line">            return &quot;&quot;</span><br><span class="line">        length, count = len(strs[0]), len(strs)</span><br><span class="line">        for i in range(count):</span><br><span class="line">            c = strs[0][i]</span><br><span class="line">            # Python 内置的 any(x) 函数接受一个可迭代的元素 x 作为参数，</span><br><span class="line">            # 如 list、元组或字典。如果在iterable中至少有一个元素使用隐式布尔转换计算为True，它返回True，否则返回False</span><br><span class="line">            # 如果iterable是空的，例如，any([])，它返回False，因为任何元素都不满足条件。</span><br><span class="line">            if any(i == len(strs[j]) or strs[j][i] != c for j in range(1, count)):</span><br><span class="line">                return strs[0][:i]</span><br><span class="line">        return strs[0]</span><br></pre></td></tr></table></figure><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    s = Solution()</span><br><span class="line">    str = [&quot;flower&quot;, &quot;flow&quot;, &quot;flight&quot;]</span><br><span class="line">    print(s.longestCommonPrefix1(str))</span><br><span class="line">    print(s.longestCommonPrefix2(str))</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 力扣题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>回文数的判断方法</title>
      <link href="/2023/08/23/%E5%9B%9E%E6%96%87%E6%95%B0%E7%9A%84%E5%88%A4%E6%96%AD%E6%96%B9%E6%B3%95/"/>
      <url>/2023/08/23/%E5%9B%9E%E6%96%87%E6%95%B0%E7%9A%84%E5%88%A4%E6%96%AD%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="判断回文数-有很多方法-记录几种方法如下"><a href="#判断回文数-有很多方法-记录几种方法如下" class="headerlink" title="判断回文数 有很多方法 记录几种方法如下"></a>判断回文数 有很多方法 记录几种方法如下</h2><h3 id="方法1"><a href="#方法1" class="headerlink" title="方法1"></a>方法1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def judge1(data):</span><br><span class="line">    data = str(data)</span><br><span class="line">    if data == &#x27;&#x27;.join(reversed(data)):</span><br><span class="line">        return True</span><br><span class="line">    else:</span><br><span class="line">        return False</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="方法2"><a href="#方法2" class="headerlink" title="方法2"></a>方法2</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def judge2(data):</span><br><span class="line">    data = str(data)</span><br><span class="line">    if data == data[::-1]:</span><br><span class="line">        return True</span><br><span class="line">    else:</span><br><span class="line">        return False</span><br></pre></td></tr></table></figure><h3 id="方法3"><a href="#方法3" class="headerlink" title="方法3"></a>方法3</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">def judge3(data):</span><br><span class="line">    # judge1和2都是利用str类型做判断 judge3使用的是整形</span><br><span class="line">    help = 1</span><br><span class="line">    # 生成一个辅助变量help 跟data的位数一致</span><br><span class="line">    while (data / help &gt;= 10):</span><br><span class="line">        help *= 10</span><br><span class="line">    print(help)</span><br><span class="line">    while (data != 0):</span><br><span class="line">        # 对比每一位是否相等</span><br><span class="line">        if (data // help != data % 10):</span><br><span class="line">            return False</span><br><span class="line">        # 调整data和help的位数</span><br><span class="line">        data = (data % help) // 10</span><br><span class="line">        help //= 100</span><br><span class="line">        print(data)</span><br><span class="line">        print(help)</span><br><span class="line">    return True</span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    data = 123321</span><br><span class="line">    if judge3(data):</span><br><span class="line">        print(f&quot;&#123;data&#125;是回文数&quot;)</span><br><span class="line">    else:</span><br><span class="line">        print(f&#x27;&#123;data&#125;不是回文数&#x27;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日一题-超级回文数</title>
      <link href="/2023/08/23/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-%E8%B6%85%E7%BA%A7%E5%9B%9E%E6%96%87%E6%95%B0/"/>
      <url>/2023/08/23/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-%E8%B6%85%E7%BA%A7%E5%9B%9E%E6%96%87%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="题目简介"><a href="#题目简介" class="headerlink" title="题目简介"></a>题目简介</h3><p>如果一个正整数自身是一个回文数，而且他也是一个回文数的平方，那么我们称这个数为超级回文数<br>现在我们给定义两个正整数L和R（字符串形式表示）返回包含在范围[L,R]中的超级回文数的数目<br>回文数就是从左往右和从右往左的顺序一致的整数例如121 232<br>实例:<br>输入L&#x3D;’4’R&#x3D;’1000’<br>输出 4<br>解释：4，9,121以及484是超级回文数 要注意的是676不是超级回文数 26*26 &#x3D; 676 但是26不是回文数</p><h3 id="函数解释"><a href="#函数解释" class="headerlink" title="函数解释"></a>函数解释</h3><pre><code>减小问题的规模 提高计算效率 修改最大限制 题目要求的是R小于10的18次方 运算量太大经过分析可以得知 如果把R先开方再对半除就能得到最大限制limit是10的5次方从0开始使用函数palindrome_number_make去创建回文数再平方该回文数传参给函数palindrome_number_judge判断是不是回文数再判断生成的回文数的平方是不是在题目所给的范围内，如果满足以上要求那么就是超级回文数让result加1最后将结果返回</code></pre><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">def palindrome_number_judge(data):</span><br><span class="line">    # 判断传入的data是不是回文数</span><br><span class="line">    data = str(data)</span><br><span class="line">    if data == data[::-1]:</span><br><span class="line">        return True</span><br><span class="line">    else:</span><br><span class="line">        return False</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def palindrome_number_make(data):</span><br><span class="line">    # 加工回文数生成 一个data生成两个回文数分别是奇数长度回文数和偶数长度回文数</span><br><span class="line">    # 比如data = 1，然后加工出的回文数是11和1</span><br><span class="line">    # data是123，加工出的回文数是123321和12321</span><br><span class="line">    if data &gt;= 10:</span><br><span class="line">        data = str(data)</span><br><span class="line">        data_1 = data + data[::-1]</span><br><span class="line">        data_2 = data + data[-2::-1]</span><br><span class="line">    else:</span><br><span class="line">        data = str(data)</span><br><span class="line">        data_1 = data</span><br><span class="line">        data_2 = data + data[::-1]</span><br><span class="line">    data_1 = int(data_1)</span><br><span class="line">    data_2 = int(data_2)</span><br><span class="line">    return data_1, data_2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def reduce_que_size(L, R):</span><br><span class="line"></span><br><span class="line">    limit = 100000</span><br><span class="line">    result = 0</span><br><span class="line">    for data in range(limit):</span><br><span class="line">        data_1, data_2 = palindrome_number_make(data)</span><br><span class="line">        if data_1 ** 2 &gt; R:</span><br><span class="line">            break</span><br><span class="line">        if palindrome_number_judge(data_1 * data_1) and L &lt;= data_1 ** 2:</span><br><span class="line">            result += 1</span><br><span class="line"></span><br><span class="line">    for data in range(limit):</span><br><span class="line">        data_1, data_2 = palindrome_number_make(data)</span><br><span class="line">        if data_2 ** 2 &gt; R:</span><br><span class="line">            break</span><br><span class="line">        if palindrome_number_judge(data_2 * data_2) and L &lt;= data_2 ** 2:</span><br><span class="line">            result += 1</span><br><span class="line">    return result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    print(reduce_que_size(1, 5))</span><br><span class="line">    print(palindrome_number_make(9))</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 力扣题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日一题-无线环绕字符串中寻找非空子串问题</title>
      <link href="/2023/08/22/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-%E6%97%A0%E7%BA%BF%E7%8E%AF%E7%BB%95%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E5%AF%BB%E6%89%BE%E9%9D%9E%E7%A9%BA%E5%AD%90%E4%B8%B2%E9%97%AE%E9%A2%98/"/>
      <url>/2023/08/22/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-%E6%97%A0%E7%BA%BF%E7%8E%AF%E7%BB%95%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E5%AF%BB%E6%89%BE%E9%9D%9E%E7%A9%BA%E5%AD%90%E4%B8%B2%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="题目简介"><a href="#题目简介" class="headerlink" title="题目简介"></a>题目简介</h3><p>无线环绕字符串寻找非空子串问题：假设有一个想象的字符串f：…a-z a-z a-z…这样循环，现有一字符串s，请找出字符串s中不重复的<br>非空的子串在想象串f中的不重复非空子串的个数</p><h3 id="解析："><a href="#解析：" class="headerlink" title="解析："></a>解析：</h3><p>将字符串s从左到右依次寻找，第一个以a结尾的子串在f中的个数是1是a，第二个以a结尾的子串在f中的个数是3分别是a za yza，可以看出第二个以a结尾的子串<br>在f中的个数包含了第一个以a结尾的子串，因此可以知道，以相同字母结尾的子串在f中的个数取最大值即可，所以以s串中的每一个字母结尾的子串在f中能找到的<br>个数分别是 a:1 b:2 y:1 z:2 a: 3 b :4,然后将数据整合放入dict中可以得到a:3 b:4 y:1 z:2，将每一个字母的value值加起来就是本题的解</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">def build_f():</span><br><span class="line">    # f串的构建</span><br><span class="line">    f = [chr(i) for i in range(97, 123)]</span><br><span class="line">    f = &quot;&quot;.join(f)</span><br><span class="line">    # 假设是3倍a-z</span><br><span class="line">    f = f * 3</span><br><span class="line">    return f</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def search_str(s):</span><br><span class="line">    # 搜索字符串方法</span><br><span class="line">    # 默认长度为1 str_len是前一个字符成长的长度</span><br><span class="line">    str_len = 1</span><br><span class="line">    str_dict = &#123;&#125;</span><br><span class="line">    for i in range(len(s)):</span><br><span class="line">        cur = s[i]  # 当前的字符串</span><br><span class="line">        pre = s[i - 1]  # 之前的字符串</span><br><span class="line">        if cur == &#x27;a&#x27; and pre == &#x27;z&#x27;:</span><br><span class="line">            str_len += 1</span><br><span class="line">        elif chr(ord(pre) + 1) == cur:</span><br><span class="line">            str_len += 1</span><br><span class="line">        else:</span><br><span class="line">            str_len = 1</span><br><span class="line">        # 将数据放入dict中</span><br><span class="line">        if str_dict.get(s[i]):</span><br><span class="line">            if str_len&gt;str_dict[s[i]]:</span><br><span class="line">                str_dict.update(&#123;s[i]: str_len&#125;)</span><br><span class="line">        else:</span><br><span class="line">            str_dict.update(&#123;s[i]: str_len&#125;)</span><br><span class="line"></span><br><span class="line">    return str_dict</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    # f = &#x27;...a-z a-z a-z...&#x27;</span><br><span class="line">    s = &#x27;abyzab&#x27;</span><br><span class="line">    # f串没用上 只是一个假设的串</span><br><span class="line">    f = build_f()</span><br><span class="line">    print(search_str(s))</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 力扣题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法进阶-动态规划</title>
      <link href="/2023/07/27/%E7%AE%97%E6%B3%95%E8%BF%9B%E9%98%B6-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
      <url>/2023/07/27/%E7%AE%97%E6%B3%95%E8%BF%9B%E9%98%B6-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
      
        <content type="html"><![CDATA[<h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>动态规划（英语：Dynamic programming，简称 DP），是一种在数学、管理科学、计算机科学、经济学和生物信息学中使用的，通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。动态规划常常适用于有重叠子问题和最优子结构性质的问题。<br>以上定义来自维基百科，看定义感觉还是有点抽象。简单来说，动态规划其实就是，给定一个问题，我们把它拆成一个个子问题，直到子问题可以直接解决。然后呢，把子问题答案保存起来，以减少重复计算。再根据子问题答案反推，得出原问题解的一种方法。<br>动态规划最核心的思想，就在于拆分子问题，记住过往，减少重复计算。<br>摘自：<a href="https://zhuanlan.zhihu.com/p/365698607">https://zhuanlan.zhihu.com/p/365698607</a></p><h3 id="斐波那契数列看动态规划"><a href="#斐波那契数列看动态规划" class="headerlink" title="斐波那契数列看动态规划"></a>斐波那契数列看动态规划</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">def fibnacci(n):</span><br><span class="line">    f = [0, 1, 1]</span><br><span class="line">    if n &gt; 2:</span><br><span class="line">        for i in range(n - 2):</span><br><span class="line">            num = f[-1] + f[-2]</span><br><span class="line">            f.append(num)</span><br><span class="line">    return f[n]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(fibnacci(100)) </span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法进阶 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法进阶-贪心算法</title>
      <link href="/2023/07/26/%E7%AE%97%E6%B3%95%E8%BF%9B%E9%98%B6-%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
      <url>/2023/07/26/%E7%AE%97%E6%B3%95%E8%BF%9B%E9%98%B6-%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h2><p>又称贪婪算法，是指在对问题求解时，总是做出在当前看来是最好的选择，也就是说，不从整体最优上加以考虑<br>贪心算法所做的是在某种意义上的局部最优解<br>贪心算法并不保证会得到最优解，但是在某些问题上贪心算法的解就是最优解。<br>要会判断一个问题是否能用贪心算法解决</p><h3 id="模拟商店找零问题"><a href="#模拟商店找零问题" class="headerlink" title="模拟商店找零问题"></a>模拟商店找零问题</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># change函数需要两个参数t是找零面值list，n是你输入的要找零金额</span><br><span class="line"># 找零的面值如下：</span><br><span class="line">t = [100, 50, 20, 5, 1]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def change(t, n):</span><br><span class="line">    m = [0 for _ in range(len(t))]</span><br><span class="line">    for i, money in enumerate(t):</span><br><span class="line">    # enumerate用来给t列表的每一项一个索引，默认从0开始，用在for循环中就是把索引值赋给i</span><br><span class="line">        m[i] = n // money</span><br><span class="line">        n = n % money</span><br><span class="line">    return m, n</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 打印366元的找零结果</span><br><span class="line">print(change(t, 376))</span><br></pre></td></tr></table></figure><h3 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h3><p>0-1背包：对于一个商品，要么拿走要么留下，不能拿走1部分<br>分数背包：对一个商品，可以拿走其中一部分<br>举例：v和w分别是价值和重量<br>商品1：v1&#x3D; 60 w1 &#x3D;10<br>商品2：v2 &#x3D; 100 w2 &#x3D; 20<br>商品3：v3 &#x3D; 120 w3 &#x3D; 30<br>背包容量 w&#x3D;50</p><h4 id="分数背包的实现"><a href="#分数背包的实现" class="headerlink" title="分数背包的实现"></a>分数背包的实现</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">goods = [(60, 10), (120, 30), (100, 20)]</span><br><span class="line"># 单位重量下更值钱的商品 降序排列</span><br><span class="line">goods.sort(key=lambda x: x[0] / x[1], reverse=True)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def fractional_bakcpack(goods, w):</span><br><span class="line">    m = [0 for _ in range(len(goods))]</span><br><span class="line">    total_v = 0</span><br><span class="line">    for i, (prize, weight) in enumerate(goods):</span><br><span class="line">        if w &gt;= weight:</span><br><span class="line">            m[i] = 1</span><br><span class="line">            total_v += prize</span><br><span class="line">            w -= weight</span><br><span class="line">        else:</span><br><span class="line">            m[i] = w / weight</span><br><span class="line">            total_v += m[i] * prize</span><br><span class="line">            w = 0</span><br><span class="line">            break</span><br><span class="line">    return total_v,m</span><br><span class="line"></span><br><span class="line">print(goods)</span><br><span class="line">print(fractional_bakcpack(goods, 50))</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="拼接最大数字问题"><a href="#拼接最大数字问题" class="headerlink" title="拼接最大数字问题"></a>拼接最大数字问题</h3><p>问题描述：<br>有n个非负整数，将其按照字符串拼接的方式拼接为一个整数，如何拼接可以使得到的的整数最大？<br>例如：32,94,128,1286,6,71 可以拼接的最大整数为94716321286128</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">from functools import cmp_to_key</span><br><span class="line">li = [32,94,128,1286,6,71]</span><br><span class="line">def xy_cmp(x,y):</span><br><span class="line">    if x+y &lt;y+x:</span><br><span class="line">        return 1</span><br><span class="line">    elif x+y&gt;y+x:</span><br><span class="line">        return -1</span><br><span class="line">    else:</span><br><span class="line">        return 0</span><br><span class="line"></span><br><span class="line">def number_join(li):</span><br><span class="line">    li = list(map(str,li))</span><br><span class="line">    li.sort(key=cmp_to_key(xy_cmp))</span><br><span class="line">    return &quot;&quot;.join(li)</span><br><span class="line"></span><br><span class="line">print(number_join(li))</span><br></pre></td></tr></table></figure><h3 id="活动选择问题"><a href="#活动选择问题" class="headerlink" title="活动选择问题"></a>活动选择问题</h3><p>问题概述：<br>假设有n个活动，这些活动要占用同一片场地，而场地在某个时刻只能供一个和活动使用。<br>每个活动都有一个开始时间si和结束时间fi（题目中时间以整数表示），表示活动在[si,fi)区间占用场地<br>问：安排哪些活动能够使改场地举办的活动个数最多？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">activities = [</span><br><span class="line">    (1, 4),</span><br><span class="line">    (3, 5),</span><br><span class="line">    (0, 6),</span><br><span class="line">    (5, 7),</span><br><span class="line">    (3, 9),</span><br><span class="line">    (5, 9),</span><br><span class="line">    (6, 10),</span><br><span class="line">    (8, 11),</span><br><span class="line">    (8, 12),</span><br><span class="line">    (2, 14),</span><br><span class="line">    (12, 16)</span><br><span class="line">]</span><br><span class="line"># 排序保证活动是按照结束时间排好序的</span><br><span class="line">activities.sort(key=lambda x: x[1])</span><br><span class="line">print(activities)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def activity_selection(a):</span><br><span class="line">    res = [a[0]]</span><br><span class="line">    for i in range(1, len(a)):</span><br><span class="line">        if a[i][0] &gt;= res[-1][1]:  # 当前活动开始时间小于等于最后一个入选活动的结束时间</span><br><span class="line">            # 不冲突</span><br><span class="line">            res.append(a[i])</span><br><span class="line">    return res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(activity_selection(activities))</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法进阶 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构-树与二叉树</title>
      <link href="/2023/07/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>/2023/07/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><p>树结构是一种包括节点(nodes)和边(edges)的拥有层级关系的一种结构， 它的形式和家谱树非常类似.<br>linux 文件结构（tree 命令），它的结构也是一棵树。<br>根节点(root): 树的最上层的节点，任何非空的树都有一个节点<br>路径(path): 从起始节点到终止节点经历过的边<br>父亲(parent)：除了根节点，每个节点的上一层边连接的节点就是它的父亲(节点)<br>孩子(children): 每个节点由边指向的下一层节点<br>兄弟(siblings): 同一个父亲并且处在同一层的节点<br>子树(subtree): 每个节点包含它所有的后代组成的子树<br>叶子节点(leaf node): 没有孩子的节点成为叶子节点</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">class Node:</span><br><span class="line">    # 链式存储的方式存储树</span><br><span class="line">    def __init__(self, name, type=&#x27;dir&#x27;):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.type = type</span><br><span class="line">        self.children = []</span><br><span class="line">        self.parent = None</span><br><span class="line"></span><br><span class="line">    def __repr__(self):</span><br><span class="line">        return self.name</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class FileSystemTree:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.root = Node(&quot;/&quot;)</span><br><span class="line">        self.now = self.root</span><br><span class="line"></span><br><span class="line">    def mkdir(self, name):</span><br><span class="line">        if name[-1] != &quot;/&quot;:</span><br><span class="line">            name += &quot;/&quot;</span><br><span class="line">        node = Node(name)</span><br><span class="line">        self.now.children.append(node)</span><br><span class="line">        node.parent = self.now</span><br><span class="line"></span><br><span class="line">    def ls(self):</span><br><span class="line">        return self.now.children</span><br><span class="line"></span><br><span class="line">    def cd(self, name):</span><br><span class="line">        if name[-1] != &quot;/&quot;:</span><br><span class="line">            name += &quot;/&quot;</span><br><span class="line">        if name == &quot;../&quot;:</span><br><span class="line">            self.now = self.now.parent</span><br><span class="line">            return</span><br><span class="line">        for child in self.now.children:</span><br><span class="line">            if child.name == name:</span><br><span class="line">                self.now = child</span><br><span class="line">                return</span><br><span class="line">        raise ValueError(&quot;invalid dir&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">tree = FileSystemTree()</span><br><span class="line">tree.mkdir(&quot;var/&quot;)</span><br><span class="line">tree.mkdir(&quot;bin/&quot;)</span><br><span class="line">tree.mkdir(&quot;usr/&quot;)</span><br><span class="line">print(tree.ls())</span><br><span class="line">tree.cd(&quot;bin/&quot;)</span><br><span class="line">tree.mkdir(&quot;pyhton/&quot;)</span><br><span class="line">print(tree.ls())</span><br><span class="line">tree.cd(&quot;../&quot;)</span><br><span class="line">print(tree.ls())</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><p>了解完树的结构以后，我们来看树结构里一种简单但是却比较常用的树-二叉树。<br>二叉树是一种简单的树，它的每个节点最多只能包含两个孩子.<br>通过上边这幅图再来看几个二叉树相关的概念:<br>节点深度(depth): 节点对应的 level 数字<br>树的高度(height): 二叉树的高度就是 level 数 + 1，因为 level 从 0开始计算的<br>树的宽度(width): 二叉树的宽度指的是包含最多节点的层级的节点数<br>树的 size：二叉树的节点总个数。</p><h3 id="满二叉树-full-binary-tree"><a href="#满二叉树-full-binary-tree" class="headerlink" title="满二叉树(full binary tree)"></a>满二叉树(full binary tree)</h3><p>如果每个内部节点（非叶节点）都包含两个孩子，就成为满二叉树。</p><h3 id="完美二叉树-perfect-binary-tree"><a href="#完美二叉树-perfect-binary-tree" class="headerlink" title="完美二叉树(perfect binary tree)"></a>完美二叉树(perfect binary tree)</h3><p>当所有的叶子节点都在同一层就是完美二叉树，毫无间隙填充了 h 层。</p><h3 id="完全二叉树-complete-binary-tree"><a href="#完全二叉树-complete-binary-tree" class="headerlink" title="完全二叉树(complete binary tree)"></a>完全二叉树(complete binary tree)</h3><p>当一个高度为 h 的完美二叉树减少到 h-1，并且最底层的槽被毫无间隙地从左到右填充，我们就叫它完全二叉树</p><h3 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h3><p>二叉树其实是一种递归结构，因为单独拿出来一个 subtree 子树出来，其实它还是一棵树。那遍历它就很方便啦，我们可以直接用递归的方式来遍历它。但是当处理顺序不同的时候，树又分为三种遍历方式:</p><p>先(根)序遍历: 先处理根，之后是左子树，然后是右子树<br>中(根)序遍历: 先处理左子树，之后是根，最后是右子树<br>后(根)序遍历: 先处理左子树，之后是右子树，最后是根</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">class BitreeNode:</span><br><span class="line">    def __init__(self, data):</span><br><span class="line">        self.data = data</span><br><span class="line">        self.lchild = None  # 左孩子</span><br><span class="line">        self.rchild = None  # 右孩子</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 手动创建二叉树创建节点</span><br><span class="line">a = BitreeNode(&quot;A&quot;)</span><br><span class="line">b = BitreeNode(&quot;B&quot;)</span><br><span class="line">c = BitreeNode(&quot;C&quot;)</span><br><span class="line">d = BitreeNode(&quot;D&quot;)</span><br><span class="line">e = BitreeNode(&quot;E&quot;)</span><br><span class="line">f = BitreeNode(&quot;F&quot;)</span><br><span class="line">g = BitreeNode(&quot;G&quot;)</span><br><span class="line"></span><br><span class="line">e.lchild = a</span><br><span class="line">e.rchild = g</span><br><span class="line">a.rchild = c</span><br><span class="line">c.lchild = b</span><br><span class="line">c.rchild = d</span><br><span class="line">g.rchild = f</span><br><span class="line"></span><br><span class="line">root = e</span><br><span class="line">print(root.lchild.rchild.data)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def pre_order(root):</span><br><span class="line">    # 前序遍历</span><br><span class="line">    if root:</span><br><span class="line">        print(root.data, end=&quot;,&quot;)</span><br><span class="line">        pre_order(root.lchild)</span><br><span class="line">        pre_order(root.rchild)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def in_order(root):</span><br><span class="line">    # 中序遍历</span><br><span class="line">    if root:</span><br><span class="line">        in_order(root.lchild)</span><br><span class="line">        print(root.data, end=&quot;,&quot;)</span><br><span class="line">        in_order(root.rchild)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def post_order(root):</span><br><span class="line">    # 后序遍历</span><br><span class="line">    if root:</span><br><span class="line">        post_order(root.lchild)</span><br><span class="line">        post_order(root.rchild)</span><br><span class="line">        print(root.data, end=&quot;,&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">from collections import deque</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def level_order(root):</span><br><span class="line">    # 层次遍历</span><br><span class="line">    queue = deque()</span><br><span class="line">    queue.append(root)</span><br><span class="line">    while len(queue) &gt; 0:</span><br><span class="line">        node = queue.popleft()</span><br><span class="line">        print(node.data, end=&#x27;,&#x27;)</span><br><span class="line">        if node.lchild:</span><br><span class="line">            queue.append(node.lchild)</span><br><span class="line">        if node.rchild:</span><br><span class="line">            queue.append(node.rchild)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pre_order(root)</span><br><span class="line">print()</span><br><span class="line">in_order(root)</span><br><span class="line">print()</span><br><span class="line">post_order(root)</span><br><span class="line">print()</span><br><span class="line">level_order(root)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h2><p>二叉搜索树是一个二叉树且满足在性质：<br>设x是二叉树的一个节点。如果y是x左子树的一个节点，那么y.key&lt;&#x3D;x.key;<br>如果y是x右子树的一个节点，那么y.key&gt;&#x3D;x.key<br>二叉搜索树的操作：查询、插入、删除</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br></pre></td><td class="code"><pre><span class="line">import random</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class BitreeNode:</span><br><span class="line">    def __init__(self, data):</span><br><span class="line">        self.data = data</span><br><span class="line">        self.lchild = None  # 左孩子</span><br><span class="line">        self.rchild = None  # 右孩子</span><br><span class="line">        self.parent = None  # 父节点</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class BST:</span><br><span class="line">    def __init__(self, li=None):</span><br><span class="line">        self.root = None</span><br><span class="line">        if li:</span><br><span class="line">            for val in li:</span><br><span class="line">                self.insert_norec(val)</span><br><span class="line"></span><br><span class="line">    def insert(self, node, val):</span><br><span class="line">        if not node:</span><br><span class="line">            node = BitreeNode(val)</span><br><span class="line">        elif val &lt; node.data:</span><br><span class="line">            node.lchild = self.insert(node.lchild, val)</span><br><span class="line">            node.lchild.parent = node</span><br><span class="line">        elif val &gt; node.data:</span><br><span class="line">            node.rchild = self.insert(node.rchild, val)</span><br><span class="line">            node.rchild.parent = node</span><br><span class="line">        else:</span><br><span class="line">            pass</span><br><span class="line">        return node</span><br><span class="line"></span><br><span class="line">    def insert_norec(self, val):</span><br><span class="line">        # 非递归插入</span><br><span class="line">        p = self.root</span><br><span class="line">        if not p:  # 空数</span><br><span class="line">            self.root = BitreeNode(val)</span><br><span class="line">            return</span><br><span class="line">        while True:</span><br><span class="line">            if val &lt; p.data:</span><br><span class="line">                if p.lchild:</span><br><span class="line">                    p = p.lchild</span><br><span class="line">                else:  # 左孩子不存在时</span><br><span class="line">                    p.lchild = BitreeNode(val)</span><br><span class="line">                    p.lchild.parent = p</span><br><span class="line">                    return</span><br><span class="line">            elif val &gt; p.data:</span><br><span class="line">                if p.rchild:</span><br><span class="line">                    p = p.rchild</span><br><span class="line">                else:</span><br><span class="line">                    p.rchild = BitreeNode(val)</span><br><span class="line">                    p.rchild.parent = p</span><br><span class="line">                    return</span><br><span class="line">            else:</span><br><span class="line">                return</span><br><span class="line"></span><br><span class="line">    def query(self, node, val):</span><br><span class="line">        # 查询</span><br><span class="line">        if not node:</span><br><span class="line">            return None</span><br><span class="line">        if node.data &lt; val:</span><br><span class="line">            return self.query(node.rchild, val)</span><br><span class="line">        elif node.data &gt; val:</span><br><span class="line">            return self.query(node.rchild, val)</span><br><span class="line">        else:</span><br><span class="line">            return node</span><br><span class="line"></span><br><span class="line">    def query_norec(self, val):</span><br><span class="line">        # 非递归查询</span><br><span class="line">        p = self.root</span><br><span class="line">        while p:</span><br><span class="line">            if p.data &lt; val:</span><br><span class="line">                p = p.rchild</span><br><span class="line">            elif p.data &gt; val:</span><br><span class="line">                p = p.lchild</span><br><span class="line">            else:</span><br><span class="line">                return p</span><br><span class="line">        else:</span><br><span class="line">            return None</span><br><span class="line"></span><br><span class="line">    def remove_node1(self, node):</span><br><span class="line">        # 删除的情况1 node是叶子节点没有孩子</span><br><span class="line">        if not node.parent:</span><br><span class="line">            # 判断是不是根节点</span><br><span class="line">            self.root = None</span><br><span class="line">        if node.parent == node.parent.lchild:</span><br><span class="line">            # node是父亲的左孩子</span><br><span class="line">            node.parent.lchild = None</span><br><span class="line">        else:</span><br><span class="line">            # node是父亲的右孩子</span><br><span class="line">            node.parent.rchild = None</span><br><span class="line"></span><br><span class="line">    def remove_node21(self, node):</span><br><span class="line">        # 删除的情况2.1 node只有一个左孩子</span><br><span class="line">        if not node.parent:</span><br><span class="line">            self.root = node.lchild</span><br><span class="line">            node.lchild.parent = None</span><br><span class="line">        elif node == node.parent.lchild:</span><br><span class="line">            node.parent.lchild = node.lchild</span><br><span class="line">            node.lchild.parent = node.parent</span><br><span class="line">        else:</span><br><span class="line">            node.parent.rchild = node.lchild</span><br><span class="line">            node.lchild.parent = node.parent</span><br><span class="line"></span><br><span class="line">    def remove_node22(self, node):</span><br><span class="line">        # 删除情况2.2 node只有一个右孩子</span><br><span class="line">        if not node.parent:</span><br><span class="line">            self.root = node.rchild</span><br><span class="line">            node.rchild.parent = None</span><br><span class="line">        elif node == node.parent.lchild:</span><br><span class="line">            node.parent.lchild = node.rchild</span><br><span class="line">            node.rchild.parent = node.parent</span><br><span class="line">        else:</span><br><span class="line">            node.parent.rchild = node.rchild</span><br><span class="line">            node.rchild.parent = node.parent</span><br><span class="line"></span><br><span class="line">    def delete(self, val):</span><br><span class="line">        if self.root:</span><br><span class="line">            # 不是空树再删除</span><br><span class="line">            node = self.query_norec(val)</span><br><span class="line">            if not node:</span><br><span class="line">                return False</span><br><span class="line">            # 存在node</span><br><span class="line">            if not node.lchild and not node.rchild:</span><br><span class="line">                # 情况1 没有左孩子也没有右孩子</span><br><span class="line">                self.remove_node1(node)</span><br><span class="line">            elif not node.rchild:</span><br><span class="line">                # 情况2.1只有一个左孩子</span><br><span class="line">                self.remove_node21(node)</span><br><span class="line">            elif not node.lchild:</span><br><span class="line">                # 情况2.2 只有一个右孩子</span><br><span class="line">                self.remove_node22(node)</span><br><span class="line">            else:</span><br><span class="line">                #  情况3 两个孩子都有</span><br><span class="line">                min_node = node.rchild  # min_node就是右子树里最小的节点</span><br><span class="line">                while min_node == min_node.lchild:</span><br><span class="line">                    min_node = min_node.lchild</span><br><span class="line">                node.data = min_node.data</span><br><span class="line">                # 删除min_node</span><br><span class="line">                if min_node.rchild:</span><br><span class="line">                    self.remove_node22(min_node)</span><br><span class="line">                else:</span><br><span class="line">                    self.remove_node1(min_node)</span><br><span class="line"></span><br><span class="line">    def pre_order(self, root):</span><br><span class="line">        # 前序遍历</span><br><span class="line">        if root:</span><br><span class="line">            print(root.data, end=&quot;,&quot;)</span><br><span class="line">            self.pre_order(root.lchild)</span><br><span class="line">            self.pre_order(root.rchild)</span><br><span class="line"></span><br><span class="line">    def in_order(self, root):</span><br><span class="line">        # 中序遍历</span><br><span class="line">        if root:</span><br><span class="line">            self.in_order(root.lchild)</span><br><span class="line">            print(root.data, end=&quot;,&quot;)</span><br><span class="line">            self.in_order(root.rchild)</span><br><span class="line"></span><br><span class="line">    def post_order(self, root):</span><br><span class="line">        # 后序遍历</span><br><span class="line">        if root:</span><br><span class="line">            self.post_order(root.lchild)</span><br><span class="line">            self.post_order(root.rchild)</span><br><span class="line">            print(root.data, end=&quot;,&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 遍历</span><br><span class="line">tree = BST([4, 6, 7, 9, 2, 1, 3, 5, 8])</span><br><span class="line">print(&quot;前序遍历：&quot;)</span><br><span class="line">tree.pre_order(tree.root)</span><br><span class="line">print()</span><br><span class="line">print(&quot;中序遍历(对于二叉搜索树来说中序遍历一定是升序的)：&quot;)</span><br><span class="line">tree.in_order(tree.root)</span><br><span class="line">print()</span><br><span class="line">print(&quot;后序遍历：&quot;)</span><br><span class="line">tree.post_order(tree.root)</span><br><span class="line">print()</span><br><span class="line"># 查询</span><br><span class="line">li = list(range(0, 500, 2))</span><br><span class="line">random.shuffle(li)</span><br><span class="line">tree = BST(li)</span><br><span class="line">print(tree.query_norec(4))</span><br><span class="line"># 删除</span><br><span class="line">tree = BST([1, 4, 2, 5, 3, 8, 9, 6, 9, 7])</span><br><span class="line">tree.in_order(tree.root)</span><br><span class="line">tree.delete(4)</span><br><span class="line">tree.delete(5)</span><br><span class="line">tree.delete(1)</span><br><span class="line">print()</span><br><span class="line">tree.in_order(tree.root)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="AVL树-代码看不懂-没学明白-暂时记录下来"><a href="#AVL树-代码看不懂-没学明白-暂时记录下来" class="headerlink" title="AVL树(代码看不懂 没学明白 暂时记录下来)"></a>AVL树(代码看不懂 没学明白 暂时记录下来)</h3><p>AVL树是一棵自平衡的二叉搜索树，具有以下性质:<br>树的左右子树高度差的绝对值不能超过1<br>根的左右子树都是平衡二叉树<br>AVL树的扩展应用：B树(B-Tree):<br>b树是一棵自平衡的多路搜索树，常用于数据库的索引</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line">from bst import BST, BitreeNode</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class AVLNode(BitreeNode):</span><br><span class="line">    def __init__(self, data):</span><br><span class="line">        BitreeNode.__init__(self, data)</span><br><span class="line">        self.bf = 0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class AVLTree(BST):</span><br><span class="line">    def __init__(self, li=None):</span><br><span class="line">        BST.__init__(self, li)</span><br><span class="line"></span><br><span class="line">    def rotate_left(self, p, c):</span><br><span class="line">        # 根的右孩子的右子树插入导致的不平衡：左旋操作</span><br><span class="line">        s2 = c.lchild</span><br><span class="line">        p.rchild = s2</span><br><span class="line">        if s2:</span><br><span class="line">            s2.parent = p</span><br><span class="line">        c.lchild = p</span><br><span class="line">        p.parent = c</span><br><span class="line">        # 更新平衡因子</span><br><span class="line">        p.bf = 0</span><br><span class="line">        c.bf = 0</span><br><span class="line">        return c</span><br><span class="line"></span><br><span class="line">    def rotate_right(self, p, c):</span><br><span class="line">        # 根的左孩子的左子树插入导致的不平衡：右旋操作</span><br><span class="line">        s2 = c.rchild</span><br><span class="line">        p.lchild = s2</span><br><span class="line">        if s2:</span><br><span class="line">            s2.parent = p</span><br><span class="line">        c.rchild = p</span><br><span class="line">        p.parent = c</span><br><span class="line">        # 更新平衡因子</span><br><span class="line">        p.bf = 0</span><br><span class="line">        c.bf = 0</span><br><span class="line">        return c</span><br><span class="line"></span><br><span class="line">    def rotate_right_left(self, p, c):</span><br><span class="line">        # 根的右孩子的左子树插入导致的不平衡，先右旋再左旋</span><br><span class="line">        g = c.lchild</span><br><span class="line">        s3 = g.rchild</span><br><span class="line">        c.lchild = s3</span><br><span class="line">        if s3:</span><br><span class="line">            s3.parent = c</span><br><span class="line">        g.rchild = c</span><br><span class="line">        c.parent = g</span><br><span class="line">        s2 = g.lchild</span><br><span class="line">        p.rchild = s2</span><br><span class="line">        if s2:</span><br><span class="line">            s2.parent = p</span><br><span class="line">        g.lchild = p</span><br><span class="line">        p.parent = g</span><br><span class="line">        # 更新平衡因子</span><br><span class="line">        if g.bf &gt; 0:</span><br><span class="line">            p.bf = -1</span><br><span class="line">            c.bf = 0</span><br><span class="line">        elif g.bf &lt; 0:</span><br><span class="line">            p.bf = 0</span><br><span class="line">            c.bf = 1</span><br><span class="line">        else:</span><br><span class="line">            p.bf = 0</span><br><span class="line">            c.bf = 0</span><br><span class="line"></span><br><span class="line">    def rotate_left_right(self, p, c):</span><br><span class="line">        # 根的左孩子的右子树插入导致的不平衡，先左旋再右旋</span><br><span class="line">        g = c.rchild</span><br><span class="line">        s2 = g.lchild</span><br><span class="line">        c.rchild = s2</span><br><span class="line">        if s2:</span><br><span class="line">            s2.parent = c</span><br><span class="line">        g.lchild = c</span><br><span class="line">        c.parent = g</span><br><span class="line">        s3 = g.rchild</span><br><span class="line">        p.lchild = s3</span><br><span class="line">        if s3:</span><br><span class="line">            s3.parent = p</span><br><span class="line">        g.rchild = p</span><br><span class="line">        p.parent = g</span><br><span class="line">        # 更新因子</span><br><span class="line">        if g.bf &lt; 0:</span><br><span class="line">            p.bf = 1</span><br><span class="line">            c.bf = 0</span><br><span class="line">        elif g.bf &gt; 0:</span><br><span class="line">            p.bf = 0</span><br><span class="line">            c.bf = -1</span><br><span class="line">        else:</span><br><span class="line">            p.bf = 0</span><br><span class="line">            c.bf = 0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构-链表</title>
      <link href="/2023/07/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/"/>
      <url>/2023/07/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p>链表也是比较常见的数据结构，其与数组经常做对比，<br>对于数组，需要连续的内存地址来存储数据，对内存的要求较高，而链表恰恰相反，它并不需要一块连续的内存空间，它通过“指针”将一组零散的内存块串联起来使用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">class Node:</span><br><span class="line">    def __init__(self, item):</span><br><span class="line">        self.item = item</span><br><span class="line">        self.next = None</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def create_head_linklist(li):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    头插法创建链表</span><br><span class="line">    :param li:</span><br><span class="line">    :return:</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    head = Node(li[0])</span><br><span class="line">    for element in li[1:]:</span><br><span class="line">        node = Node(element)</span><br><span class="line">        node.next = head</span><br><span class="line">        head = node</span><br><span class="line">    return head</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def create_tail_linklist(li):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    尾插法创建链表</span><br><span class="line">    :param li:</span><br><span class="line">    :return:</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    head = Node(li[0])</span><br><span class="line">    tail = head</span><br><span class="line">    for element in li[1:]:</span><br><span class="line">        node = Node(element)</span><br><span class="line">        tail.next = node</span><br><span class="line">        tail = node</span><br><span class="line">    return head</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def print_linklist(lk):</span><br><span class="line">    while lk:</span><br><span class="line">        print(lk.item, end=&quot;,&quot;)</span><br><span class="line">        lk = lk.next</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">lk1 = create_head_linklist([1, 2, 3, 4, 5])</span><br><span class="line">lk2 = create_tail_linklist([4, 5, 6, 7, 8])</span><br><span class="line">print_linklist(lk1)</span><br><span class="line">print()</span><br><span class="line">print_linklist(lk2)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构-hash表</title>
      <link href="/2023/07/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-hash%E8%A1%A8/"/>
      <url>/2023/07/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-hash%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><p>hash表又叫散列表<br>hash表是一种线性表的存储结构，哈希表由一个直接寻址表和一个哈希函数组成，哈希函数h(k)将元素关键字作为自变量，返回元素的存储下标<br>由于哈希表的大小是有限的，而要存储的值的总数量无限的，由此对于任何哈希函数，都会出现两个不同元素映射到同一个位置上的情况，这种情况被称为哈希冲突<br>解决哈希冲突：<br>开放寻址法：如果哈希函数返回的位置已经有了值，则可以向后探查新的位置来存储这个值<br>1、线性探查：如果位置i被占用，则探查i+1，i+2…<br>2、二次探查：如果位置i被占用，则探查i+1的平方、i-1的平方、i+2的平方、i-2的平方<br>3、二度哈希：有n个哈希函数，当使用第一个哈希函数h1发生冲突时，尝试使用哈希函数h2、h3<br>拉链法：哈希表的每一个位置都连接一个链表，当冲突发生后，冲突的元素将被加到改位置链表的最后<br>常见的hash函数：<br>1、除法哈希：h(k) &#x3D; k % m<br>2、乘法哈希：h(k) &#x3D; floor(m*(A<em>key%1))<br>3、全域哈希：ha,b(k) &#x3D; ((a</em>key+b)%p)%m   a,b &#x3D;1,2,..p-1<br>哈希表的应用：<br>python中的字典和集合都是使用和哈希表来实现的<br>文件的哈希值若是相同的，我们就认为这两个文件是相同的，因此用户可以通过md5来验证文件是否完整，云存储服务商可以利用它来判断用户<br>要上传的文件，是否已经存在相同服务器上，从而实现秒传功能同时避免存储过的相同的副本</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line">class LinkList:</span><br><span class="line">    class Node:</span><br><span class="line">        def __init__(self, item=None):</span><br><span class="line">            self.item = item</span><br><span class="line">            self.next = None</span><br><span class="line"></span><br><span class="line">    class LinkListIterator:</span><br><span class="line">        def __init__(self, node):</span><br><span class="line">            self.node = node</span><br><span class="line"></span><br><span class="line">        def __next__(self):</span><br><span class="line">            if self.node:</span><br><span class="line">                cur_node = self.node</span><br><span class="line">                self.node = cur_node.next</span><br><span class="line">                return cur_node.item</span><br><span class="line">            else:</span><br><span class="line">                raise StopIteration</span><br><span class="line"></span><br><span class="line">        def __iter__(self):</span><br><span class="line">            return self</span><br><span class="line"></span><br><span class="line">    def __init__(self, iterable=None):</span><br><span class="line">        self.head = None</span><br><span class="line">        self.tail = None</span><br><span class="line">        if iterable:</span><br><span class="line">            self.extend(iterable)</span><br><span class="line"></span><br><span class="line">    def append(self, obj):</span><br><span class="line">        s = LinkList.Node(obj)</span><br><span class="line">        if not self.head:</span><br><span class="line">            self.head = s</span><br><span class="line">            self.tail = s</span><br><span class="line">        else:</span><br><span class="line">            self.tail.next = s</span><br><span class="line">            self.tail = s</span><br><span class="line"></span><br><span class="line">    def extend(self, iterable):</span><br><span class="line">        for obj in iterable:</span><br><span class="line">            self.append(obj)</span><br><span class="line"></span><br><span class="line">    def find(self, obj):</span><br><span class="line">        for n in self:</span><br><span class="line">            if n == obj:</span><br><span class="line">                return True</span><br><span class="line">        else:</span><br><span class="line">            return False</span><br><span class="line"></span><br><span class="line">    def __iter__(self):</span><br><span class="line">        return self.LinkListIterator(self.head)</span><br><span class="line"></span><br><span class="line">    def __repr__(self):</span><br><span class="line">        return &quot;&lt;&lt;&quot; + &quot;,&quot;.join(map(str, self)) + &quot;&gt;&gt;&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 类似于集合的结构</span><br><span class="line">class HashTable:</span><br><span class="line">    def __init__(self, size=101):</span><br><span class="line">        self.size = size</span><br><span class="line">        self.T = [LinkList() for i in range(self.size)]</span><br><span class="line"></span><br><span class="line">    def h(self, k):</span><br><span class="line">        return k % self.size</span><br><span class="line"></span><br><span class="line">    # 插入</span><br><span class="line">    def insert(self, k):</span><br><span class="line">        i = self.h(k)</span><br><span class="line">        if self.find(k):</span><br><span class="line">            print(f&quot;Duplicated Inserted:值:&#123;k&#125;重复插入了&quot;)</span><br><span class="line">        else:</span><br><span class="line">            self.T[i].append(k)</span><br><span class="line"></span><br><span class="line">    # 查找</span><br><span class="line">    def find(self, k):</span><br><span class="line">        i = self.h(k)</span><br><span class="line">        return self.T[i].find(k)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ht = HashTable()</span><br><span class="line">ht.insert(0)</span><br><span class="line">ht.insert(1)</span><br><span class="line">ht.insert(102)</span><br><span class="line">ht.insert(2)</span><br><span class="line">ht.insert(3)</span><br><span class="line">ht.insert(508)</span><br><span class="line">ht.insert(4)</span><br><span class="line">ht.insert(5)</span><br><span class="line">print(&quot;,&quot;.join(map(str, ht.T)))</span><br><span class="line">print(ht.find(102))</span><br><span class="line">print(ht.find(200))</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>经典迷宫问题</title>
      <link href="/2023/07/24/%E7%BB%8F%E5%85%B8%E8%BF%B7%E5%AE%AB%E9%97%AE%E9%A2%98/"/>
      <url>/2023/07/24/%E7%BB%8F%E5%85%B8%E8%BF%B7%E5%AE%AB%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="迷宫问题简单描述"><a href="#迷宫问题简单描述" class="headerlink" title="迷宫问题简单描述"></a>迷宫问题简单描述</h2><p>指定起点和终点，使用深度优先和广度优先两种搜索算法来完成从起点到终点的整个过程，迷宫中1表示墙0表示路<br>深度优先搜索是完成从起点到终点的任务无法解决最短路径问题、广度优先可以解决最短路径问题</p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">maze = [</span><br><span class="line">    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],</span><br><span class="line">    [1, 0, 0, 1, 0, 0, 0, 1, 0, 1],</span><br><span class="line">    [1, 0, 0, 1, 0, 0, 0, 1, 0, 1],</span><br><span class="line">    [1, 0, 0, 0, 0, 1, 1, 0, 0, 1],</span><br><span class="line">    [1, 0, 1, 1, 1, 0, 0, 0, 0, 1],</span><br><span class="line">    [1, 0, 0, 0, 1, 0, 0, 0, 0, 1],</span><br><span class="line">    [1, 0, 1, 0, 0, 0, 1, 0, 0, 1],</span><br><span class="line">    [1, 0, 1, 1, 1, 0, 1, 1, 0, 1],</span><br><span class="line">    [1, 1, 0, 0, 0, 0, 0, 0, 0, 1],</span><br><span class="line">    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"># 表示上下左右</span><br><span class="line">dirs = [</span><br><span class="line">    lambda x, y: (x + 1, y),</span><br><span class="line">    lambda x, y: (x - 1, y),</span><br><span class="line">    lambda x, y: (x, y - 1),</span><br><span class="line">    lambda x, y: (x, y + 1),</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h2 id="深度优先py代码实现"><a href="#深度优先py代码实现" class="headerlink" title="深度优先py代码实现"></a>深度优先py代码实现</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">def maze_path_depth(x1, y1, x2, y2):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    深度优先搜索-代码简单但是路径不能保证是最短</span><br><span class="line">    :param x1:起点位置</span><br><span class="line">    :param y1: 起点位置</span><br><span class="line">    :param x2: 终点位置</span><br><span class="line">    :param y2: 终点位置</span><br><span class="line">    :return:</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    stack = []</span><br><span class="line">    stack.append((x1, y1))</span><br><span class="line">    while (len(stack) &gt; 0):</span><br><span class="line">        curNode = stack[-1]  # 当前节点</span><br><span class="line">        if curNode[0] == x2 and curNode[1] == y2:</span><br><span class="line">            # 走到终点了</span><br><span class="line">            for p in stack:</span><br><span class="line">                print(p, end=&quot;-&gt;&quot;)</span><br><span class="line">            return True</span><br><span class="line">        # x，y表示四个方向，上下左右分别是 x-1,y x+1,y x,y-1 x,y+1</span><br><span class="line">        for dir in dirs:</span><br><span class="line">            nextNode = dir(curNode[0], curNode[1])</span><br><span class="line">            # 如果下一个节点能走 就入栈</span><br><span class="line">            if maze[nextNode[0]][nextNode[1]] == 0:</span><br><span class="line">                stack.append(nextNode)</span><br><span class="line">                maze[nextNode[0]][nextNode[1]] = 2  # 2表示已经走过</span><br><span class="line">                break</span><br><span class="line">        else:</span><br><span class="line">            maze[nextNode[0]][nextNode[1]] = 2  # 2表示已经走过</span><br><span class="line">            stack.pop()</span><br><span class="line">    else:</span><br><span class="line">        print(&quot;没有路&quot;)</span><br><span class="line">        return False</span><br></pre></td></tr></table></figure><h2 id="广度优先py代码实现"><a href="#广度优先py代码实现" class="headerlink" title="广度优先py代码实现"></a>广度优先py代码实现</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">from collections import deque</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def print_r(path):</span><br><span class="line">    curNode = path[-1]</span><br><span class="line">    realpath = []</span><br><span class="line">    while curNode[2] != -1:</span><br><span class="line">        realpath.append(curNode[0:2])</span><br><span class="line">        curNode = path[curNode[2]]</span><br><span class="line">    realpath.append(curNode[0:2])  # 把起点放入path</span><br><span class="line">    realpath.reverse()</span><br><span class="line">    for node in realpath:</span><br><span class="line">        print(node, end=&quot;-&gt;&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def maze_path_queue(x1, y1, x2, y2):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    广度优先搜索</span><br><span class="line">    :param x1:起点位置</span><br><span class="line">    :param y1: 起点位置</span><br><span class="line">    :param x2: 终点位置</span><br><span class="line">    :param y2: 终点位置</span><br><span class="line">    :return:</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    queue = deque()</span><br><span class="line">    queue.append((x1, y1, -1))</span><br><span class="line">    path = []</span><br><span class="line">    while len(queue) &gt; 0:</span><br><span class="line">        curNode = queue.popleft()</span><br><span class="line">        path.append(curNode)</span><br><span class="line">        if curNode[0] == x2 and curNode[1] == y2:</span><br><span class="line">            # 说明此时到达了终点</span><br><span class="line">            print_r(path)</span><br><span class="line">            return True</span><br><span class="line">        for dir in dirs:</span><br><span class="line">            nextNode = dir(curNode[0], curNode[1])</span><br><span class="line">            if maze[nextNode[0]][nextNode[1]] == 0:</span><br><span class="line">                queue.append((nextNode[0], nextNode[1], len(path) - 1))  # 后续节点进队，记录哪个节点带他来的</span><br><span class="line">                maze[nextNode[0]][nextNode[1]] = 2  # 标记为已经走过</span><br><span class="line">    else:</span><br><span class="line">        print(&quot;没有路&quot;)</span><br><span class="line">        return False</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>汉诺塔问题</title>
      <link href="/2023/07/24/%E6%B1%89%E8%AF%BA%E5%A1%94%E9%97%AE%E9%A2%98/"/>
      <url>/2023/07/24/%E6%B1%89%E8%AF%BA%E5%A1%94%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="汉诺塔问题简单描述："><a href="#汉诺塔问题简单描述：" class="headerlink" title="汉诺塔问题简单描述："></a>汉诺塔问题简单描述：</h2><p>问题规则：Hanoi(汉诺)塔问题。古代有一个焚塔，塔内有3个座A,B,C,开始时A座上有64个盘子，<br>盘子大小不等，大的在上，小的在下，有一个老和尚想把这64个盘子从A座移到C座，但规定每次只允许移到一个盘，<br>且在移动过程中在3个座上都始终保持大盘在下，小盘在上，在移动过程中可以利用B座。输出移动盘子的步骤。</p><h2 id="py代码实现"><a href="#py代码实现" class="headerlink" title="py代码实现"></a>py代码实现</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># hanoi函数的参数表示的是n个盘子从a经过b移动到c</span><br><span class="line">def hanoi(n, a, b, c):</span><br><span class="line">    if n &gt; 0:</span><br><span class="line">        hanoi(n - 1, a, c, b)</span><br><span class="line">        print(&quot;moving from %s to %s&quot; % (a, c))</span><br><span class="line">        hanoi(n - 1, b, a, c)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">hanoi(3, &quot;A&quot;, &quot;B&quot;, &quot;C&quot;)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排序算法补充</title>
      <link href="/2023/07/24/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E8%A1%A5%E5%85%85/"/>
      <url>/2023/07/24/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E8%A1%A5%E5%85%85/</url>
      
        <content type="html"><![CDATA[<h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><p>希尔排序是一种插入排序变种属于分组插入排序</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">def insert_sort_gap(li, gap):</span><br><span class="line">    for i in range(gap, len(li)):</span><br><span class="line">        tmp = li[i]</span><br><span class="line">        j = i - gap</span><br><span class="line">        while j &gt;= 0 and li[j] &gt; tmp:</span><br><span class="line">            li[j + gap] = li[j]</span><br><span class="line">            j -= gap</span><br><span class="line">        li[j + gap] = tmp</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def shell_sort(li):</span><br><span class="line">    d = len(li) // 2</span><br><span class="line">    while d &gt;= 1:</span><br><span class="line">        insert_sort_gap(li, d)</span><br><span class="line">        d //= 2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">li = list(range(1000))</span><br><span class="line">import random</span><br><span class="line"></span><br><span class="line">random.shuffle(li)</span><br><span class="line">print(li)</span><br><span class="line">shell_sort(li)</span><br><span class="line">print(li)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2><p>基数排序就是把数据从个位数往上按顺序入桶并且按顺序出桶  即可完成排序</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">def radix_sort(li):</span><br><span class="line">    max_num = max(li)</span><br><span class="line">    it = 0</span><br><span class="line">    while 10 ** it &lt;= max_num:</span><br><span class="line">        buckets = [[] for _ in range(10)]</span><br><span class="line">        for var in li:</span><br><span class="line">            digit = (var // 10 ** it) % 10</span><br><span class="line">            buckets[digit].append(var)</span><br><span class="line">        # 分桶完成</span><br><span class="line">        li.clear()</span><br><span class="line">        for buc in buckets:</span><br><span class="line">            li.extend(buc)</span><br><span class="line">        # 把数据重新写回li</span><br><span class="line">        it += 1</span><br><span class="line"></span><br><span class="line">import random</span><br><span class="line">li = list(range(1000))</span><br><span class="line">random.shuffle(li)</span><br><span class="line">print(li)</span><br><span class="line">radix_sort(li)</span><br><span class="line">print(li)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用算法学习</title>
      <link href="/2023/07/24/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"/>
      <url>/2023/07/24/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="查找算法"><a href="#查找算法" class="headerlink" title="查找算法"></a>查找算法</h2><h3 id="1-线性查找"><a href="#1-线性查找" class="headerlink" title="1.线性查找"></a>1.线性查找</h3><p>就是一个一个从前往后查找</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def line_search(list,val):</span><br><span class="line">    for i in range(len(li)):</span><br><span class="line">        if list[i] == val:</span><br><span class="line">            return  i</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2-二分查找、折半查找"><a href="#2-二分查找、折半查找" class="headerlink" title="2.二分查找、折半查找"></a>2.二分查找、折半查找</h3><p>前提是列表必须是有序的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"># 该函数的参数分别是有序列表和要查找的值</span><br><span class="line">def binnary_search(li, val):</span><br><span class="line">    left = 0</span><br><span class="line">    right = len(li) - 1</span><br><span class="line">    while left &lt;= right:</span><br><span class="line">        # 条件是要保证候选区有值</span><br><span class="line">        mid = (left + right) // 2</span><br><span class="line">        if li[mid] == val:</span><br><span class="line">            # 匹配成功 返回下标</span><br><span class="line">            return mid</span><br><span class="line">        elif li[mid] &lt;= val:</span><br><span class="line">            # 中间值小于等于val说明候选区在mid右边</span><br><span class="line">            left = mid + 1</span><br><span class="line">        else:</span><br><span class="line">            # 中间值大于等于val说明候选区在mid的左边</span><br><span class="line">            right = mid - 1</span><br><span class="line">    else:</span><br><span class="line">        # 没找到</span><br><span class="line">        return None</span><br><span class="line"></span><br><span class="line">list = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</span><br><span class="line">print(f&quot;查找数据所在下标为：&#123;binnary_search(list, 2)&#125;&quot;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>python的内置查找函数index就是使用的线性查找，二分查找虽然但是有有序前提</p><h2 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h2><h3 id="1-冒泡排序"><a href="#1-冒泡排序" class="headerlink" title="1.冒泡排序"></a>1.冒泡排序</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">import random</span><br><span class="line">def bubble_sort(li):</span><br><span class="line">    for i in range(len(li)):</span><br><span class="line">        for j in range(len(li) - i - 1):</span><br><span class="line">            if li[j] &gt; li[j + 1]:</span><br><span class="line">                # 调换位置 把值大的冒出去 升序排列(把if判断条件改为小于即为降序排列)</span><br><span class="line">                li[j], li[j + 1] = li[j + 1], li[j]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 冒泡排序优化 如果在一次排序中没有顺序移动 说明之后‘未排序’的数已经做好了排序 因此就不需要再做之后的冒泡 直接返回结果即可</span><br><span class="line">def bubble_sort_plus(li):</span><br><span class="line">    for i in range(len(li)):</span><br><span class="line">        exchange = False</span><br><span class="line">        for j in range(len(li) - i - 1):</span><br><span class="line">            if li[j] &gt; li[j + 1]:</span><br><span class="line">                # 调换位置 把值大的冒出去 升序排列(把if判断条件改为小于即为降序排列)</span><br><span class="line">                li[j], li[j + 1] = li[j + 1], li[j]</span><br><span class="line">                exchange = True</span><br><span class="line">        if exchange is False:</span><br><span class="line">            return</span><br><span class="line">        # 列表生成式 生成一个长度为100的每一项为0-1000之间的数的列表</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">li = [random.randint(0, 1000) for i in range(100)]</span><br><span class="line">print(li)</span><br><span class="line">bubble_sort(li)</span><br><span class="line">print(li)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2-选择排序"><a href="#2-选择排序" class="headerlink" title="2.选择排序:"></a>2.选择排序:</h3><p>选择排序是要在无序区遍历拿到最小的数 然后跟之前所记录的最小的数做交换<br>注意：有序区、无序区、无序区最小数的位置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">def search_sort(li):</span><br><span class="line">    for i in range(len(li) - 1):</span><br><span class="line">        min_loc = i</span><br><span class="line">        for j in range(i + 1, len(li)):</span><br><span class="line">            if li[j] &lt; li[min_loc]:</span><br><span class="line">                min_loc = j</span><br><span class="line">        li[i], li[min_loc] = li[min_loc], li[i]</span><br><span class="line">        print(li)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">li = [1, 4, 2, 3, 6, 9, 7]</span><br><span class="line">print(li)</span><br><span class="line">search_sort(li)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3-插入排序"><a href="#3-插入排序" class="headerlink" title="3.插入排序"></a>3.插入排序</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">def insert_sort(li):</span><br><span class="line">    for i in range(1, len(li)):  # i表示摸到牌的下标</span><br><span class="line">        temp = li[i]</span><br><span class="line">        j = i - 1  # j是手里的牌的下标</span><br><span class="line">        if j &gt;= 0 and li[j] &gt; temp:</span><br><span class="line">            li[j + 1] = li[j]</span><br><span class="line">            j -= 1</span><br><span class="line">        li[j+1] = temp</span><br><span class="line">        print(li)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">li = [1, 4, 2, 3, 6, 9, 5]</span><br><span class="line">print(li)</span><br><span class="line">insert_sort(li)</span><br></pre></td></tr></table></figure><h3 id="4-快速排序"><a href="#4-快速排序" class="headerlink" title="4.快速排序"></a>4.快速排序</h3><p>快速排序的思路就是递归的让列表中的一个数据被放列表的合适的位置<br>一次归位要保证归位的这个数一定能到达准确的位置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"># 归位函数</span><br><span class="line">def partition(li, left, right):</span><br><span class="line">    tmp = li[left]</span><br><span class="line">    while left &lt; right:</span><br><span class="line">        while left &lt; right and li[right] &gt;= tmp:  # 在右边找比tmp小的数 进行移动</span><br><span class="line">            right -= 1  # 往左走一步</span><br><span class="line">        li[left] = li[right]  # 把右边的值写到左边空位置上</span><br><span class="line">        while left &lt; right and li[left] &lt;= tmp:  # 在左边找比tmp大的数 进行移动</span><br><span class="line">            left += 1  # 往右走一步</span><br><span class="line">        li[right] = li[left]  # 把左边的值写到右边空位上</span><br><span class="line">    li[left] = tmp  # 把tmp归位</span><br><span class="line">    return left</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 递归调用实现快速排序</span><br><span class="line">def quick_sort(li, left, right):</span><br><span class="line">    if left &lt; right:</span><br><span class="line">        mid = partition(li, left, right)  # 获取中间值</span><br><span class="line">        quick_sort(li, left, mid - 1)  # 递归左边</span><br><span class="line">        quick_sort(li, mid + 1, right)  # 递归右边</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">li = [5, 6, 3, 7, 1, 9, 8]</span><br><span class="line">quick_sort(li, 0, len(li)-1)</span><br><span class="line">print(li)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="5-堆排序"><a href="#5-堆排序" class="headerlink" title="5.堆排序"></a>5.堆排序</h3><p>学了半天python版的堆排序看不懂代码<br>于是在网上找了个能看得懂的c代码将其转换成了python代码 正常运行<br>整体思路就是先把list列表通过堆维护的性质将其建成堆、然后在排序的过程中一边交换堆顶元素和堆底元素的值同时再调用堆的维护函数保证大顶堆</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">def heapify(li, n, i):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    维护堆函数</span><br><span class="line">    :param li:待维护列表</span><br><span class="line">    :param n: 待维护列表的长度</span><br><span class="line">    :param i: 待维护节点的下标</span><br><span class="line">    :return:</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    # 父节点、左孩子、右孩子</span><br><span class="line">    largest = i</span><br><span class="line">    lson = i * 2 + 1</span><br><span class="line">    rson = i * 2 + 2</span><br><span class="line">    if lson &lt; n and li[largest] &lt; li[lson]:</span><br><span class="line">        largest = lson</span><br><span class="line">    if rson &lt; n and li[largest] &lt; li[rson]:</span><br><span class="line">        largest = rson</span><br><span class="line">    # 最开始定义的父节点等于i、如果父节点的不等于i、说明此时该交换了</span><br><span class="line">    if largest is not i:</span><br><span class="line">        li[largest], li[i] = li[i], li[largest]</span><br><span class="line">        heapify(li, n, largest)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def heap_sort(li, n):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    堆排序：分为两步1、建堆2、排序</span><br><span class="line">    :param li: 待排序数列表</span><br><span class="line">    :param n: 长度</span><br><span class="line">    :return:</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    # 建堆</span><br><span class="line">    for i in range(n // 2 - 1, -1, -1):</span><br><span class="line">        heapify(li, n, i)</span><br><span class="line">    # 排序</span><br><span class="line">    for i in range(n - 1, -1, -1):</span><br><span class="line">        # 交换堆顶和堆底的元素</span><br><span class="line">        li[i], li[0] = li[0], li[i]</span><br><span class="line">        # 传入堆和剩余元素的数量与待维护节点下标</span><br><span class="line">        heapify(li, i, 0)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    list = [2, 3, 8, 1, 4, 7, 9, 10, 17, 5]</span><br><span class="line">    print(list)</span><br><span class="line">    heap_sort(list, len(list))</span><br><span class="line">    print(list)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="6-归并排序"><a href="#6-归并排序" class="headerlink" title="6.归并排序"></a>6.归并排序</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">def merge(li, low, high, mid):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    归并排序</span><br><span class="line">    :param li: 列表</span><br><span class="line">    :param low: 左边初始下标</span><br><span class="line">    :param high: 右边的初始下标</span><br><span class="line">    :param mid: 中间的初始下标</span><br><span class="line">    :return:</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    i = low</span><br><span class="line">    j = mid + 1</span><br><span class="line">    ltmp = []</span><br><span class="line">    while i &lt;= mid and j &lt;= high:</span><br><span class="line">        if li[i] &lt; li[j]:</span><br><span class="line">            ltmp.append(li[i])</span><br><span class="line">            i += 1</span><br><span class="line">        else:</span><br><span class="line">            ltmp.append(li[j])</span><br><span class="line">            j += 1</span><br><span class="line">    # while执行完，一定有一部分没数了</span><br><span class="line">    while i &lt;= mid:</span><br><span class="line">        ltmp.append(li[i])</span><br><span class="line">        i += 1</span><br><span class="line">    while j &lt;= high:</span><br><span class="line">        ltmp.append(li[j])</span><br><span class="line">        j += 1</span><br><span class="line">    li[low:high + 1] = ltmp</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def merge_sort(li, low, high):</span><br><span class="line">    if low &lt; high:  # 至少有两个元素递归</span><br><span class="line">        mid = (low + high) // 2</span><br><span class="line">        merge_sort(li, low, mid)</span><br><span class="line">        merge_sort(li, mid + 1, high)</span><br><span class="line">        merge(li, low, high, mid)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    list = [2, 3, 8, 1, 4, 7, 9, 10, 17, 5]</span><br><span class="line">    print(list)</span><br><span class="line">    merge_sort(list, 0, len(list)-1)</span><br><span class="line">    print(list)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="排序总结"><a href="#排序总结" class="headerlink" title="排序总结"></a>排序总结</h3><p>456这三种排序算法运行的速度相当快，时间复杂度都是O(nlogn)<br>一般情况下就运行的时间而言：快速排序&lt;归并排序&lt;堆排序<br>三种算法的优缺点：<br>快速排序：在极端情况下排序的效率特别低<br>归并排序：需要额外的内存开销<br>堆排序：在这三种排序中相对较慢</p><table><thead><tr><th>排序方法</th><th align="center">最坏情况</th><th align="center">时间复杂度(最坏情况)</th><th align="center">时间复杂度(最好情况)</th><th align="center">空间复杂度</th><th align="center">稳定性</th><th align="right">代码复杂度</th></tr></thead><tbody><tr><td>冒泡排序</td><td align="center">O(n&#96;2)</td><td align="center">O(n&#96;2)</td><td align="center">O(n)</td><td align="center">O(1)</td><td align="center">稳定</td><td align="right">稳定</td></tr><tr><td>选择排序</td><td align="center">O(n&#96;2)</td><td align="center">O(n&#96;2)</td><td align="center">O(n&#96;2)</td><td align="center">O(1)</td><td align="center">不稳定</td><td align="right">简单</td></tr><tr><td>插入排序</td><td align="center">O(n&#96;2)</td><td align="center">O(n&#96;2)</td><td align="center">O(n&#96;2)</td><td align="center">O(1)</td><td align="center">稳定</td><td align="right">简单</td></tr><tr><td>快速排序</td><td align="center">O(n&#96;2)</td><td align="center">O(nlogn)</td><td align="center">O(nlogn)</td><td align="center">好:O(logn)坏:O(n)</td><td align="center">不稳定</td><td align="right">较复杂</td></tr><tr><td>堆排序</td><td align="center">O(nlogn)</td><td align="center">O(nlogn)</td><td align="center">O(nlogn)</td><td align="center">O(1)</td><td align="center">不稳定</td><td align="right">复杂</td></tr><tr><td>归并排序</td><td align="center">O(nlogn)</td><td align="center">O(nlogn)</td><td align="center">O(nlogn)</td><td align="center">O(n)</td><td align="center">稳定</td><td align="right">较复杂</td></tr></tbody></table>]]></content>
      
      
      
        <tags>
            
            <tag> 算法学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>更新1</title>
      <link href="/2023/07/14/%E6%9B%B4%E6%96%B01/"/>
      <url>/2023/07/14/%E6%9B%B4%E6%96%B01/</url>
      
        <content type="html"><![CDATA[<h2 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h2><p>新增看板白色小咪、B站追番列表<del>(但是很久不在B站追)</del>、音乐播放器<del>(这玩意时怎么好时坏)</del></p>]]></content>
      
      
      
        <tags>
            
            <tag> 更新 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的第一篇博文</title>
      <link href="/2023/07/14/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E6%96%87/"/>
      <url>/2023/07/14/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E6%96%87/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>之前写的新建的hexo博客由于安装包依赖等一系列问题，因为博主能力有限导致束手无策，因此删掉了整个blog目录，重新创建学习记录。</p><h2 id="相关"><a href="#相关" class="headerlink" title="相关"></a>相关</h2><p>本博客使用hexo博客框架,主题是butterfly</p><h2 id="关于我为什么要创建这个blog"><a href="#关于我为什么要创建这个blog" class="headerlink" title="关于我为什么要创建这个blog"></a>关于我为什么要创建这个blog</h2><p>希望通过blog的形式记录生活或工作上的一些事情，旨在记录，用blog的形式，希望未来能为自己留下一段回忆，共勉！</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
